<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql高级使用2</title>
    <url>/post/ae8fce6d.html</url>
    <content><![CDATA[<p>mysql高级使用-存储引擎-优化SQL-索引的使用-SQL的优化</p>
<a id="more"></a>



<h1 id="1-Mysql的体系结构概览"><a href="#1-Mysql的体系结构概览" class="headerlink" title="1. Mysql的体系结构概览"></a>1. Mysql的体系结构概览</h1><p> <img src="../images/mysql/2/2-1.jpg" alt="2-1"></p>
<p>整个MySQL Server由以下组成</p>
<ul>
<li>Connection Pool : 连接池组件</li>
<li>Management Services &amp; Utilities : 管理服务和工具组件</li>
<li>SQL Interface : SQL接口组件</li>
<li>Parser : 查询分析器组件</li>
<li>Optimizer : 优化器组件</li>
<li>Caches &amp; Buffers : 缓冲池组件</li>
<li>Pluggable Storage Engines : 存储引擎</li>
<li>File System : 文件系统</li>
</ul>
<ol>
<li><p>连接层</p>
<p>最上层是一些客户端和链接服务，包含本地sock 通信和大多数基于客户端/服务端工具实现的类似于 TCP/IP的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</li>
<li><p>服务层</p>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如 过程、函数等。在该层，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定表的查询的顺序，是否利用索引等， 最后生成相应的执行操作。如果是select语句，服务器还会查询内部的缓存，如果缓存空间足够大，这样在解决大量读操作的环境中能够很好的提升系统的性能。</p>
</li>
<li><p>引擎层</p>
<p>存储引擎层， 存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
</li>
<li><p>存储层</p>
<p>数据存储层， 主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ol>
<p>​    和其他数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用。主要体现在存储引擎上，插件式的存储引擎架构，将查询处理和其他的系统任务以及数据的存储提取分离。这种架构可以根据业务的需求和实际需要选择合适的存储引擎。</p>
<h1 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h1><h2 id="2-1-存储引擎概述"><a href="#2-1-存储引擎概述" class="headerlink" title="2.1 存储引擎概述"></a>2.1 存储引擎概述</h2><ul>
<li>和大多数的数据库不同, MySQL中有一个存储引擎的概念, 针对不同的存储需求可以选择最优的存储引擎。</li>
<li>存储引擎就是存储数据，建立索引，更新查询数据等等技术的实现方式 。存储引擎是基于表的，而不是基于库的。所以存储引擎也可被称为表类型。</li>
<li>Oracle，SqlServer等数据库只有一种存储引擎。MySQL提供了插件式的存储引擎架构。所以MySQL存在多种存储引擎，可以根据需要使用相应引擎，或者编写存储引擎。</li>
<li>MySQL5.0支持的存储引擎包含 ： InnoDB 、MyISAM 、BDB、MEMORY、MERGE、EXAMPLE、NDB Cluster、ARCHIVE、CSV、BLACKHOLE、FEDERATED等，其中InnoDB和BDB提供事务安全表，其他存储引擎是非事务安全表。</li>
</ul>
<p>可以通过指定 show engines ， 来查询当前数据库支持的存储引擎 ： </p>
<p><img src="../images/mysql/2/2-2.png" alt="2-2"></p>
<p>创建新表时如果不指定存储引擎，那么系统就会使用默认的存储引擎，MySQL5.5之前的默认存储引擎是MyISAM，5.5之后就改为了InnoDB。</p>
<p>查看Mysql数据库默认的存储引擎 ， 指令 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show variables like &#39;%storage_engine%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-3.png" alt="2-3"></p>
<h2 id="2-2-各种存储引擎特性"><a href="#2-2-各种存储引擎特性" class="headerlink" title="2.2 各种存储引擎特性"></a>2.2 各种存储引擎特性</h2><p>下面重点介绍几种常用的存储引擎， 并对比各个存储引擎之间的区别， 如下表所示 ： </p>
<table>
<thead>
<tr>
<th>特点</th>
<th>InnoDB</th>
<th>MyISAM</th>
<th>MEMORY</th>
<th>MERGE</th>
<th>NDB</th>
</tr>
</thead>
<tbody><tr>
<td>存储限制</td>
<td>64TB</td>
<td>有</td>
<td>有</td>
<td>没有</td>
<td>有</td>
</tr>
<tr>
<td>事务安全</td>
<td>==支持==</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>锁机制</td>
<td>==行锁(适合高并发)==</td>
<td>==表锁==</td>
<td>表锁</td>
<td>表锁</td>
<td>行锁</td>
</tr>
<tr>
<td>B树索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>哈希索引</td>
<td></td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
</tr>
<tr>
<td>全文索引</td>
<td>支持(5.6版本之后)</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>集群索引</td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>数据索引</td>
<td>支持</td>
<td></td>
<td>支持</td>
<td></td>
<td>支持</td>
</tr>
<tr>
<td>索引缓存</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>数据可压缩</td>
<td></td>
<td>支持</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>空间使用</td>
<td>高</td>
<td>低</td>
<td>N/A</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td>内存使用</td>
<td>高</td>
<td>低</td>
<td>中等</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>批量插入速度</td>
<td>低</td>
<td>高</td>
<td>高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>支持外键</td>
<td>==支持==</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>下面我们将重点介绍最长使用的两种存储引擎： InnoDB、MyISAM ， 另外两种 MEMORY、MERGE ， 了解即可。</p>
<h3 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h3><p>​    InnoDB存储引擎是Mysql的默认存储引擎。InnoDB存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全。但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间以保留数据和索引。</p>
<p>InnoDB存储引擎不同于其他存储引擎的特点 ： </p>
<h4 id="事务控制"><a href="#事务控制" class="headerlink" title="事务控制"></a>事务控制</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table goods_innodb(</span><br><span class="line">	id int NOT NULL AUTO_INCREMENT,</span><br><span class="line">	name varchar(20) NOT NULL,</span><br><span class="line">    primary key(id)</span><br><span class="line">)ENGINE&#x3D;innodb DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启事务</span><br><span class="line">start transaction;</span><br><span class="line">insert into goods_innodb(id,name)values(null,&#39;Meta20&#39;);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-4.png" alt="2-4"></p>
<p>测试，发现在InnoDB中是存在事务的 ；</p>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><p>​    MySQL支持外键的存储引擎只有InnoDB ， 在创建外键的时候， 要求父表必须有对应的索引 ， 子表在创建外键的时候， 也会自动的创建对应的索引。</p>
<p>​    下面两张表中 ， country_innodb是父表 ， country_id为主键索引，city_innodb表是子表，country_id字段为外键，对应于country_innodb表的主键country_id 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> country_innodb(</span><br><span class="line">	country_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    country_name <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(country_id)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> city_innodb(</span><br><span class="line">	city_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    city_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country_id <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(city_id),</span><br><span class="line">    <span class="keyword">key</span> idx_fk_country_id(country_id),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> <span class="string">`fk_city_country`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(country_id) <span class="keyword">REFERENCES</span> country_innodb(country_id) <span class="keyword">ON</span> <span class="keyword">DELETE</span> RESTRICT <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> country_innodb <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'China'</span>),(<span class="literal">null</span>,<span class="string">'America'</span>),(<span class="literal">null</span>,<span class="string">'Japan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> city_innodb <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'Xian'</span>,<span class="number">1</span>),(<span class="literal">null</span>,<span class="string">'NewYork'</span>,<span class="number">2</span>),(<span class="literal">null</span>,<span class="string">'BeiJing'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">ON <span class="keyword">DELETE</span> RESTRICT：删除主表数据时，如果有关联记录，不删除</span><br><span class="line"><span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CASCADE</span>：更新主表时，如果子表有关联记录，更新子表记录</span><br></pre></td></tr></table></figure>

<ul>
<li>在创建索引时， 可以指定在删除、更新父表时，对子表进行的相应操作，包括 RESTRICT、CASCADE、SET NULL 和 NO ACTION。</li>
<li>RESTRICT和NO ACTION相同， 是指限制在子表有关联记录的情况下， 父表不能更新；</li>
<li>CASCADE表示父表在更新或者删除时，更新或者删除子表对应的记录；</li>
<li>SET NULL 则表示父表在更新或者删除的时候，子表的对应字段被SET NULL 。</li>
</ul>
<p>​    针对上面创建的两个表， 子表的外键指定是ON DELETE RESTRICT ON UPDATE CASCADE 方式的， 那么在主表删除记录的时候， 如果子表有对应记录， 则不允许删除， 主表在更新记录的时候， 如果子表有对应记录， 则子表对应更新 。</p>
<p>表中数据如下图所示 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city_innodb;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> country_innodb;</span><br></pre></td></tr></table></figure>

<p> <img src="../images/mysql/2/2-6.png" alt="2-6"></p>
<h4 id="外键信息可以使用如下两种方式查看-："><a href="#外键信息可以使用如下两种方式查看-：" class="headerlink" title="外键信息可以使用如下两种方式查看 ："></a>外键信息可以使用如下两种方式<strong>查看</strong> ：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show create table city_innodb;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-7.png" alt="2-7"></p>
<h4 id="删除country-id为1-的country数据："><a href="#删除country-id为1-的country数据：" class="headerlink" title="删除country_id为1 的country数据："></a>删除country_id为1 的country数据：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete from country_innodb where country_id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-8.png" alt="2-8"></p>
<h4 id="更新主表country表的字段-country-id"><a href="#更新主表country表的字段-country-id" class="headerlink" title="更新主表country表的字段 country_id :"></a>更新主表country表的字段 country_id :</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">update country_innodb set country_id &#x3D; 100 where country_id &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>更新后， 子表的数据信息为 ： </p>
<p><img src="../images/mysql/2/2-9.png" alt="2-9"></p>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>InnoDB 存储表和索引有以下两种方式 ： </p>
<ul>
<li>使用共享表空间存储， 这种方式创建的表的表结构保存在.frm文件中， 数据和索引保存在 innodb_data_home_dir 和 innodb_data_file_path定义的表空间中，可以是多个文件。</li>
<li>使用多表空间存储， 这种方式创建的表的表结构仍然存在 .frm 文件中，但是每个表的数据和索引单独保存在 .ibd 中。 </li>
</ul>
<h3 id="2-2-2-MyISAM"><a href="#2-2-2-MyISAM" class="headerlink" title="2.2.2 MyISAM"></a>2.2.2 MyISAM</h3><p>​    MyISAM 不支持事务、也不支持外键，其优势是访问的速度快，对事务的完整性没有要求或者以SELECT、INSERT为主的应用基本上都可以使用这个引擎来创建表 。有以下两个比较重要的特点： </p>
<h4 id="不支持事务"><a href="#不支持事务" class="headerlink" title="不支持事务"></a>不支持事务</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> goods_myisam(</span><br><span class="line">	<span class="keyword">id</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	<span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=myisam <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>通过测试，我们发现，在MyISAM存储引擎中，是没有事务控制的 ；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">开启事务</span><br><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> goods_myisam(<span class="keyword">id</span>,<span class="keyword">name</span>)<span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'Meta20'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> goods_myisam;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-10.png" alt="2-10"></p>
<h4 id="文件存储方式"><a href="#文件存储方式" class="headerlink" title="文件存储方式"></a>文件存储方式</h4><p>每个MyISAM在磁盘上存储成3个文件，其文件名都和表名相同，但拓展名分别是 ： </p>
<ul>
<li>.frm (存储表定义)；</li>
<li>.MYD(MYData , 存储数据)；</li>
<li>.MYI(MYIndex , 存储索引)；</li>
</ul>
<h3 id="2-2-3-MEMORY"><a href="#2-2-3-MEMORY" class="headerlink" title="2.2.3 MEMORY"></a>2.2.3 MEMORY</h3><p>​    Memory存储引擎将表的数据存放在内存中。每个MEMORY表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。MEMORY 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用HASH索引 ， 但是服务一旦关闭，表中的数据就会丢失。</p>
<h3 id="2-2-4-MERGE"><a href="#2-2-4-MERGE" class="headerlink" title="2.2.4 MERGE"></a>2.2.4 MERGE</h3><p>​    MERGE存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有存储数据，对MERGE类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行的。</p>
<p>​    对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST 或 LAST 值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。</p>
<p>​    可以对MERGE表进行DROP操作，但是这个操作只是删除MERGE表的定义，对内部的表是没有任何影响的。</p>
<p><img src="../images/mysql/2/2-11.png" alt="2-11"></p>
<p>下面是一个创建和使用MERGE表的示例 ： </p>
<ul>
<li>创建3个测试表 order_1990, order_1991, order_all , 其中order_all是前两个表的MERGE表 ： </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_1990(</span><br><span class="line">	order_id <span class="built_in">int</span> ,</span><br><span class="line">	order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">	primary <span class="keyword">key</span> (order_id)</span><br><span class="line">)<span class="keyword">engine</span> = myisam <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_1991(</span><br><span class="line">	order_id <span class="built_in">int</span> ,</span><br><span class="line">	order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">	primary <span class="keyword">key</span> (order_id)</span><br><span class="line">)<span class="keyword">engine</span> = myisam <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> order_all(</span><br><span class="line">	order_id <span class="built_in">int</span> ,</span><br><span class="line">	order_money <span class="keyword">double</span>(<span class="number">10</span>,<span class="number">2</span>),</span><br><span class="line">	order_address <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">	primary <span class="keyword">key</span> (order_id)</span><br><span class="line">)<span class="keyword">engine</span> = <span class="keyword">merge</span> <span class="keyword">union</span> = (order_1990,order_1991) INSERT_METHOD=<span class="keyword">LAST</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>分别向两张表中插入记录 </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">100.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1990 <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">100.0</span>,<span class="string">'上海'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">10</span>,<span class="number">200.0</span>,<span class="string">'北京'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_1991 <span class="keyword">values</span>(<span class="number">11</span>,<span class="number">200.0</span>,<span class="string">'上海'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>查询3张表中的数据。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_1990;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_1991;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> order_all;</span><br></pre></td></tr></table></figure>

<p>order_1990中的数据、order_1991中的数据、 order_all中的数据 ：</p>
<p><img src="../images/mysql/2/2-12.png" alt="2-12"></p>
<ul>
<li>往order_all中插入一条记录 ，由于在MERGE表定义时，INSERT_METHOD 选择的是LAST，那么插入的数据会想最后一张表中插入。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> order_all <span class="keyword">values</span>(<span class="number">100</span>,<span class="number">10000.0</span>,<span class="string">'西安'</span>);</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-13.png" alt="2-13"></p>
<h2 id="2-3-存储引擎的选择"><a href="#2-3-存储引擎的选择" class="headerlink" title="2.3 存储引擎的选择"></a>2.3 存储引擎的选择</h2><p>​    在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。以下是几种常用的存储引擎的使用环境。</p>
<ul>
<li>InnoDB : 是Mysql的默认存储引擎，用于事务处理应用程序，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询意外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。InnoDB存储引擎除了有效的降低由于删除和更新导致的锁定， 还可以确保事务的完整提交和回滚，对于类似于计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB是最合适的选择。</li>
<li>MyISAM ： 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li>
<li>MEMORY：将所有数据保存在RAM中，在需要快速定位记录和其他类似数据环境下，可以提供几块的访问。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。MEMORY表通常用于更新不太频繁的小表，用以快速得到访问结果。</li>
<li>MERGE：用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用他们。MERGE表的优点在于可以突破对单个MyISAM表的大小限制，并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率。这对于存储诸如数据仓储等VLDB环境十分合适。</li>
</ul>
<h1 id="3-优化SQL步骤"><a href="#3-优化SQL步骤" class="headerlink" title="3. 优化SQL步骤"></a>3. 优化SQL步骤</h1><ul>
<li>在应用的的开发过程中，由于初期数据量小，开发人员写 SQL 语句时更重视功能上的实现，但是当应用系统正式上线后，随着生产数据量的急剧增长，很多 SQL 语句开始逐渐显露出性能问题，对生产的影响也越来越大，此时这些有问题的 SQL 语句就成为整个系统性能的瓶颈，因此我们必须要对它们进行优化，本章将详细介绍在 MySQL 中优化 SQL 语句的方法。</li>
<li>当面对一个有 SQL 性能问题的数据库时，我们应该从何处入手来进行系统的分析，使得能够尽快定位问题 SQL 并尽快解决问题。</li>
</ul>
<h2 id="3-1-查看SQL执行频率"><a href="#3-1-查看SQL执行频率" class="headerlink" title="3.1 查看SQL执行频率"></a>3.1 查看SQL执行频率</h2><ul>
<li>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以提供服务器状态信息。</li>
<li>show [session|global] status 可以根据需要加上参数“session”或者“global”来显示 session 级（当前连接）的计结果和 global 级（自数据库上次启动至今）的统计结果。</li>
<li>如果不写，默认使用参数是“session”。</li>
</ul>
<p>下面的命令显示了当前 session 中所有统计参数的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Com_______&#39;;</span><br><span class="line">&#x2F;&#x2F;查询全部</span><br><span class="line">show global status like &#39;Com_______&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-14.png" alt="2-14"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show status like &#39;Innodb_rows_%&#39;;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-15.png" alt="2-15"></p>
<p>Com_xxx 表示每个 xxx 语句执行的次数，我们通常比较关心的是以下几个统计参数。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Com_select</td>
<td>执行 select 操作的次数，一次查询只累加 1。</td>
</tr>
<tr>
<td align="left">Com_insert</td>
<td>执行 INSERT 操作的次数，对于批量插入的 INSERT 操作，只累加一次。</td>
</tr>
<tr>
<td align="left">Com_update</td>
<td>执行 UPDATE 操作的次数。</td>
</tr>
<tr>
<td align="left">Com_delete</td>
<td>执行 DELETE 操作的次数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_read</td>
<td>select 查询返回的行数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_inserted</td>
<td>执行 INSERT 操作插入的行数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_updated</td>
<td>执行 UPDATE 操作更新的行数。</td>
</tr>
<tr>
<td align="left">Innodb_rows_deleted</td>
<td>执行 DELETE 操作删除的行数。</td>
</tr>
<tr>
<td align="left">Connections</td>
<td>试图连接 MySQL 服务器的次数。</td>
</tr>
<tr>
<td align="left">Uptime</td>
<td>服务器工作时间。</td>
</tr>
<tr>
<td align="left">Slow_queries</td>
<td>慢查询的次数。</td>
</tr>
</tbody></table>
<ul>
<li>Com_***      :  这些参数对于所有存储引擎的表操作都会进行累计。_</li>
<li>Innodb_*** :  这几个参数只是针对InnoDB 存储引擎的，累加的算法也略有不同。</li>
</ul>
<h2 id="3-2-定位低效率执行SQL"><a href="#3-2-定位低效率执行SQL" class="headerlink" title="3.2 定位低效率执行SQL"></a>3.2 定位低效率执行SQL</h2><p>可以通过以下两种方式定位执行效率较低的 SQL 语句。</p>
<ul>
<li>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。具体可以查看本书第 26 章中日志管理的相关部分。</li>
<li>show processlist  : 慢查询日志在查询结束以后才纪录，所以在应用反映执行效率出现问题的时候查询慢查询日志并不能定位问题，可以使用show processlist命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</li>
</ul>
<p><img src="../images/mysql/2/2-5.png" alt="2-5"></p>
<ul>
<li>id列，用户登录mysql时，系统分配的”connection_id”，可以使用函数connection_id()查看</li>
<li>user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</li>
<li>host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</li>
<li>db列，显示这个进程目前连接的是哪个数据库</li>
<li>command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等</li>
<li>time列，显示这个状态持续的时间，单位是秒</li>
<li>state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</li>
<li>info列，显示这个sql语句，是判断问题语句的一个重要依据</li>
</ul>
<h2 id="3-3-explain分析执行计划"><a href="#3-3-explain分析执行计划" class="headerlink" title="3.3 explain分析执行计划"></a>3.3 explain分析执行计划</h2><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN或者 DESC命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<p>查询SQL语句的执行计划 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-19.png" alt="2-19"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span>  <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title = <span class="string">'阿尔卡特 (OT-979) 冰川白 联通3G手机3'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-20.png" alt="2-20"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。</td>
</tr>
<tr>
<td>select_type</td>
<td>表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（子查询中的第一个 SELECT）等</td>
</tr>
<tr>
<td>table</td>
<td>输出结果集的表</td>
</tr>
<tr>
<td>type</td>
<td>表示表的连接类型，性能由好到差的连接类型为( system  —&gt;  const  —–&gt;  eq_ref  ——&gt;  ref  ——-&gt;  ref_or_null—-&gt;  index_merge  —&gt;  index_subquery  —–&gt;  range  —–&gt;  index  ——&gt; all )</td>
</tr>
<tr>
<td>possible_keys</td>
<td>表示查询时，可能使用的索引</td>
</tr>
<tr>
<td>key</td>
<td>表示实际使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>索引字段的长度</td>
</tr>
<tr>
<td>rows</td>
<td>扫描行的数量</td>
</tr>
<tr>
<td>extra</td>
<td>执行情况的说明和描述</td>
</tr>
</tbody></table>
<h3 id="3-3-1-环境准备"><a href="#3-3-1-环境准备" class="headerlink" title="3.3.1 环境准备"></a>3.3.1 环境准备</h3><p><img src="../images/mysql/2/2-21.png" alt="2-21"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`role_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`role_code`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`description`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`unique_role_name`</span> (<span class="string">`role_name`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t_user`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`unique_user_username`</span> (<span class="string">`username`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_role`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment ,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`role_id`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_ur_user_id`</span> (<span class="string">`user_id`</span>),</span><br><span class="line">  <span class="keyword">KEY</span> <span class="string">`fk_ur_role_id`</span> (<span class="string">`role_id`</span>),</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_ur_role_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`role_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span>,</span><br><span class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`fk_ur_user_id`</span> <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (<span class="string">`user_id`</span>) <span class="keyword">REFERENCES</span> <span class="string">`t_user`</span> (<span class="string">`id`</span>) <span class="keyword">ON</span> <span class="keyword">DELETE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">NO</span> <span class="keyword">ACTION</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`t_user`</span> (<span class="string">`id`</span>, <span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`name`</span>) <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'super'</span>,<span class="string">'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe'</span>,<span class="string">'超级管理员'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`t_user`</span> (<span class="string">`id`</span>, <span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`name`</span>) <span class="keyword">values</span>(<span class="string">'2'</span>,<span class="string">'admin'</span>,<span class="string">'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe'</span>,<span class="string">'系统管理员'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`t_user`</span> (<span class="string">`id`</span>, <span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`name`</span>) <span class="keyword">values</span>(<span class="string">'3'</span>,<span class="string">'itcast'</span>,<span class="string">'$2a$10$8qmaHgUFUAmPR5pOuWhYWOr291WJYjHelUlYn07k5ELF8ZCrW0Cui'</span>,<span class="string">'test02'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`t_user`</span> (<span class="string">`id`</span>, <span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`name`</span>) <span class="keyword">values</span>(<span class="string">'4'</span>,<span class="string">'stu1'</span>,<span class="string">'$2a$10$pLtt2KDAFpwTWLjNsmTEi.oU1yOZyIn9XkziK/y/spH5rftCpUMZa'</span>,<span class="string">'学生1'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`t_user`</span> (<span class="string">`id`</span>, <span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`name`</span>) <span class="keyword">values</span>(<span class="string">'5'</span>,<span class="string">'stu2'</span>,<span class="string">'$2a$10$nxPKkYSez7uz2YQYUnwhR.z57km3yqKn3Hr/p1FR6ZKgc18u.Tvqm'</span>,<span class="string">'学生2'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`t_user`</span> (<span class="string">`id`</span>, <span class="string">`username`</span>, <span class="string">`password`</span>, <span class="string">`name`</span>) <span class="keyword">values</span>(<span class="string">'6'</span>,<span class="string">'t1'</span>,<span class="string">'$2a$10$TJ4TmCdK.X4wv/tCqHW14.w70U3CC33CeVncD3SLmyMXMknstqKRe'</span>,<span class="string">'老师1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>, <span class="string">`role_name`</span>, <span class="string">`role_code`</span>, <span class="string">`description`</span>) <span class="keyword">VALUES</span>(<span class="string">'5'</span>,<span class="string">'学生'</span>,<span class="string">'student'</span>,<span class="string">'学生'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>, <span class="string">`role_name`</span>, <span class="string">`role_code`</span>, <span class="string">`description`</span>) <span class="keyword">VALUES</span>(<span class="string">'7'</span>,<span class="string">'老师'</span>,<span class="string">'teacher'</span>,<span class="string">'老师'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>, <span class="string">`role_name`</span>, <span class="string">`role_code`</span>, <span class="string">`description`</span>) <span class="keyword">VALUES</span>(<span class="string">'8'</span>,<span class="string">'教学管理员'</span>,<span class="string">'teachmanager'</span>,<span class="string">'教学管理员'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>, <span class="string">`role_name`</span>, <span class="string">`role_code`</span>, <span class="string">`description`</span>) <span class="keyword">VALUES</span>(<span class="string">'9'</span>,<span class="string">'管理员'</span>,<span class="string">'admin'</span>,<span class="string">'管理员'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t_role`</span> (<span class="string">`id`</span>, <span class="string">`role_name`</span>, <span class="string">`role_code`</span>, <span class="string">`description`</span>) <span class="keyword">VALUES</span>(<span class="string">'10'</span>,<span class="string">'超级管理员'</span>,<span class="string">'super'</span>,<span class="string">'超级管理员'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> user_role(<span class="keyword">id</span>,user_id,role_id) <span class="keyword">VALUES</span>(<span class="literal">NULL</span>, <span class="string">'1'</span>, <span class="string">'5'</span>),(<span class="literal">NULL</span>, <span class="string">'1'</span>, <span class="string">'7'</span>),(<span class="literal">NULL</span>, <span class="string">'2'</span>, <span class="string">'8'</span>),(<span class="literal">NULL</span>, <span class="string">'3'</span>, <span class="string">'9'</span>),(<span class="literal">NULL</span>, <span class="string">'4'</span>, <span class="string">'8'</span>),(<span class="literal">NULL</span>, <span class="string">'5'</span>, <span class="string">'10'</span>) ;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-explain-之-id"><a href="#3-3-2-explain-之-id" class="headerlink" title="3.3.2 explain 之 id"></a>3.3.2 explain 之 id</h3><p>id 字段是 select查询的序列号，是一组数字，表示的是查询中执行select子句或者是操作表的顺序。id 情况有三种 ： </p>
<ol>
<li>id 相同表示加载表的顺序是从上到下。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_role r, t_user u, user_role ur <span class="keyword">where</span> r.id = ur.role_id <span class="keyword">and</span> u.id = ur.user_id ;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-22.png" alt="2-22"></p>
<ol start="2">
<li>id 不同id值越大，优先级越高，越先被执行。 </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role <span class="keyword">WHERE</span> <span class="keyword">id</span> = (<span class="keyword">SELECT</span> role_id <span class="keyword">FROM</span> user_role <span class="keyword">WHERE</span> user_id = (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> username = <span class="string">'stu1'</span>));</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-23.png" alt="2-23"></p>
<ol start="3">
<li>id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_role r , (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> user_role ur <span class="keyword">WHERE</span> ur.<span class="string">`user_id`</span> = <span class="string">'2'</span>) a <span class="keyword">WHERE</span> r.id = a.role_id ;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-24.png" alt="2-24"></p>
<h3 id="3-3-3-explain-之-select-type"><a href="#3-3-3-explain-之-select-type" class="headerlink" title="3.3.3 explain 之 select_type"></a>3.3.3 explain 之 select_type</h3><p> 表示 SELECT 的类型，常见的取值，如下表所示：</p>
<table>
<thead>
<tr>
<th>select_type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的select查询，查询中不包含子查询或者UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT 或 WHERE 列表中包含了子查询</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在FROM 列表中包含的子查询，被标记为 DERIVED（衍生） MYSQL会递归执行这些子查询，把结果放在临时表中</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则标记为UNION ； 若UNION包含在FROM子句的子查询中，外层SELECT将被标记为 ： DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
<p><img src="../images/mysql/2/2-16.png" alt="2-16"></p>
<h3 id="3-3-4-explain-之-table"><a href="#3-3-4-explain-之-table" class="headerlink" title="3.3.4 explain 之 table"></a>3.3.4 explain 之 table</h3><p>展示这一行的数据是关于哪一张表的 </p>
<h3 id="3-3-5-explain-之-type"><a href="#3-3-5-explain-之-type" class="headerlink" title="3.3.5 explain 之 type"></a>3.3.5 explain 之 type</h3><p>type 显示的是访问类型，是较为重要的一个指标，可取值为： </p>
<table>
<thead>
<tr>
<th>type</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>NULL</td>
<td>MySQL不访问任何表，索引，直接返回结果</td>
</tr>
<tr>
<td>system</td>
<td>表只有一行记录(等于系统表)，这是const类型的特例，一般不会出现</td>
</tr>
<tr>
<td>const</td>
<td>表示通过索引一次就找到了，const 用于比较primary key 或者 unique 索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL 就能将该查询转换为一个常亮。const于将 “主键” 或 “唯一” 索引的所有部分与常量值进行比较</td>
</tr>
<tr>
<td>eq_ref</td>
<td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，返回所有匹配某个单独值的所有行（多个）</td>
</tr>
<tr>
<td>range</td>
<td>只检索给定返回的行，使用一个索引来选择行。 where 之后出现 between ， &lt; , &gt; , in 等操作。</td>
</tr>
<tr>
<td>index</td>
<td>index 与 ALL的区别为  index 类型只是遍历了索引树， 通常比ALL 快， ALL 是遍历数据文件。</td>
</tr>
<tr>
<td>all</td>
<td>将遍历全表以找到匹配的行</td>
</tr>
</tbody></table>
<p>结果值从最好到最坏以此是：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>

<p>一般来说， 我们需要保证查询至少达到 range 级别， 最好达到ref 。</p>
<p><img src="../images/mysql/2/2-17.png" alt="2-17"></p>
<h3 id="3-3-6-explain-之-key"><a href="#3-3-6-explain-之-key" class="headerlink" title="3.3.6 explain 之  key"></a>3.3.6 explain 之  key</h3><ul>
<li>possible_keys : 显示可能应用在这张表的索引， 一个或多个。 </li>
<li>key ： 实际使用的索引， 如果为NULL， 则没有使用索引。</li>
<li>key_len : 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。</li>
</ul>
<h3 id="3-3-7-explain-之-rows"><a href="#3-3-7-explain-之-rows" class="headerlink" title="3.3.7 explain 之 rows"></a>3.3.7 explain 之 rows</h3><p>扫描行的数量。</p>
<h3 id="3-3-8-explain-之-extra"><a href="#3-3-8-explain-之-extra" class="headerlink" title="3.3.8 explain 之 extra"></a>3.3.8 explain 之 extra</h3><p>其他的额外的执行计划信息，在该列展示 。</p>
<table>
<thead>
<tr>
<th>extra</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>using  filesort</td>
<td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取， 称为 “文件排序”, 效率低。</td>
</tr>
<tr>
<td>using  temporary</td>
<td>使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于 order by 和 group by； 效率低</td>
</tr>
<tr>
<td>using  index</td>
<td>表示相应的select操作使用了覆盖索引， 避免访问表的数据行， 效率不错。</td>
</tr>
</tbody></table>
<p><img src="../images/mysql/2/2-18.png" alt="2-18"></p>
<h3 id="3-4-show-profile分析SQL"><a href="#3-4-show-profile分析SQL" class="headerlink" title="3.4 show profile分析SQL"></a>3.4 show profile分析SQL</h3><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了。</p>
<p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @@have_profiling;</span><br><span class="line"><span class="keyword">select</span> @@profiling;</span><br></pre></td></tr></table></figure>

<p>默认profiling是关闭的，可以通过set语句在Session级别开启profiling：</p>
<p><img src="../images/mysql/2/2-25.png" alt="2-25"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> profiling=<span class="number">1</span>; //开启profiling 开关；</span><br></pre></td></tr></table></figure>

<p>通过profile，我们能够更清楚地了解SQL执行的过程。</p>
<p>首先，我们可以执行一系列的操作，如下图所示：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span>;</span><br><span class="line"><span class="keyword">use</span> db01;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">5</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_item;</span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">profiles</span> <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p>执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</p>
<p><img src="../images/mysql/2/2-26.png" alt="2-26"></p>
<p>通过show  profile for  query  query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p>
<p> <img src="../images/mysql/2/2-27.png" alt="2-27"></p>
<p><strong>TIP ：</strong></p>
<ul>
<li>Sending data 状态表示MySQL线程开始访问数据行并把结果返回给客户端，而不仅仅是返回个客户端。由于在Sending data状态下，MySQL线程往往需要做大量的磁盘读取操作，所以经常是整各查询中耗时最长的状态。</li>
</ul>
<p>​    在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间  ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> <span class="keyword">query</span> <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-28.png" alt="2-28"></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Status</td>
<td>sql 语句执行的状态</td>
</tr>
<tr>
<td>Duration</td>
<td>sql 执行过程中每一个步骤的耗时</td>
</tr>
<tr>
<td>CPU_user</td>
<td>当前用户占有的cpu</td>
</tr>
<tr>
<td>CPU_system</td>
<td>系统占有的cpu</td>
</tr>
</tbody></table>
<h2 id="3-5-trace分析优化器执行计划"><a href="#3-5-trace分析优化器执行计划" class="headerlink" title="3.5 trace分析优化器执行计划"></a>3.5 trace分析优化器执行计划</h2><p>​    MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划。</p>
<p>​    打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">"enabled=on"</span>,end_markers_in_json=<span class="keyword">on</span>;</span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size=<span class="number">1000000</span>;</span><br></pre></td></tr></table></figure>

<p>执行SQL语句 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &lt; <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line">*************************** 1. row ***************************</span><br><span class="line">QUERY: select * from tb_item where id &lt; 4</span><br><span class="line">TRACE: &#123;</span><br><span class="line">  "steps": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"join_preparation"</span>: &#123;</span><br><span class="line">        <span class="attr">"select#"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"steps"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"expanded_query"</span>: <span class="string">"/* select#1 */ select `tb_item`.`id` AS `id`,`tb_item`.`title` AS `title`,`tb_item`.`price` AS `price`,`tb_item`.`num` AS `num`,`tb_item`.`categoryid` AS `categoryid`,`tb_item`.`status` AS `status`,`tb_item`.`sellerid` AS `sellerid`,`tb_item`.`createtime` AS `createtime`,`tb_item`.`updatetime` AS `updatetime` from `tb_item` where (`tb_item`.`id` &lt; 4)"</span></span><br><span class="line">          &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_preparation */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"join_optimization"</span>: &#123;</span><br><span class="line">        <span class="attr">"select#"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"steps"</span>: [</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"condition_processing"</span>: &#123;</span><br><span class="line">              <span class="attr">"condition"</span>: <span class="string">"WHERE"</span>,</span><br><span class="line">              <span class="attr">"original_condition"</span>: <span class="string">"(`tb_item`.`id` &lt; 4)"</span>,</span><br><span class="line">              <span class="attr">"steps"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"transformation"</span>: <span class="string">"equality_propagation"</span>,</span><br><span class="line">                  <span class="attr">"resulting_condition"</span>: <span class="string">"(`tb_item`.`id` &lt; 4)"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"transformation"</span>: <span class="string">"constant_propagation"</span>,</span><br><span class="line">                  <span class="attr">"resulting_condition"</span>: <span class="string">"(`tb_item`.`id` &lt; 4)"</span></span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"transformation"</span>: <span class="string">"trivial_condition_removal"</span>,</span><br><span class="line">                  <span class="attr">"resulting_condition"</span>: <span class="string">"(`tb_item`.`id` &lt; 4)"</span></span><br><span class="line">                &#125;</span><br><span class="line">              ] <span class="comment">/* steps */</span></span><br><span class="line">            &#125; <span class="comment">/* condition_processing */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"table_dependencies"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"table"</span>: <span class="string">"`tb_item`"</span>,</span><br><span class="line">                <span class="attr">"row_may_be_null"</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">"map_bit"</span>: <span class="number">0</span>,</span><br><span class="line">                <span class="attr">"depends_on_map_bits"</span>: [</span><br><span class="line">                ] <span class="comment">/* depends_on_map_bits */</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* table_dependencies */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"ref_optimizer_key_uses"</span>: [</span><br><span class="line">            ] <span class="comment">/* ref_optimizer_key_uses */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"rows_estimation"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"table"</span>: <span class="string">"`tb_item`"</span>,</span><br><span class="line">                <span class="attr">"range_analysis"</span>: &#123;</span><br><span class="line">                  <span class="attr">"table_scan"</span>: &#123;</span><br><span class="line">                    <span class="attr">"rows"</span>: <span class="number">9816098</span>,</span><br><span class="line">                    <span class="attr">"cost"</span>: <span class="number">2.04e6</span></span><br><span class="line">                  &#125; <span class="comment">/* table_scan */</span>,</span><br><span class="line">                  <span class="attr">"potential_range_indices"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">"index"</span>: <span class="string">"PRIMARY"</span>,</span><br><span class="line">                      <span class="attr">"usable"</span>: <span class="literal">true</span>,</span><br><span class="line">                      <span class="attr">"key_parts"</span>: [</span><br><span class="line">                        <span class="string">"id"</span></span><br><span class="line">                      ] <span class="comment">/* key_parts */</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* potential_range_indices */</span>,</span><br><span class="line">                  <span class="attr">"setup_range_conditions"</span>: [</span><br><span class="line">                  ] <span class="comment">/* setup_range_conditions */</span>,</span><br><span class="line">                  <span class="attr">"group_index_range"</span>: &#123;</span><br><span class="line">                    <span class="attr">"chosen"</span>: <span class="literal">false</span>,</span><br><span class="line">                    <span class="attr">"cause"</span>: <span class="string">"not_group_by_or_distinct"</span></span><br><span class="line">                  &#125; <span class="comment">/* group_index_range */</span>,</span><br><span class="line">                  <span class="attr">"analyzing_range_alternatives"</span>: &#123;</span><br><span class="line">                    <span class="attr">"range_scan_alternatives"</span>: [</span><br><span class="line">                      &#123;</span><br><span class="line">                        <span class="attr">"index"</span>: <span class="string">"PRIMARY"</span>,</span><br><span class="line">                        <span class="attr">"ranges"</span>: [</span><br><span class="line">                          <span class="string">"id &lt; 4"</span></span><br><span class="line">                        ] <span class="comment">/* ranges */</span>,</span><br><span class="line">                        <span class="attr">"index_dives_for_eq_ranges"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">"rowid_ordered"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">"using_mrr"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">"index_only"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">"rows"</span>: <span class="number">3</span>,</span><br><span class="line">                        <span class="attr">"cost"</span>: <span class="number">1.6154</span>,</span><br><span class="line">                        <span class="attr">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                      &#125;</span><br><span class="line">                    ] <span class="comment">/* range_scan_alternatives */</span>,</span><br><span class="line">                    <span class="attr">"analyzing_roworder_intersect"</span>: &#123;</span><br><span class="line">                      <span class="attr">"usable"</span>: <span class="literal">false</span>,</span><br><span class="line">                      <span class="attr">"cause"</span>: <span class="string">"too_few_roworder_scans"</span></span><br><span class="line">                    &#125; <span class="comment">/* analyzing_roworder_intersect */</span></span><br><span class="line">                  &#125; <span class="comment">/* analyzing_range_alternatives */</span>,</span><br><span class="line">                  <span class="attr">"chosen_range_access_summary"</span>: &#123;</span><br><span class="line">                    <span class="attr">"range_access_plan"</span>: &#123;</span><br><span class="line">                      <span class="attr">"type"</span>: <span class="string">"range_scan"</span>,</span><br><span class="line">                      <span class="attr">"index"</span>: <span class="string">"PRIMARY"</span>,</span><br><span class="line">                      <span class="attr">"rows"</span>: <span class="number">3</span>,</span><br><span class="line">                      <span class="attr">"ranges"</span>: [</span><br><span class="line">                        <span class="string">"id &lt; 4"</span></span><br><span class="line">                      ] <span class="comment">/* ranges */</span></span><br><span class="line">                    &#125; <span class="comment">/* range_access_plan */</span>,</span><br><span class="line">                    <span class="attr">"rows_for_plan"</span>: <span class="number">3</span>,</span><br><span class="line">                    <span class="attr">"cost_for_plan"</span>: <span class="number">1.6154</span>,</span><br><span class="line">                    <span class="attr">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                  &#125; <span class="comment">/* chosen_range_access_summary */</span></span><br><span class="line">                &#125; <span class="comment">/* range_analysis */</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* rows_estimation */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"considered_execution_plans"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"plan_prefix"</span>: [</span><br><span class="line">                ] <span class="comment">/* plan_prefix */</span>,</span><br><span class="line">                <span class="attr">"table"</span>: <span class="string">"`tb_item`"</span>,</span><br><span class="line">                <span class="attr">"best_access_path"</span>: &#123;</span><br><span class="line">                  <span class="attr">"considered_access_paths"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                      <span class="attr">"access_type"</span>: <span class="string">"range"</span>,</span><br><span class="line">                      <span class="attr">"rows"</span>: <span class="number">3</span>,</span><br><span class="line">                      <span class="attr">"cost"</span>: <span class="number">2.2154</span>,</span><br><span class="line">                      <span class="attr">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">                    &#125;</span><br><span class="line">                  ] <span class="comment">/* considered_access_paths */</span></span><br><span class="line">                &#125; <span class="comment">/* best_access_path */</span>,</span><br><span class="line">                <span class="attr">"cost_for_plan"</span>: <span class="number">2.2154</span>,</span><br><span class="line">                <span class="attr">"rows_for_plan"</span>: <span class="number">3</span>,</span><br><span class="line">                <span class="attr">"chosen"</span>: <span class="literal">true</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* considered_execution_plans */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"attaching_conditions_to_tables"</span>: &#123;</span><br><span class="line">              <span class="attr">"original_condition"</span>: <span class="string">"(`tb_item`.`id` &lt; 4)"</span>,</span><br><span class="line">              <span class="attr">"attached_conditions_computation"</span>: [</span><br><span class="line">              ] <span class="comment">/* attached_conditions_computation */</span>,</span><br><span class="line">              <span class="attr">"attached_conditions_summary"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="attr">"table"</span>: <span class="string">"`tb_item`"</span>,</span><br><span class="line">                  <span class="attr">"attached"</span>: <span class="string">"(`tb_item`.`id` &lt; 4)"</span></span><br><span class="line">                &#125;</span><br><span class="line">              ] <span class="comment">/* attached_conditions_summary */</span></span><br><span class="line">            &#125; <span class="comment">/* attaching_conditions_to_tables */</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="attr">"refine_plan"</span>: [</span><br><span class="line">              &#123;</span><br><span class="line">                <span class="attr">"table"</span>: <span class="string">"`tb_item`"</span>,</span><br><span class="line">                <span class="attr">"access_type"</span>: <span class="string">"range"</span></span><br><span class="line">              &#125;</span><br><span class="line">            ] <span class="comment">/* refine_plan */</span></span><br><span class="line">          &#125;</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_optimization */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"join_execution"</span>: &#123;</span><br><span class="line">        <span class="attr">"select#"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"steps"</span>: [</span><br><span class="line">        ] <span class="comment">/* steps */</span></span><br><span class="line">      &#125; <span class="comment">/* join_execution */</span></span><br><span class="line">    &#125;</span><br><span class="line">  ] /* steps */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-索引的使用"><a href="#4-索引的使用" class="headerlink" title="4. 索引的使用"></a>4. 索引的使用</h1><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p>
<h2 id="4-1-验证索引提升查询效率"><a href="#4-1-验证索引提升查询效率" class="headerlink" title="4.1 验证索引提升查询效率"></a>4.1 验证索引提升查询效率</h2><p>在我们准备的表结构tb_item 中， 一共存储了 300 万记录；</p>
<ol>
<li>根据ID查询 </li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1999</span>\G;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-29.png" alt="2-29"></p>
<p>查询速度很快， 接近0s ， 主要的原因是因为id为主键， 有索引；</p>
<p><img src="../images/mysql/2/2-30.png" alt="2-30"></p>
<ol start="2">
<li>根据 title 进行精确查询</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> title = <span class="string">'iphoneX 移动3G 32G941'</span>\G;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-31.png" alt="2-31"></p>
<p>查看SQL语句的执行计划 ： </p>
<p><img src="../images/mysql/2/2-32.png" alt="2-32"></p>
<p><strong>处理方案</strong> ， 针对title字段， 创建索引 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_item_title <span class="keyword">on</span> tb_item(title);</span><br></pre></td></tr></table></figure>

<p>索引创建完成之后，再次进行查询 ： </p>
<p><img src="../images/mysql/2/2-33.png" alt="2-33"></p>
<p>通过explain ， 查看执行计划，执行SQL时使用了刚才创建的索引 </p>
<p><img src="../images/mysql/2/2-34.png" alt="2-34"></p>
<h2 id="4-2-索引的使用"><a href="#4-2-索引的使用" class="headerlink" title="4.2 索引的使用"></a>4.2 索引的使用</h2><h3 id="4-2-1-准备环境"><a href="#4-2-1-准备环境" class="headerlink" title="4.2.1 准备环境"></a>4.2.1 准备环境</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`tb_seller`</span> (</span><br><span class="line">	<span class="string">`sellerid`</span> <span class="built_in">varchar</span> (<span class="number">100</span>),</span><br><span class="line">	<span class="string">`name`</span> <span class="built_in">varchar</span> (<span class="number">100</span>),</span><br><span class="line">	<span class="string">`nickname`</span> <span class="built_in">varchar</span> (<span class="number">50</span>),</span><br><span class="line">	<span class="string">`password`</span> <span class="built_in">varchar</span> (<span class="number">60</span>),</span><br><span class="line">	<span class="string">`status`</span> <span class="built_in">varchar</span> (<span class="number">1</span>),</span><br><span class="line">	<span class="string">`address`</span> <span class="built_in">varchar</span> (<span class="number">100</span>),</span><br><span class="line">	<span class="string">`createtime`</span> datetime,</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">`sellerid`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8mb4; </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'alibaba'</span>,<span class="string">'阿里巴巴'</span>,<span class="string">'阿里小店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'baidu'</span>,<span class="string">'百度科技有限公司'</span>,<span class="string">'百度小店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'huawei'</span>,<span class="string">'华为科技有限公司'</span>,<span class="string">'华为小店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'0'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'itcast'</span>,<span class="string">'传智播客教育科技有限公司'</span>,<span class="string">'传智播客'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'itheima'</span>,<span class="string">'黑马程序员'</span>,<span class="string">'黑马程序员'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'0'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'luoji'</span>,<span class="string">'罗技科技有限公司'</span>,<span class="string">'罗技小店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'oppo'</span>,<span class="string">'OPPO科技有限公司'</span>,<span class="string">'OPPO官方旗舰店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'0'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'ourpalm'</span>,<span class="string">'掌趣科技股份有限公司'</span>,<span class="string">'掌趣小店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'qiandu'</span>,<span class="string">'千度科技'</span>,<span class="string">'千度小店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'2'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'sina'</span>,<span class="string">'新浪科技有限公司'</span>,<span class="string">'新浪官方旗舰店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'xiaomi'</span>,<span class="string">'小米科技'</span>,<span class="string">'小米官方旗舰店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'西安市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`tb_seller`</span> (<span class="string">`sellerid`</span>, <span class="string">`name`</span>, <span class="string">`nickname`</span>, <span class="string">`password`</span>, <span class="string">`status`</span>, <span class="string">`address`</span>, <span class="string">`createtime`</span>) <span class="keyword">values</span>(<span class="string">'yijia'</span>,<span class="string">'宜家家居'</span>,<span class="string">'宜家家居旗舰店'</span>,<span class="string">'e10adc3949ba59abbe56e057f20f883e'</span>,<span class="string">'1'</span>,<span class="string">'北京市'</span>,<span class="string">'2088-01-01 12:00:00'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-避免索引失效"><a href="#4-2-2-避免索引失效" class="headerlink" title="4.2.2 避免索引失效"></a>4.2.2 避免索引失效</h3><ol>
<li>全值匹配 ，对索引中所有列都指定具体值。</li>
</ol>
<p>改情况下，索引生效，执行效率高。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-35.png" alt="2-35"></p>
<ol start="2">
<li>最左前缀法则</li>
</ol>
<ul>
<li>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</li>
<li>跟顺序没有关系，有就执行索引（爬楼梯一样，走一层，再走下一层，不能跳级）</li>
<li>匹配最左前缀法则，走索引：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-36.png" alt="2-36"></p>
<p>违法最左前缀法则 ， 索引失效：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'1'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">status</span>=<span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-37.png" alt="2-37"></p>
<p>如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-38.png" alt="2-38"></p>
<ol start="3">
<li>范围查询右边的列，不能使用索引 。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> &gt; <span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'北京市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-39.png" alt="2-39"></p>
<p>前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</p>
<ol start="4">
<li>不要在索引列上进行运算操作， 索引将失效。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">3</span>,<span class="number">2</span>)=<span class="string">'科技'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">substring</span>(<span class="keyword">name</span>,<span class="number">3</span>,<span class="number">2</span>)=<span class="string">'科技'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-40.png" alt="2-40"></p>
<ol start="5">
<li>字符串不加单引号，造成索引失效。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="string">'1'</span> ;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="number">1</span> ;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-41.png" alt="2-41"></p>
<p>在查询时，没有对字符串加单引号，MySQL的查询优化器，会自动的进行类型转换，造成索引失效。</p>
<ol start="6">
<li>尽量使用覆盖索引，避免select *</li>
</ol>
<p>尽量使用覆盖索引（只访问索引的查询（索引列完全包含查询列）），减少select * 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">status</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">status</span>,address <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-42.png" alt="2-42"></p>
<p>如果查询列，超出索引列，也会降低性能。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">name</span>,<span class="keyword">status</span>,address,<span class="keyword">password</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span> = <span class="string">'1'</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-43.png" alt="2-43"></p>
<p><strong>TIP :</strong> </p>
<ul>
<li>using index ：使用覆盖索引的时候就会出现</li>
<li>using where：在查找使用索引的情况下，需要回表去查询所需的数据</li>
<li>using index condition：查找使用了索引，但是需要回表查询数据</li>
<li>using index ; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</li>
</ul>
<ol start="7">
<li>用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</li>
</ol>
<p>示例，name字段是索引列 ， 而createtime不是索引列，中间是or进行连接是不走索引的 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'黑马程序员'</span> <span class="keyword">and</span> createtime = <span class="string">'2088-01-01 12:00:00'</span>;	</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'黑马程序员'</span> <span class="keyword">or</span> createtime = <span class="string">'2088-01-01 12:00:00'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-44.png" alt="2-44"></p>
<ol start="8">
<li>以%开头的Like模糊查询，索引失效。</li>
</ol>
<p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'黑马程序员%'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%黑马程序员'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%黑马程序员%'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-45.png" alt="2-45"></p>
<p><strong>解决方案 ：</strong> </p>
<p>通过覆盖索引来解决 （索引的字段，id为自动创建的索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'科技%'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> sellerid,<span class="keyword">name</span>,<span class="keyword">status</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">like</span> <span class="string">'%科技%'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-46.png" alt="2-46"></p>
<ol start="9">
<li>如果MySQL评估使用索引比全表更慢，则不使用索引。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_seller;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_address <span class="keyword">on</span> tb_seller(address);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'北京市'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address=<span class="string">'西安市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-47.png" alt="2-47"></p>
<ol start="10">
<li>is  NULL ， is NOT NULL  <font color="red">有时</font>索引失效。</li>
</ol>
<p>看数据量，第9点，如果全表快，就走全表，不走索引（多数为null，全表快，不走索引）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">is</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-48.png" alt="2-48"></p>
<ol start="11">
<li>in 走索引， not in 索引失效。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> sellerid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">'oppo'</span>,<span class="string">'xiaomi'</span>,<span class="string">'sina'</span>);</span><br></pre></td></tr></table></figure>

<p>学习版：出现</p>
<p><img src="../images/mysql/2/2-49.png" alt="2-49"> </p>
<p>测试版：没有出现</p>
<p><img src="../images/mysql/2/2-50.png" alt="2-50"></p>
<ol start="12">
<li>单列索引和复合索引。</li>
</ol>
<p>尽量使用复合索引，而少使用单列索引 。</p>
<p>创建复合索引 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_name_sta_address <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>, <span class="keyword">status</span>, address);</span><br><span class="line">就相当于创建了三个索引 ： </span><br><span class="line">	name</span><br><span class="line">	name + status</span><br><span class="line">	name + status + address</span><br></pre></td></tr></table></figure>

<p>创建单列索引 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create index idx_seller_name on tb_seller(name);</span><br><span class="line">create index idx_seller_status on tb_seller(status);</span><br><span class="line">create index idx_seller_address on tb_seller(address);</span><br></pre></td></tr></table></figure>

<p>数据库会选择一个最优的索引（辨识度最高索引）来使用，并不会使用全部索引 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span> <span class="keyword">and</span> <span class="keyword">status</span>=<span class="string">' '</span> <span class="keyword">and</span> address=<span class="string">'西安市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-51.png" alt="2-51"></p>
<h2 id="4-3-查看索引使用情况"><a href="#4-3-查看索引使用情况" class="headerlink" title="4.3 查看索引使用情况"></a>4.3 查看索引使用情况</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;	</span><br><span class="line">全局</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Handler_read%'</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="../images/mysql/2/2-52.png" alt="2-52"></p>
<ul>
<li>Handler_read_first：索引中第一条被读的次数。如果较高，表示服务器正执行大量全索引扫描（这个值越低越好）。</li>
<li>Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。</li>
<li>Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。</li>
<li>Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC。</li>
<li>Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。</li>
<li>Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。</li>
</ul>
<h1 id="5-SQL优化"><a href="#5-SQL优化" class="headerlink" title="5. SQL优化"></a>5. SQL优化</h1><h2 id="5-1-大批量插入数据"><a href="#5-1-大批量插入数据" class="headerlink" title="5.1 大批量插入数据"></a>5.1 大批量插入数据</h2><p>环境准备 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`tb_user_1`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">96</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`birthday`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`sex`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`email`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`phone`</span> <span class="built_in">varchar</span>(<span class="number">45</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`qq`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'用户状态'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`unique_user_username`</span> (<span class="string">`username`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 ;</span><br></pre></td></tr></table></figure>

<p>当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。</p>
<p><img src="../images/mysql/2/2-53.png" alt="2-53"></p>
<p>对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p>
<ol>
<li>主键顺序插入<ol>
<li>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。</li>
<li>如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</li>
</ol>
</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">脚本文件介绍 :</span><br><span class="line">	sql1.log  <span class="comment">----&gt; 主键有序</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'C:\\sql1.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user_1 <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_1;</span><br><span class="line">	sql2.log  <span class="comment">----&gt; 主键无序</span></span><br><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span> <span class="string">'C:\\sql2.log'</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user_2 <span class="keyword">fields</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">','</span> <span class="keyword">lines</span> <span class="keyword">terminated</span> <span class="keyword">by</span> <span class="string">'\n'</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> tb_user_2;</span><br><span class="line"></span><br><span class="line">过程</span><br><span class="line">mysql <span class="comment">--local-infile=1 -u root -p</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'local_infile'</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile = <span class="string">'ON'</span>;</span><br></pre></td></tr></table></figure>

<p>插入ID顺序排列数据：</p>
<p><img src="../images/mysql/2/2-56.png" alt="2-56"></p>
<p>插入ID无序排列数据：（学习版，测试时系统崩了）</p>
<p><img src="../images/mysql/2/2-59.png" alt="2-59"></p>
<ol start="2">
<li>关闭唯一性校验</li>
</ol>
<p>在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p>
<p><img src="../images/mysql/2/2-60.png" alt="2-60"></p>
<ol start="3">
<li>手动提交事务</li>
</ol>
<p>如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。</p>
<p><img src="../images/mysql/2/2-61.png" alt="2-61"></p>
<h2 id="5-2-优化insert语句"><a href="#5-2-优化insert语句" class="headerlink" title="5.2 优化insert语句"></a>5.2 优化insert语句</h2><p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案。</p>
<ul>
<li><p>如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</p>
<p>示例， 原始方式为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure>

<p>优化后的方案为 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>),(<span class="number">2</span>,<span class="string">'Cat'</span>)，(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在事务中进行数据插入。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">start</span> <span class="keyword">transaction</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>数据有序插入</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Tim'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Rose'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Cat'</span>);</span><br></pre></td></tr></table></figure>

<p>优化后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'Tom'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'Cat'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Jerry'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'Tim'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">'Rose'</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="5-3-优化order-by语句"><a href="#5-3-优化order-by语句" class="headerlink" title="5.3 优化order by语句"></a>5.3 优化order by语句</h2><h3 id="5-3-1-环境准备"><a href="#5-3-1-环境准备" class="headerlink" title="5.3.1 环境准备"></a>5.3.1 环境准备</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`emp2`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`salary`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>  <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'1'</span>,<span class="string">'Tom'</span>,<span class="string">'25'</span>,<span class="string">'2300'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'2'</span>,<span class="string">'Jerry'</span>,<span class="string">'30'</span>,<span class="string">'3500'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'3'</span>,<span class="string">'Luci'</span>,<span class="string">'25'</span>,<span class="string">'2800'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'4'</span>,<span class="string">'Jay'</span>,<span class="string">'36'</span>,<span class="string">'3500'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'5'</span>,<span class="string">'Tom2'</span>,<span class="string">'21'</span>,<span class="string">'2200'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'6'</span>,<span class="string">'Jerry2'</span>,<span class="string">'31'</span>,<span class="string">'3300'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'7'</span>,<span class="string">'Luci2'</span>,<span class="string">'26'</span>,<span class="string">'2700'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'8'</span>,<span class="string">'Jay2'</span>,<span class="string">'33'</span>,<span class="string">'3500'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'9'</span>,<span class="string">'Tom3'</span>,<span class="string">'23'</span>,<span class="string">'2400'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'10'</span>,<span class="string">'Jerry3'</span>,<span class="string">'32'</span>,<span class="string">'3100'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'11'</span>,<span class="string">'Luci3'</span>,<span class="string">'26'</span>,<span class="string">'2900'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`emp2`</span> (<span class="string">`id`</span>, <span class="string">`name`</span>, <span class="string">`age`</span>, <span class="string">`salary`</span>) <span class="keyword">values</span>(<span class="string">'12'</span>,<span class="string">'Jay3'</span>,<span class="string">'37'</span>,<span class="string">'4500'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp2(age,salary);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-2-两种排序方式"><a href="#5-3-2-两种排序方式" class="headerlink" title="5.3.2 两种排序方式"></a>5.3.2 两种排序方式</h3><ol>
<li>第一种是通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="../images/mysql/2/2-54.png" alt="2-54"></p>
<ol start="2">
<li>第二种通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,age <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,age,salary <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-55.png" alt="2-55"></p>
<ol start="3">
<li>多字段排序（排序的名字与索引的顺序保持一致）</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,age,salary <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age,salary;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,age,salary <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>,salary <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,age,salary <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>,age <span class="keyword">desc</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">id</span>,age,salary <span class="keyword">from</span> emp2 <span class="keyword">order</span> <span class="keyword">by</span> age <span class="keyword">desc</span>,salary <span class="keyword">asc</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-57.png" alt="2-57"></p>
<p>了解了MySQL的排序方式，优化目标就清晰了：</p>
<ul>
<li>尽量减少额外的排序，通过索引直接返回有序数据。</li>
<li>where 条件和Order by 使用相同的索引，并且Order By 的顺序和索引顺序相同， 并且Order  by 的字段都是升序，或者都是降序。</li>
<li>否则肯定需要额外的操作，这样就会出现FileSort。</li>
</ul>
<h3 id="5-3-3-Filesort-的优化"><a href="#5-3-3-Filesort-的优化" class="headerlink" title="5.3.3 Filesort 的优化"></a>5.3.3 Filesort 的优化</h3><p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p>
<ul>
<li>两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</li>
<li>一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort  buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</li>
</ul>
<p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。</p>
<p>可以适当提高 sort_buffer_size  和 max_length_for_sort_data  系统变量，来增大排序区的大小，提高排序的效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sort_buffer_size'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'max_length_for_sort_data'</span>;</span><br></pre></td></tr></table></figure>

<p> <img src="../images/mysql/2/2-58.png" alt="2-58"></p>
<h2 id="5-4-优化group-by-语句（学习版，测试版没有做到）"><a href="#5-4-优化group-by-语句（学习版，测试版没有做到）" class="headerlink" title="5.4 优化group by 语句（学习版，测试版没有做到）"></a>5.4 优化group by 语句（学习版，测试版没有做到）</h2><p>​    由于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p>
<p>​    如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp2(age,salary);</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp2;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp2 <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-62.png" alt="2-62"></p>
<p>优化后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> age,<span class="keyword">count</span>(*) <span class="keyword">from</span> emp2 <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-63.png" alt="2-63"></p>
<p>从上面的例子可以看出，第一个SQL语句需要进行”filesort”，而第二个SQL由于order  by  null 不需要进行 “filesort”， 而上文提过Filesort往往非常耗费时间。</p>
<p>创建索引 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_emp_age_salary <span class="keyword">on</span> emp2(age,salary);</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-64.png" alt="2-64"></p>
<h2 id="5-5-优化嵌套查询"><a href="#5-5-优化嵌套查询" class="headerlink" title="5.5 优化嵌套查询"></a>5.5 优化嵌套查询</h2><p>Mysql4.1版本之后，开始支持SQL的子查询。这个技术可以使用SELECT语句来创建一个单列的查询结果，然后把这个结果作为过滤条件用在另一个查询中。使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p>
<p>示例 ，查找有角色的所有的用户信息 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span> (<span class="keyword">select</span> user_id <span class="keyword">from</span> user_role );</span><br></pre></td></tr></table></figure>

<p>优化后 :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> t_user u , user_role ur <span class="keyword">where</span> u.id = ur.user_id;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-65.png" alt="2-65"></p>
<p>连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p>
<h2 id="5-6-优化OR条件"><a href="#5-6-优化OR条件" class="headerlink" title="5.6 优化OR条件"></a>5.6 优化OR条件</h2><p>对于包含OR的查询子句，如果要利用索引，则OR之间的每个条件列都必须用到索引 ， 而且不能使用到复合索引； 如果没有索引，则应该考虑增加索引。</p>
<p>获取 emp2 表中的所有的索引 ： show index from emp2;</p>
<p><img src="../images/mysql/2/2-66.png" alt="2-66"></p>
<p>示例 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp2 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">or</span> age = <span class="number">30</span>\G;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp2 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">id</span> =<span class="number">10</span>\G;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-67.png" alt="2-67"></p>
<p><img src="../images/mysql/2/2-68.png" alt="2-68"></p>
<p>建议使用 union 替换 or ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp2 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp2 <span class="keyword">where</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-69.png" alt="2-69"></p>
<p>我们来比较下重要指标，发现主要差别是 type 和 ref 这两项</p>
<p>type 显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null  &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</span><br></pre></td></tr></table></figure>

<ul>
<li>UNION 语句的 type 值为 ref，OR 语句的 type 值为 range，可以看到这是一个很明显的差距</li>
<li>UNION 语句的 ref 值为 const，OR 语句的 type 值为 null，const 表示是常量值引用，非常快</li>
<li>这两项的差距就说明了 UNION 要优于 OR 。</li>
</ul>
<h2 id="5-7-优化分页查询"><a href="#5-7-优化分页查询" class="headerlink" title="5.7 优化分页查询"></a>5.7 优化分页查询</h2><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 2000000,10  ，此时需要MySQL排序前2000010 记录，仅仅返回2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item t,(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> tb_item <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">id</span> <span class="keyword">limit</span> <span class="number">2000000</span>,<span class="number">10</span>) a <span class="keyword">where</span> t.id=a.id;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_item <span class="keyword">where</span> <span class="keyword">id</span> &gt; <span class="number">2000000</span> <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-70.png" alt="2-70"></p>
<h3 id="5-7-1-优化思路一"><a href="#5-7-1-优化思路一" class="headerlink" title="5.7.1 优化思路一"></a>5.7.1 优化思路一</h3><p>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</p>
<p><img src="../images/mysql/2/2-71.png" alt="2-71"></p>
<h3 id="5-7-2-优化思路二"><a href="#5-7-2-优化思路二" class="headerlink" title="5.7.2 优化思路二"></a>5.7.2 优化思路二</h3><p>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</p>
<p><img src="../images/mysql/2/2-72.png" alt="2-72"></p>
<h2 id="5-8-使用SQL提示"><a href="#5-8-使用SQL提示" class="headerlink" title="5.8 使用SQL提示"></a>5.8 使用SQL提示</h2><p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<h3 id="5-8-1-USE-INDEX"><a href="#5-8-1-USE-INDEX" class="headerlink" title="5.8.1 USE INDEX"></a>5.8.1 USE INDEX</h3><p>在查询语句中表名的后面，添加 use index 来提供希望MySQL去参考的索引列表，就可以让MySQL不再考虑其他可用的索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_name_stta_addr <span class="keyword">on</span> tb_seller(<span class="keyword">name</span>,<span class="keyword">status</span>,address);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_name) <span class="keyword">where</span> <span class="keyword">name</span>=<span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-73.png" alt="2-73"></p>
<h3 id="5-8-2-IGNORE-INDEX"><a href="#5-8-2-IGNORE-INDEX" class="headerlink" title="5.8.2 IGNORE INDEX"></a>5.8.2 IGNORE INDEX</h3><p>如果用户只是单纯的想让MySQL忽略一个或者多个索引，则可以使用 ignore index 作为 hint 。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">ignore</span> <span class="keyword">index</span>(idx_seller_name) <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'小米科技'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-74.png" alt="2-74"></p>
<h3 id="5-8-3-FORCE-INDEX"><a href="#5-8-3-FORCE-INDEX" class="headerlink" title="5.8.3 FORCE INDEX"></a>5.8.3 FORCE INDEX</h3><p>为强制MySQL使用一个特定的索引，可在查询中使用 force index 作为hint 。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_seller_address <span class="keyword">on</span> tb_seller(address);</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address = <span class="string">'北京市'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">use</span> <span class="keyword">index</span>(idx_seller_address) <span class="keyword">where</span> address = <span class="string">'北京市'</span>;</span><br><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> tb_seller <span class="keyword">force</span> <span class="keyword">index</span>(idx_seller_address) <span class="keyword">where</span> address = <span class="string">'北京市'</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/2/2-75.png" alt="2-75"></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql高级使用1</title>
    <url>/post/51ce57fc.html</url>
    <content><![CDATA[<p>mysql高级使用-索引，视图，存储过程，触发器</p>
<a id="more"></a>

<h1 id="1-Linux-系统安装MySQL"><a href="#1-Linux-系统安装MySQL" class="headerlink" title="1.Linux 系统安装MySQL"></a>1.Linux 系统安装MySQL</h1><h2 id="1-1-准备安装包"><a href="#1-1-准备安装包" class="headerlink" title="1-1.准备安装包"></a>1-1.准备安装包</h2><p> <a href="https://dev.mysql.com/downloads/" target="_blank" rel="noopener">MySQL Community Downloads</a></p>
<p><img src="../images/mysql/1-2.png" alt="1-2"></p>
<h2 id="1-2-安装MySQL"><a href="#1-2-安装MySQL" class="headerlink" title="1-2.安装MySQL"></a>1-2.安装MySQL</h2><p>直接将安装包推动到linux虚拟机</p>
<ul>
<li>卸载 centos 中预安装的 mysql</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rpm -qa | grep -i mysql</span><br><span class="line">rpm -e （版本） --nodeps</span><br></pre></td></tr></table></figure>

<ul>
<li>解压 mysql 的安装包 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> mysql</span><br><span class="line"><span class="comment">//解压到</span></span><br><span class="line">tar -xvf MySQL<span class="number">-5.6</span><span class="number">.22</span><span class="number">-1.</span>el6.i686.rpm-bundle.tar -C /root/mysql</span><br></pre></td></tr></table></figure>

<ul>
<li>安装依赖包 </li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">yum -y install libaio.so<span class="number">.1</span> libgcc_s.so<span class="number">.1</span> libstdc++.so<span class="number">.6</span> libncurses.so<span class="number">.5</span> --setopt=protected_multilib=<span class="literal">false</span></span><br><span class="line">yum  update libstdc++<span class="number">-4.4</span><span class="number">.7</span><span class="number">-4.</span>el6.x86_64</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 mysql-client</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-client<span class="number">-5.6</span><span class="number">.22</span><span class="number">-1.</span>el6.i686.rpm</span><br></pre></td></tr></table></figure>

<ul>
<li>安装 mysql-server</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rpm -ivh MySQL-server<span class="number">-5.6</span><span class="number">.22</span><span class="number">-1.</span>el6.i686.rpm</span><br></pre></td></tr></table></figure>

<h2 id="1-3-启动-MySQL-服务"><a href="#1-3-启动-MySQL-服务" class="headerlink" title="1.3 启动 MySQL 服务"></a>1.3 启动 MySQL 服务</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">开启</span><br><span class="line">service mysql <span class="keyword">start</span></span><br><span class="line">停止</span><br><span class="line">service mysql <span class="keyword">stop</span></span><br><span class="line">查看状态</span><br><span class="line">service mysql <span class="keyword">status</span></span><br><span class="line">重启</span><br><span class="line">service mysql restart</span><br></pre></td></tr></table></figure>

<h2 id="1-4-登录MySQL"><a href="#1-4-登录MySQL" class="headerlink" title="1.4 登录MySQL"></a>1.4 登录MySQL</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql 安装完成之后, 会自动生成一个随机的密码, 并且保存在一个密码文件中 : </span><br><span class="line">打开： cat &#x2F;root&#x2F;.mysql_secret</span><br><span class="line">进入mysql</span><br><span class="line">mysql -u root -p </span><br><span class="line">登录之后, 修改密码 :</span><br><span class="line">set password &#x3D; password(&#39;1234&#39;);</span><br><span class="line">退出：Ctrl+c</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/linux-mysql%E5%AF%86%E7%A0%81.png" alt="linux-mysql密码"></p>
<p><img src="../images/mysql/linux-mysql%E5%AF%86%E7%A0%812.png" alt="linux-mysql密码2"></p>
<h1 id="2-索引"><a href="#2-索引" class="headerlink" title="2.索引"></a>2.索引</h1><h2 id="2-1-索引概述"><a href="#2-1-索引概述" class="headerlink" title="2.1 索引概述"></a>2.1 索引概述</h2><p>​    MySQL官方对索引的定义为：索引（index）是帮助MySQL高效获取数据的数据结构（有序）。在数据之外，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。如下面的==示意图==所示 : </p>
<p><img src="../images/mysql/1-3.png" alt="1-3"></p>
<p>​    左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找快速获取到相应数据。</p>
<p>​    一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上。索引是数据库中用来提高性能的最常用的工具。</p>
<p>例子：</p>
<p><img src="../images/mysql/1-1.png" alt="1-1"></p>
<h2 id="2-2-索引优势劣势"><a href="#2-2-索引优势劣势" class="headerlink" title="2.2 索引优势劣势"></a>2.2 索引优势劣势</h2><ul>
<li><p>优势</p>
<ul>
<li>类似于书籍的目录索引，提高数据检索的效率，降低数据库的IO成本。</li>
<li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</li>
</ul>
</li>
<li><p>劣势</p>
<ul>
<li>实际上索引也是一张表，该表中保存了主键与索引字段，并指向实体类的记录，所以索引列也是要占用空间的。</li>
<li>虽然索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE。因为更新表时，MySQL 不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。</li>
</ul>
</li>
</ul>
<h2 id="2-3-索引结构"><a href="#2-3-索引结构" class="headerlink" title="2.3 索引结构"></a>2.3 索引结构</h2><p>​    索引是在MySQL的存储引擎层中实现的，而不是在服务器层实现的。所以每种存储引擎的索引都不一定完全相同，也不是所有的存储引擎都支持所有的索引类型的。MySQL目前提供了以下4种索引：</p>
<ul>
<li>BTREE 索引 ： 最常见的索引类型，大部分索引都支持 B 树索引。</li>
<li>HASH 索引：只有Memory引擎支持 ， 使用场景简单 。</li>
<li>R-tree 索引（空间索引）：空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。</li>
<li>Full-text （全文索引） ：全文索引也是MyISAM的一个特殊索引类型，主要用于全文索引，InnoDB从Mysql5.6版本开始支持全文索引。</li>
</ul>
<center><b>MyISAM、InnoDB、Memory三种存储引擎对各种索引类型的支持</b></center>

<table>
<thead>
<tr>
<th>索引</th>
<th>InnoDB引擎</th>
<th>MyISAM引擎</th>
<th>Memory引擎</th>
</tr>
</thead>
<tbody><tr>
<td>BTREE索引</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>HASH 索引</td>
<td>不支持</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>R-tree 索引</td>
<td>不支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td>Full-text</td>
<td>5.6版本之后支持</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<p>​    我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉的）结构组织的索引。其中聚集索引、复合索引、前缀索引、唯一索引默认都是使用 B+tree 索引，统称为 索引。</p>
<h3 id="2-3-1-BTREE-结构"><a href="#2-3-1-BTREE-结构" class="headerlink" title="2.3.1 BTREE 结构"></a>2.3.1 BTREE 结构</h3><p>BTree又叫多路平衡搜索树，一颗m叉的BTree特性如下：</p>
<ul>
<li>树中每个节点最多包含m个孩子。</li>
<li>除根节点与叶子节点外，每个节点至少有[ceil(m/2)]个孩子。</li>
<li>若根节点不是叶子节点，则至少有两个孩子。</li>
<li>所有的叶子节点都在同一层。</li>
<li>每个非叶子节点由n个key与n+1个指针组成，其中[ceil(m/2)-1] &lt;= n &lt;= m-1 </li>
</ul>
<p>​    以5叉BTree为例，key的数量：公式推导[ceil(m/2)-1] &lt;= n &lt;= m-1。所以 2 &lt;= n &lt;=4 。当n&gt;4时，中间节点分裂到父节点，两边节点分裂。</p>
<p>插入 C N G A H E K Q M F W L T Z D P R X Y S 数据为例。</p>
<p>演变过程如下：</p>
<p>1). 插入前4个字母 C N G A </p>
<p><img src="../images/mysql/1-4.png" alt="1-4"> </p>
<p>2). 插入H，n&gt;4，中间元素G字母向上分裂到新的节点</p>
<p><img src="../images/mysql/1-5.png" alt="1-5"> </p>
<p>3). 插入E，K，Q不需要分裂</p>
<p><img src="../images/mysql/1-6.png" alt="1-6"> </p>
<p>4). 插入M，中间元素M字母向上分裂到父节点G</p>
<p><img src="../images/mysql/1-7.png" alt="1-7"> </p>
<p>5). 插入F，W，L，T不需要分裂</p>
<p><img src="../images/mysql/1-8.png" alt="1-8"> </p>
<p>6). 插入Z，中间元素T向上分裂到父节点中 </p>
<p><img src="../images/mysql/1-9.png" alt="1-9"> </p>
<p>7). 插入D，中间元素D向上分裂到父节点中。然后插入P，R，X，Y不需要分裂</p>
<p> <img src="../images/mysql/1-10.png" alt="1-10"></p>
<p>8). 最后插入S，NPQR节点n&gt;5，中间节点Q向上分裂，但分裂后父节点DGMT的n&gt;5，中间节点M向上分裂</p>
<p> <img src="../images/mysql/1-11.png" alt="1-11"></p>
<p>到此，该BTREE树就已经构建完成了， BTREE树 和 二叉树 相比， 查询数据的效率更高， 因为对于相同的数据量来说，BTREE的层级结构比二叉树小，因此搜索速度快。</p>
<h3 id="2-3-3-B-TREE-结构"><a href="#2-3-3-B-TREE-结构" class="headerlink" title="2.3.3 B+TREE 结构"></a>2.3.3 B+TREE 结构</h3><p>B+Tree为BTree的变种，B+Tree与BTree的区别为：</p>
<p>1). n叉B+Tree最多含有n个key，而BTree最多含有n-1个key。</p>
<p>2). B+Tree的叶子节点保存所有的key信息，依key大小顺序排列。</p>
<p>3). 所有的非叶子节点都可以看作是key的索引部分。</p>
<p><img src="../images/mysql/1-12.JPG" alt="1-12"></p>
<p>由于B+Tree只有叶子节点保存key信息，查询任何key都要从root走到叶子。所以B+Tree的查询效率更加稳定。</p>
<p><img src="../images/mysql/1-30.png" alt="1-30"></p>
<p><img src="../images/mysql/1-31.png" alt="1-31"></p>
<h3 id="2-3-3-MySQL中的B-Tree"><a href="#2-3-3-MySQL中的B-Tree" class="headerlink" title="2.3.3 MySQL中的B+Tree"></a>2.3.3 MySQL中的B+Tree</h3><p>MySql索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。</p>
<p>MySQL中的 B+Tree 索引结构示意图: <img src="../images/mysql/1-13.png" alt="1-13"></p>
<h2 id="2-4-索引分类"><a href="#2-4-索引分类" class="headerlink" title="2.4 索引分类"></a>2.4 索引分类</h2><ol>
<li>单值索引 ：即一个索引只包含单个列，一个表可以有多个单列索引</li>
<li>唯一索引 ：索引列的值必须唯一，但允许有空值</li>
<li>复合索引 ：即一个索引包含多个列</li>
</ol>
<h2 id="2-5-索引语法"><a href="#2-5-索引语法" class="headerlink" title="2.5 索引语法"></a>2.5 索引语法</h2><p>索引在创建表的时候，可以同时创建， 也可以随时增加新的索引。</p>
<p>准备环境:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">//创建数据库</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> demo_01 <span class="keyword">default</span> <span class="keyword">charset</span>=utf8mb4;</span><br><span class="line">//使用数据库</span><br><span class="line"><span class="keyword">use</span> demo_01;</span><br><span class="line">//创建表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`city`</span> (</span><br><span class="line">  <span class="string">`city_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`city_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`country_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`city_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`country`</span> (</span><br><span class="line">  <span class="string">`country_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="string">`country_name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`country_id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line">//插入数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`city`</span> (<span class="string">`city_id`</span>, <span class="string">`city_name`</span>, <span class="string">`country_id`</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'西安'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`city`</span> (<span class="string">`city_id`</span>, <span class="string">`city_name`</span>, <span class="string">`country_id`</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'NewYork'</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`city`</span> (<span class="string">`city_id`</span>, <span class="string">`city_name`</span>, <span class="string">`country_id`</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'北京'</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`city`</span> (<span class="string">`city_id`</span>, <span class="string">`city_name`</span>, <span class="string">`country_id`</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'上海'</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`country`</span> (<span class="string">`country_id`</span>, <span class="string">`country_name`</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'China'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`country`</span> (<span class="string">`country_id`</span>, <span class="string">`country_name`</span>) <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'America'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`country`</span> (<span class="string">`country_id`</span>, <span class="string">`country_name`</span>) <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">'Japan'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`country`</span> (<span class="string">`country_id`</span>, <span class="string">`country_name`</span>) <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">'UK'</span>);</span><br></pre></td></tr></table></figure>



<h3 id="2-5-1-创建索引"><a href="#2-5-1-创建索引" class="headerlink" title="2.5.1 创建索引"></a>2.5.1 创建索引</h3><p>语法 ：     </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> 	[<span class="keyword">UNIQUE</span>|FULLTEXT|SPATIAL]  <span class="keyword">INDEX</span> index_name </span><br><span class="line">[<span class="keyword">USING</span>  index_type]</span><br><span class="line"><span class="keyword">ON</span> tbl_name(index_col_name,...)</span><br><span class="line"></span><br><span class="line">index_col_name : column_name[(<span class="keyword">length</span>)][<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure>

<p>示例 ：</p>
<p> 为city表中的city_name字段创建索引 ；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city(city_name);</span><br></pre></td></tr></table></figure>



<h3 id="2-5-2-查看索引"><a href="#2-5-2-查看索引" class="headerlink" title="2.5.2 查看索引"></a>2.5.2 查看索引</h3><p>语法： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show index  from  table_name;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>查看city表中的索引信息；</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span>  <span class="keyword">from</span> city;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-14.png" alt="1-14"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span>  <span class="keyword">from</span> city\G;</span><br></pre></td></tr></table></figure>

<p> <img src="../images/mysql/1-15.png" alt="1-15"></p>
<h3 id="2-5-3-删除索引"><a href="#2-5-3-删除索引" class="headerlink" title="2.5.3 删除索引"></a>2.5.3 删除索引</h3><p>语法 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DROP  INDEX  index_name  ON  tbl_name;</span><br></pre></td></tr></table></figure>

<p>示例 ： </p>
<p>想要删除city表上的索引idx_city_name，可以操作如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_city_name <span class="keyword">on</span> city;</span><br></pre></td></tr></table></figure>



<h3 id="2-5-4-ALTER命令"><a href="#2-5-4-ALTER命令" class="headerlink" title="2.5.4 ALTER命令"></a>2.5.4 ALTER命令</h3><ul>
<li>该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL（主键索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  primary  <span class="keyword">key</span>(column_list);</span><br></pre></td></tr></table></figure>

<ul>
<li>这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）（唯一索引）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  <span class="keyword">unique</span> index_name(column_list);</span><br></pre></td></tr></table></figure>

<ul>
<li>添加普通索引， 索引值可以出现多次。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  <span class="keyword">index</span> index_name(column_list);</span><br></pre></td></tr></table></figure>

<ul>
<li>该语句指定了索引为FULLTEXT， 用于全文索引</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span>  <span class="keyword">table</span>  tb_name  <span class="keyword">add</span>  fulltext  index_name(column_list);</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="2-6-索引设计原则"><a href="#2-6-索引设计原则" class="headerlink" title="2.6 索引设计原则"></a>2.6 索引设计原则</h2><p>​    索引的设计可以遵循一些已有的原则，创建索引的时候请尽量考虑符合这些原则，便于提升索引的使用效率，更高效的使用索引。</p>
<ul>
<li><p>对查询频次较高，且数据量比较大的表建立索引。</p>
</li>
<li><p>索引字段的选择，最佳候选列应当从where子句的条件中提取，如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。</p>
</li>
<li><p>使用唯一索引，区分度越高，使用索引的效率越高。</p>
</li>
<li><p>索引可以有效的提升查询数据的效率，但索引数量不是多多益善，索引越多，维护索引的代价自然也就水涨船高。对于插入、更新、删除等DML操作比较频繁的表来说，索引过多，会引入相当高的维护代价，降低DML操作的效率，增加相应操作的时间消耗。另外索引过多的话，MySQL也会犯选择困难病，虽然最终仍然会找到一个可用的索引，但无疑提高了选择的代价。</p>
</li>
<li><p>使用短索引，索引创建之后也是使用硬盘来存储的，因此提升索引访问的I/O效率，也可以提升总体的访问效率。假如构成索引的字段总长度比较短，那么在给定大小的存储块内可以存储更多的索引值，相应的可以有效的提升MySQL访问索引的I/O效率。</p>
</li>
<li><p>利用最左前缀，N个列组合而成的组合索引，那么相当于是创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引来提升查询效率。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">创建复合索引:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_name_email_status <span class="keyword">ON</span> tb_seller(<span class="keyword">NAME</span>,email,<span class="keyword">STATUS</span>);</span><br><span class="line"></span><br><span class="line">就相当于</span><br><span class="line">	对name 创建索引 ;</span><br><span class="line">	对name , email 创建了索引 ;</span><br><span class="line">	对name , email, status 创建了索引 ;</span><br></pre></td></tr></table></figure>

<h1 id="3-视图"><a href="#3-视图" class="headerlink" title="3. 视图"></a>3. 视图</h1><h2 id="3-1-视图概述"><a href="#3-1-视图概述" class="headerlink" title="3.1 视图概述"></a>3.1 视图概述</h2><p>​    视图（View）是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。通俗的讲，视图就是一条SELECT语句执行后返回的结果集。所以我们在创建视图的时候，主要的工作就落在创建这条SQL查询语句上。</p>
<p>视图相对于普通的表的优势主要包括以下几项。</p>
<ul>
<li>简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件和筛选条件，对用户来说已经是过滤好的复合条件的结果集。</li>
<li>安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。</li>
<li>数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，源表增加列对视图没有影响；源表修改列名，则可以通过修改视图来解决，不会造成对访问者的影响。</li>
</ul>
<h2 id="3-2-创建或者修改视图"><a href="#3-2-创建或者修改视图" class="headerlink" title="3.2 创建或者修改视图"></a>3.2 创建或者修改视图</h2><p>创建视图的语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure>

<p>修改视图的语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> [ALGORITHM = &#123;UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">选项 : </span><br><span class="line">	WITH [CASCADED | LOCAL] CHECK OPTION 决定了是否允许更新数据使记录不再满足视图的条件。</span><br><span class="line">	LOCAL ： 只要满足本视图的条件就可以更新。</span><br><span class="line">	CASCADED ： 必须满足所有针对该视图的所有视图的条件才可以更新。 默认值.</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p>创建city_country_view视图 , 执行如下SQL : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> city_country_view </span><br><span class="line"><span class="keyword">as</span> </span><br><span class="line"><span class="keyword">select</span> t.*,c.country_name <span class="keyword">from</span> country c , city t <span class="keyword">where</span> c.country_id = t.country_id;</span><br></pre></td></tr></table></figure>

<p>查询视图 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> city_country_view;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-16.png" alt="1-16"></p>
<p>修改视图：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> city_country_view <span class="keyword">set</span> city_name=<span class="string">'西安市'</span> <span class="keyword">where</span> city_id=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>更新视图，也会相应更新表的数据</p>
<p><img src="../images/mysql/1-17.png" alt="1-17"></p>
<h2 id="3-3-查看视图"><a href="#3-3-查看视图" class="headerlink" title="3.3 查看视图"></a>3.3 查看视图</h2><p>​    从 MySQL 5.1 版本开始，使用 SHOW TABLES 命令的时候不仅显示表的名字，同时也会显示视图的名字，而不存在单独显示视图的 SHOW VIEWS 命令。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-18.png" alt="1-18"></p>
<p>同样，在使用 SHOW TABLE STATUS 命令的时候，不但可以显示表的信息，同时也可以显示视图的信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'city_country_view'</span>\G;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-19.png" alt="1-19"></p>
<p>如果需要查询某个视图的定义，可以使用 SHOW CREATE VIEW 命令进行查看 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> city_country_view \G;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-20.png" alt="1-20"></p>
<h2 id="3-4-删除视图"><a href="#3-4-删除视图" class="headerlink" title="3.4 删除视图"></a>3.4 删除视图</h2><p>语法 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] view_name [, view_name] ...[RESTRICT | <span class="keyword">CASCADE</span>]</span><br></pre></td></tr></table></figure>

<p>示例 </p>
<p>删除视图city_country_view :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> city_country_view ;</span><br><span class="line">//没有这个视图也不会出错，if exists</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> <span class="keyword">if</span> <span class="keyword">exists</span> city_country_view ;</span><br></pre></td></tr></table></figure>

<h1 id="4-存储过程和函数"><a href="#4-存储过程和函数" class="headerlink" title="4. 存储过程和函数"></a>4. 存储过程和函数</h1><h2 id="4-1-存储过程和函数概述"><a href="#4-1-存储过程和函数概述" class="headerlink" title="4.1 存储过程和函数概述"></a>4.1 存储过程和函数概述</h2><p>​    存储过程和函数是  事先经过编译并存储在数据库中的一段 SQL 语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。    </p>
<p>​    存储过程和函数的区别在于函数必须有返回值，而存储过程没有。</p>
<p>​    函数 ： 是一个有返回值的过程 ；</p>
<p>​    过程 ： 是一个没有返回值的函数 ；</p>
<h2 id="4-2-创建存储过程"><a href="#4-2-创建存储过程" class="headerlink" title="4.2 创建存储过程"></a>4.2 创建存储过程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> procedure_name ([proc_parameter[,...]])</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="comment">-- SQL语句</span></span><br><span class="line"><span class="keyword">end</span> ;</span><br></pre></td></tr></table></figure>

<p>示例 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test1()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	<span class="keyword">select</span> <span class="string">'Hello Mysql'</span> ;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>



<p><strong><font color="red">知识小贴士</font></strong></p>
<p><strong>DELIMITER</strong></p>
<p>​    该关键字用来声明SQL语句的分隔符 , 告诉 MySQL 解释器，该段命令是否已经结束了，mysql是否可以执行了。默认情况下，delimiter是分号;。在命令行客户端中，如果有一行命令以分号结束，那么回车后，mysql将会执行该命令。</p>
<h2 id="4-3-调用存储过程"><a href="#4-3-调用存储过程" class="headerlink" title="4.3 调用存储过程"></a>4.3 调用存储过程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> procedure_name() ;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">call</span> pro_test1();</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-21.png" alt="1-21"></p>
<h2 id="4-4-查看存储过程"><a href="#4-4-查看存储过程" class="headerlink" title="4.4 查看存储过程"></a>4.4 查看存储过程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询demo_01数据库中的所有的存储过程</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">name</span> <span class="keyword">from</span> mysql.proc <span class="keyword">where</span> db=<span class="string">'demo_01'</span>;</span><br><span class="line"><span class="comment">-- 查询存储过程的状态信息</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">procedure</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment">-- 查询某个存储过程的定义</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">procedure</span> pro_test1 \G;</span><br></pre></td></tr></table></figure>



<h2 id="4-5-删除存储过程"><a href="#4-5-删除存储过程" class="headerlink" title="4.5 删除存储过程"></a>4.5 删除存储过程</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">PROCEDURE</span>  [<span class="keyword">IF</span> <span class="keyword">EXISTS</span>] sp_name ；</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> pro_test1;</span><br></pre></td></tr></table></figure>



<h2 id="4-6-语法"><a href="#4-6-语法" class="headerlink" title="4.6 语法"></a>4.6 语法</h2><p>存储过程是可以编程的，意味着可以使用变量，表达式，控制结构 ， 来完成比较复杂的功能。</p>
<h3 id="4-6-1-变量"><a href="#4-6-1-变量" class="headerlink" title="4.6.1 变量"></a>4.6.1 变量</h3><ul>
<li><p>DECLARE</p>
<p>通过 DECLARE 可以定义一个局部变量，该变量的作用范围只能在 BEGIN…END 块中。</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> var_name[,...] <span class="keyword">type</span> [<span class="keyword">DEFAULT</span> <span class="keyword">value</span>]</span><br></pre></td></tr></table></figure>

<p>示例 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test2() </span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">	<span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">5</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">num</span>+ <span class="number">10</span>; </span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ; </span><br><span class="line">查看</span><br><span class="line"><span class="keyword">call</span> pro_test2();</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-22.png" alt="1-22"></p>
<ul>
<li>SET</li>
</ul>
<p>直接赋值使用 SET，可以赋常量或者赋表达式，具体语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SET var_name &#x3D; expr [, var_name &#x3D; expr] ...</span><br></pre></td></tr></table></figure>

<p>示例 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span>  <span class="keyword">procedure</span> pro_test3()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">DECLARE</span> <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>);</span><br><span class="line">  <span class="keyword">SET</span> <span class="keyword">NAME</span> = <span class="string">'MYSQL'</span>;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">NAME</span>;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> pro_test3();</span><br></pre></td></tr></table></figure>

<p>也可以通过select … into 方式进行赋值操作 :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> pro_test4()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">declare</span>  countnum <span class="built_in">int</span>;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> countnum <span class="keyword">from</span> city;</span><br><span class="line">	<span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'city表中的记录数为：'</span>,countnum);</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"><span class="keyword">call</span> pro_test4();</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-23.png" alt="1-23"></p>
<h3 id="4-6-2-if条件判断"><a href="#4-6-2-if条件判断" class="headerlink" title="4.6.2 if条件判断"></a>4.6.2 if条件判断</h3><p>语法结构 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">if search_condition then statement_list</span><br><span class="line">	[elseif search_condition then statement_list] ...</span><br><span class="line">	[else statement_list]</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br></pre></td></tr></table></figure>

<p>需求： </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型 </span><br><span class="line">	180 及以上 ----------&gt; 身材高挑</span><br><span class="line">	170 - 180  ---------&gt; 标准身材</span><br><span class="line">	170 以下  ----------&gt; 一般身材</span><br></pre></td></tr></table></figure>

<p>示例 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test5()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span>  height  <span class="built_in">int</span>  <span class="keyword">default</span>  <span class="number">175</span>; </span><br><span class="line">  <span class="keyword">declare</span>  description  <span class="built_in">varchar</span>(<span class="number">50</span>);</span><br><span class="line">  if  height &gt;= 180  then</span><br><span class="line">    <span class="keyword">set</span> description = <span class="string">'身材高挑'</span>;</span><br><span class="line">  elseif height &gt;= 170 and height &lt; 180  then</span><br><span class="line">    <span class="keyword">set</span> description = <span class="string">'标准身材'</span>;</span><br><span class="line">  else</span><br><span class="line">    <span class="keyword">set</span> description = <span class="string">'一般身材'</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'身高：'</span>,height,<span class="string">'   对应的身材类型为：'</span>,description);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> pro_test5();</span><br></pre></td></tr></table></figure>

<p>调用结果为 : </p>
<p> <img src="../images/mysql/1-24.png" alt="1-24"></p>
<h3 id="4-6-3-传递参数"><a href="#4-6-3-传递参数" class="headerlink" title="4.6.3 传递参数"></a>4.6.3 传递参数</h3><p>语法格式 : </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure procedure_name([in&#x2F;out&#x2F;inout] 参数名   参数类型)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">IN :   该参数可以作为输入，也就是需要调用方传入值 , 默认</span><br><span class="line">OUT:   该参数作为输出，也就是该参数可以作为返回值</span><br><span class="line">INOUT: 既可以作为输入参数，也可以作为输出参数</span><br></pre></td></tr></table></figure>

<p><strong>IN - 输入</strong></p>
<p>需求 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据定义的身高变量，判定当前身高的所属的身材类型</span><br></pre></td></tr></table></figure>

<p>示例  : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test6(<span class="keyword">in</span> height <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">declare</span> description <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">default</span> <span class="string">''</span>;</span><br><span class="line">  if height &gt;= 180 then</span><br><span class="line">    <span class="keyword">set</span> description=<span class="string">'身材高挑'</span>;</span><br><span class="line">  elseif height &gt;= 170 and height &lt; 180 then</span><br><span class="line">    <span class="keyword">set</span> description=<span class="string">'标准身材'</span>;</span><br><span class="line">  else</span><br><span class="line">    <span class="keyword">set</span> description=<span class="string">'一般身材'</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'身高 '</span>, height , <span class="string">'对应的身材类型为:'</span>,description);</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> pro_test6(<span class="number">168</span>);</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-25.png" alt="1-25"></p>
<p><strong>OUT-输出</strong></p>
<p> 需求 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">根据传入的身高变量，获取当前身高的所属的身材类型</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test7(<span class="keyword">in</span> height <span class="built_in">int</span> , <span class="keyword">out</span> description <span class="built_in">varchar</span>(<span class="number">100</span>))</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">if</span> height &gt;= <span class="number">180</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">set</span> description=<span class="string">'身材高挑'</span>;</span><br><span class="line">  elseif height &gt;= 170 and height &lt; 180 then</span><br><span class="line">    <span class="keyword">set</span> description=<span class="string">'标准身材'</span>;</span><br><span class="line">  else</span><br><span class="line">    <span class="keyword">set</span> description=<span class="string">'一般身材'</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">end</span>$	</span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<p>调用:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">call pro_test7(168, @description);</span><br><span class="line"></span><br><span class="line">select @description;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-26.png" alt="1-26"></p>
<p><font color="red"><strong>小知识</strong> </font></p>
<p>@description :  这种变量要在变量名称前面加上“@”符号，叫做用户会话变量，代表整个会话过程他都是有作用的，这个类似于全局变量一样。</p>
<p>@@global.sort_buffer_size : 这种在变量前加上 “@@” 符号, 叫做 系统变量 </p>
<h3 id="4-6-4-case结构"><a href="#4-6-4-case结构" class="headerlink" title="4.6.4 case结构"></a>4.6.4 case结构</h3><p>语法结构 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">方式一 : 有值，等于执行后面</span><br><span class="line">CASE case_value</span><br><span class="line">  WHEN when_value THEN statement_list</span><br><span class="line">  [WHEN when_value THEN statement_list] ...</span><br><span class="line">  [ELSE statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br><span class="line"></span><br><span class="line">方式二 : 没有值，当条件判断成立，执行后面</span><br><span class="line">CASE</span><br><span class="line">  WHEN search_condition THEN statement_list</span><br><span class="line">  [WHEN search_condition THEN statement_list] ...</span><br><span class="line">  [ELSE statement_list]</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">CASE</span>;</span><br></pre></td></tr></table></figure>

<p>需求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个月份, 然后计算出所在的季度</span><br></pre></td></tr></table></figure>

<p>示例  :</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test8(<span class="keyword">month</span> <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">result</span> <span class="built_in">varchar</span>(<span class="number">20</span>);</span><br><span class="line">  case </span><br><span class="line">    when month &gt;= 1 and month &lt;=3 then </span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> = <span class="string">'第一季度'</span>;</span><br><span class="line">    when month &gt;= 4 and month &lt;=6 then </span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> = <span class="string">'第二季度'</span>;</span><br><span class="line">    when month &gt;= 7 and month &lt;=9 then </span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> = <span class="string">'第三季度'</span>;</span><br><span class="line">    when month &gt;= 10 and month &lt;=12 then </span><br><span class="line">      <span class="keyword">set</span> <span class="keyword">result</span> = <span class="string">'第四季度'</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">case</span>;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'您输入的月份为 :'</span>, <span class="keyword">month</span> , <span class="string">' , 该月份为 : '</span> , <span class="keyword">result</span>) <span class="keyword">as</span> <span class="keyword">content</span> ;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> pro_test8(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>



<h3 id="4-6-5-while循环"><a href="#4-6-5-while循环" class="headerlink" title="4.6.5 while循环"></a>4.6.5 while循环</h3><p>语法结构: </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">while search_condition <span class="keyword">do</span></span><br><span class="line">	statement_list</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">while</span>;</span><br></pre></td></tr></table></figure>

<p>需求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算从1加到n的值</span><br></pre></td></tr></table></figure>

<p>示例  : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test9(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">declare</span> <span class="keyword">num</span> <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">  while num&lt;=n do</span><br><span class="line">    <span class="keyword">set</span> total = total + <span class="keyword">num</span>;</span><br><span class="line">	<span class="keyword">set</span> <span class="keyword">num</span> = <span class="keyword">num</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">while</span>;</span><br><span class="line">  <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> pro_test9(<span class="number">100</span>);</span><br><span class="line">删除</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span>  pro_test9;</span><br></pre></td></tr></table></figure>



<h3 id="4-6-6-repeat结构"><a href="#4-6-6-repeat结构" class="headerlink" title="4.6.6 repeat结构"></a>4.6.6 repeat结构</h3><p>有条件的循环控制语句, 当满足条件的时候退出循环 。while 是满足条件才执行，repeat 是满足条件就退出循环。</p>
<p>语法结构 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REPEAT</span><br><span class="line">  statement_list</span><br><span class="line">  UNTIL search_condition</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">REPEAT</span>;</span><br></pre></td></tr></table></figure>

<p>需求: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算从1加到n的值</span><br></pre></td></tr></table></figure>

<p>示例  : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test10(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  repeat </span><br><span class="line">    <span class="keyword">set</span> total = total + n;</span><br><span class="line">    <span class="keyword">set</span> n = n - <span class="number">1</span>;</span><br><span class="line">    until n=0  </span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">  <span class="keyword">select</span> total ;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> pro_test10(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">注意：until n=0  不加；，加；报错</span><br></pre></td></tr></table></figure>



<h3 id="4-6-7-loop语句"><a href="#4-6-7-loop语句" class="headerlink" title="4.6.7 loop语句"></a>4.6.7 loop语句</h3><p>LOOP 实现简单的循环，退出循环的条件需要使用其他的语句定义，通常可以使用 LEAVE 语句实现，具体语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">  statement_list</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">LOOP</span> [end_label]</span><br></pre></td></tr></table></figure>

<p>如果不在 statement_list 中增加退出循环的语句，那么 LOOP 语句可以用来实现简单的死循环。</p>
<h3 id="4-6-8-leave语句"><a href="#4-6-8-leave语句" class="headerlink" title="4.6.8 leave语句"></a>4.6.8 leave语句</h3><p>用来从标注的流程构造中退出，通常和 BEGIN … END 或者循环一起使用。下面是一个使用 LOOP 和 LEAVE 的简单例子 , 退出循环：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> pro_test11(n <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">declare</span> total <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">0</span>;</span><br><span class="line">  ins: LOOP   </span><br><span class="line">    IF n &lt;= 0 then</span><br><span class="line">      leave ins;</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">    <span class="keyword">set</span> total = total + n;</span><br><span class="line">    <span class="keyword">set</span> n = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">LOOP</span> ins;</span><br><span class="line">  <span class="keyword">select</span> total;</span><br><span class="line"><span class="keyword">END</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"><span class="keyword">call</span> pro_test11(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>



<h3 id="4-6-9-游标-光标"><a href="#4-6-9-游标-光标" class="headerlink" title="4.6.9 游标/光标"></a>4.6.9 游标/光标</h3><p>游标是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p>
<p>声明光标：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> cursor_name <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> select_statement ;</span><br></pre></td></tr></table></figure>

<p>OPEN 光标：打开</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">OPEN cursor_name ;</span><br></pre></td></tr></table></figure>

<p>FETCH 光标：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">FETCH cursor_name INTO var_name [, var_name] ...</span><br></pre></td></tr></table></figure>

<p>CLOSE 光标：关闭</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CLOSE cursor_name ;</span><br></pre></td></tr></table></figure>

<p>示例 : </p>
<p>初始化脚本:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment ,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'姓名'</span>,</span><br><span class="line">  age <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">comment</span> <span class="string">'年龄'</span>,</span><br><span class="line">  salary <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">comment</span> <span class="string">'薪水'</span>,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8 ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>,age,salary) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'金毛狮王'</span>,<span class="number">55</span>,<span class="number">3800</span>),(<span class="literal">null</span>,<span class="string">'白眉鹰王'</span>,<span class="number">60</span>,<span class="number">4000</span>),(<span class="literal">null</span>,<span class="string">'青翼蝠王'</span>,<span class="number">38</span>,<span class="number">2800</span>),(<span class="literal">null</span>,<span class="string">'紫衫龙王'</span>,<span class="number">42</span>,<span class="number">1800</span>);</span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询emp表中数据, 并逐行获取进行展示</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test11()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> e_id <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">declare</span> e_name <span class="built_in">varchar</span>(<span class="number">50</span>);</span><br><span class="line">  <span class="keyword">declare</span> e_age <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">declare</span> e_salary <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">declare</span> emp_result <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line">  open emp_result;</span><br><span class="line">  fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id='</span>,e_id , <span class="string">', name='</span>,e_name, <span class="string">', age='</span>, e_age, <span class="string">', 薪资为: '</span>,e_salary);</span><br><span class="line">  </span><br><span class="line">  fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id='</span>,e_id , <span class="string">', name='</span>,e_name, <span class="string">', age='</span>, e_age, <span class="string">', 薪资为: '</span>,e_salary);</span><br><span class="line">  </span><br><span class="line">  fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id='</span>,e_id , <span class="string">', name='</span>,e_name, <span class="string">', age='</span>, e_age, <span class="string">', 薪资为: '</span>,e_salary);</span><br><span class="line">  </span><br><span class="line">  fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id='</span>,e_id , <span class="string">', name='</span>,e_name, <span class="string">', age='</span>, e_age, <span class="string">', 薪资为: '</span>,e_salary);</span><br><span class="line">  </span><br><span class="line">  fetch emp_result into e_id,e_name,e_age,e_salary;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id='</span>,e_id , <span class="string">', name='</span>,e_name, <span class="string">', age='</span>, e_age, <span class="string">', 薪资为: '</span>,e_salary);</span><br><span class="line">  </span><br><span class="line">  close emp_result;</span><br><span class="line"><span class="keyword">end</span>$</span><br></pre></td></tr></table></figure>

<p>声明：declare XXX cursor for XXX;</p>
<p>当抓取不到数据时，设置变量</p>
<p>定义变量：declare exit handler for not found set XXX;</p>
<p>通过循环结构 , 获取游标中的数据 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> pro_test12()</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">DECLARE</span> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">DECLARE</span> <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">50</span>);</span><br><span class="line">  <span class="keyword">DECLARE</span> age <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">DECLARE</span> salary <span class="built_in">int</span>(<span class="number">11</span>);</span><br><span class="line">  <span class="keyword">DECLARE</span> has_data <span class="built_in">int</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">DECLARE</span> emp_result <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">select</span> * <span class="keyword">from</span> emp;</span><br><span class="line">  <span class="keyword">DECLARE</span> <span class="keyword">EXIT</span> <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">set</span> has_data = <span class="number">0</span>;</span><br><span class="line">  open emp_result;</span><br><span class="line">  repeat</span><br><span class="line">    fetch emp_result into id , name , age , salary;</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">concat</span>(<span class="string">'id为'</span>,<span class="keyword">id</span>, <span class="string">', name 为'</span> ,<span class="keyword">name</span> , <span class="string">', age为 '</span> ,age , <span class="string">', 薪水为: '</span>, salary);</span><br><span class="line">    until has_data = 0</span><br><span class="line">  <span class="keyword">end</span> <span class="keyword">repeat</span>;</span><br><span class="line">  close emp_result;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">DELIMITER ; </span><br><span class="line"><span class="keyword">call</span> pro_test12();</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-27.png" alt="1-27"></p>
<h2 id="4-7-存储函数"><a href="#4-7-存储函数" class="headerlink" title="4.7 存储函数"></a>4.7 存储函数</h2><p>语法结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION function_name([param type ... ]) </span><br><span class="line">RETURNS type </span><br><span class="line">BEGIN</span><br><span class="line">	...</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<p>案例 : </p>
<p>定义一个存储过程, 请求满足条件的总记录数 ;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> count_city(countryId <span class="built_in">int</span>)</span><br><span class="line"><span class="keyword">returns</span> <span class="built_in">int</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">declare</span> cnum <span class="built_in">int</span> ;</span><br><span class="line">  <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">into</span> cnum <span class="keyword">from</span> city <span class="keyword">where</span> country_id = countryId;</span><br><span class="line">  return cnum;</span><br><span class="line"><span class="keyword">end</span>$</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br></pre></td></tr></table></figure>

<p>调用: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select count_city(1);</span><br><span class="line">select count_city(2);</span><br><span class="line">删除</span><br><span class="line">drop function count_city();</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-28.png" alt="1-28"></p>
<p>出现错误：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">ERROR 1418 (HY000): This function has none of DETERMINISTIC, NO SQL, or READS SQL DATA in its declaration and binary logging is enabled (you *might* want to use the less safe log_bin_trust_function_creators variable)</span><br></pre></td></tr></table></figure>

<p>解决方案：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> log_bin_trust_function_creators=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.jb51.net/article/97037.htm" target="_blank" rel="noopener">mysql 报错This function has none of DETERMINISTIC解决方案</a></p>
<h1 id="5-触发器"><a href="#5-触发器" class="headerlink" title="5. 触发器"></a>5. 触发器</h1><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><p>触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句集合。触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p>
<p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<table>
<thead>
<tr>
<th>触发器类型</th>
<th>NEW 和 OLD的使用</th>
</tr>
</thead>
<tbody><tr>
<td>INSERT 型触发器</td>
<td>NEW 表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE 型触发器</td>
<td>OLD 表示修改之前的数据 , NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE 型触发器</td>
<td>OLD 表示将要或者已经删除的数据</td>
</tr>
</tbody></table>
<h2 id="5-2-创建触发器"><a href="#5-2-创建触发器" class="headerlink" title="5.2 创建触发器"></a>5.2 创建触发器</h2><p>语法结构 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name </span><br><span class="line"><span class="keyword">before</span>/<span class="keyword">after</span> <span class="keyword">insert</span>/<span class="keyword">update</span>/<span class="keyword">delete</span></span><br><span class="line"><span class="keyword">on</span> tbl_name </span><br><span class="line">[ <span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> ]  <span class="comment">-- 行级触发器</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">	trigger_stmt ;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure>

<p>示例 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过触发器记录 emp 表的数据变更日志 , 包含增加, 修改 , 删除 ;</span><br></pre></td></tr></table></figure>

<p>首先创建一张日志表 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp_logs(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> auto_increment,</span><br><span class="line">  operation <span class="built_in">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作类型, insert/update/delete'</span>,</span><br><span class="line">  operate_time datetime <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作时间'</span>,</span><br><span class="line">  operate_id <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'操作表的ID'</span>,</span><br><span class="line">  operate_params <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">comment</span> <span class="string">'操作参数'</span>,</span><br><span class="line">  primary <span class="keyword">key</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">innodb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br></pre></td></tr></table></figure>

<p>创建 insert 型触发器，完成插入数据时的日志记录 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_insert_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">insert</span> </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (<span class="keyword">id</span>,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'insert'</span>,<span class="keyword">now</span>(),new.id,<span class="keyword">concat</span>(<span class="string">'插入后(id:'</span>,new.id,<span class="string">', name:'</span>,new.name,<span class="string">', age:'</span>,new.age,<span class="string">', salary:'</span>,new.salary,<span class="string">')'</span>));	</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>创建 update 型触发器，完成更新数据时的日志记录 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_update_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">update</span> </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (<span class="keyword">id</span>,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'update'</span>,<span class="keyword">now</span>(),new.id,<span class="keyword">concat</span>(<span class="string">'修改前(id:'</span>,old.id,<span class="string">', name:'</span>,old.name,<span class="string">', age:'</span>,old.age,<span class="string">', salary:'</span>,old.salary,<span class="string">') , 修改后(id'</span>,new.id, <span class="string">'name:'</span>,new.name,<span class="string">', age:'</span>,new.age,<span class="string">', salary:'</span>,new.salary,<span class="string">')'</span>));</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>创建delete 行的触发器 , 完成删除数据时的日志记录 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> emp_logs_delete_trigger</span><br><span class="line"><span class="keyword">after</span> <span class="keyword">delete</span> </span><br><span class="line"><span class="keyword">on</span> emp </span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span> </span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">into</span> emp_logs (<span class="keyword">id</span>,operation,operate_time,operate_id,operate_params) <span class="keyword">values</span>(<span class="literal">null</span>,<span class="string">'delete'</span>,<span class="keyword">now</span>(),old.id,<span class="keyword">concat</span>(<span class="string">'删除前(id:'</span>,old.id,<span class="string">', name:'</span>,old.name,<span class="string">', age:'</span>,old.age,<span class="string">', salary:'</span>,old.salary,<span class="string">')'</span>));</span><br><span class="line"><span class="keyword">end</span> $</span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>,age,salary) <span class="keyword">values</span>(<span class="literal">null</span>, <span class="string">'光明左使'</span>,<span class="number">30</span>,<span class="number">3500</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> emp(<span class="keyword">id</span>,<span class="keyword">name</span>,age,salary) <span class="keyword">values</span>(<span class="literal">null</span>, <span class="string">'光明右使'</span>,<span class="number">33</span>,<span class="number">3200</span>);</span><br><span class="line"><span class="keyword">update</span> emp <span class="keyword">set</span> age = <span class="number">39</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> emp <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>

<p><img src="../images/mysql/1-29.png" alt="1-29"></p>
<h2 id="5-3-删除触发器"><a href="#5-3-删除触发器" class="headerlink" title="5.3 删除触发器"></a>5.3 删除触发器</h2><p>语法结构 : </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> [schema_name.]trigger_name</span><br></pre></td></tr></table></figure>

<p>如果没有指定 schema_name，默认为当前数据库 。</p>
<h2 id="5-4-查看触发器"><a href="#5-4-查看触发器" class="headerlink" title="5.4 查看触发器"></a>5.4 查看触发器</h2><p>可以通过执行 SHOW TRIGGERS 命令查看触发器的状态、语法等信息。</p>
<p>语法结构 ： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span> ；</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的安装</title>
    <url>/post/a2918a76.html</url>
    <content><![CDATA[<p>VMware15虚拟机的安装和Linux的安装</p>
<a id="more"></a>

<h1 id="1-下载虚拟机"><a href="#1-下载虚拟机" class="headerlink" title="1.下载虚拟机"></a>1.下载虚拟机</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&mid=502715453&idx=1&sn=f08535e26e03d71589f405b663b2ce0b&chksm=0ee174d13996fdc7523236ce503a76dd85a71cb04cfa20013bc2e1b0bdd6aa813157c2116951&mpshare=1&scene=1&srcid=&sharer_sharetime=1586086410573&sharer_shareid=00eea3a26ac4fddadd3fa5b3a756a18a&key=b112a119ee94d5a08ecd5718883901159a366854de22a1d0fab4ca324e093b776fe869cddf1171b33974485d91d9397046ed6918b639a2ee17b1dc1dbe76f9455e75dc31a7c7cb0220f4a21a5e64c361&ascene=1&uin=MjI5NzAyNTcwNA%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=A5q7S6WeY750bFB9gMgXOZk%3D&pass_ticket=WYA3RU%2BMpXrRlJCd0hS%2BAyjJiQHODsGe0ktghsN%2FJlfmVEmVQ0vzrCsv9ofCpNow" target="_blank" rel="noopener">VMware15虚拟机安装教程</a></p>
<h1 id="2-找好目录，安装虚拟机"><a href="#2-找好目录，安装虚拟机" class="headerlink" title="2.找好目录，安装虚拟机"></a>2.找好目录，安装虚拟机</h1><h1 id="3-最重要，许可证秘钥"><a href="#3-最重要，许可证秘钥" class="headerlink" title="3.最重要，许可证秘钥"></a>3.最重要，许可证秘钥</h1><p>许可证密钥输入：UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA</p>
<h1 id="4-安装完成"><a href="#4-安装完成" class="headerlink" title="4.安装完成"></a>4.安装完成</h1><h1 id="5-个人找Linux-CentOS安装包"><a href="#5-个人找Linux-CentOS安装包" class="headerlink" title="5.个人找Linux  CentOS安装包"></a>5.个人找Linux  CentOS安装包</h1><h1 id="6-在虚拟机上安装"><a href="#6-在虚拟机上安装" class="headerlink" title="6.在虚拟机上安装"></a>6.在虚拟机上安装</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzIwMjE1MjMyMw==&mid=502716093&idx=3&sn=3f240cd8e722e34e4b3d7bb1ab695cc3&chksm=0ee176513996ff47cb6842f777d6ffcd6f05880e35f8de5900686796150083b3f3a0e9c70689&mpshare=1&scene=1&srcid=&sharer_sharetime=1586093264959&sharer_shareid=00eea3a26ac4fddadd3fa5b3a756a18a&key=9b8298cd804d9d6f130eef24891416fdb6d920b99fbe8ac008c8f2c3b26e8a48de43c76b50b6da67f557e7c59afe8f41e48676572491ad0383579f0e816cbf13148a52e82c1bbd151789e49938e766e3&ascene=1&uin=MjI5NzAyNTcwNA%3D%3D&devicetype=Windows+10&version=62080079&lang=zh_CN&exportkey=AzgLKkH5jMTuRR%2BHpMuuToE%3D&pass_ticket=tLeqXemrkkNLr6zzulu1SnD2PiVWaH0C1TpV7VRcuzCCC68AhteAK3kDUJffRC%2Fh" target="_blank" rel="noopener">Linux CentOS安装教程</a></p>
<p><a href="https://www.runoob.com/w3cnote/vmware-install-centos7.html" target="_blank" rel="noopener">VMware 安装 Centos7 超详细过程</a></p>
<h1 id="7-开启Linux"><a href="#7-开启Linux" class="headerlink" title="7.开启Linux"></a>7.开启Linux</h1><p><img src="../images/linux/1.png" alt="1"></p>
<h1 id="8-开启中文"><a href="#8-开启中文" class="headerlink" title="8.开启中文"></a>8.开启中文</h1><p><img src="../images/linux/2.png" alt="2"></p>
<p><img src="../images/linux/3.png" alt="3"></p>
<h1 id="9-开网"><a href="#9-开网" class="headerlink" title="9.开网"></a>9.开网</h1><p><img src="../images/linux/4-linux%E5%BC%80%E7%BD%91-2.png" alt="4-linux开网-2"></p>
<p>还不行：</p>
<p>打开终端后我们就可以通过命令来操作</p>
<p>vim /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<p>网卡的默认路径，ifcfg-ens33是Linux的默认网卡配置文件</p>
<p>进入后页面</p>
<p><img src="../images/linux/6.png" alt="6"></p>
<p>退出后，输入命令service network restart重启网络服务,点击回车…</p>
<p>输入命令ifconfig查看IP地址,我们能看到ens33网卡成功获取网络地址…</p>
<p>退出终端，打开火狐浏览器，输入百度网址，成功访问4399…</p>
<p><img src="../images/linux/7.png" alt="7"></p>
]]></content>
      <categories>
        <category>后端</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>rides的学习与使用</title>
    <url>/post/2c753e03.html</url>
    <content><![CDATA[<p>rides的学习与使用</p>
<a id="more"></a>

<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h1><p>​    redis是一款高性能的NOSQL系列的非关系型数据库</p>
<ul>
<li>关系型数据库：mysql，oracle<ul>
<li>数据之间有关联关系</li>
<li>数据存储在硬盘的文件上</li>
</ul>
</li>
<li>非关系型数据库（NoSQL）：redis，hbase<ul>
<li>存储 Key：value</li>
<li>数据之间没有关联关系</li>
<li>数据存储在内存中</li>
</ul>
</li>
</ul>
<p>如果经常查询一些不太经常发生变化的数据</p>
<p><img src="../images/rides/1.png" alt="1"></p>
<h2 id="1-1-什么是NOSQL"><a href="#1-1-什么是NOSQL" class="headerlink" title="1.1.什么是NOSQL"></a>1.1.什么是NOSQL</h2><p>​    NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。</p>
<p>​    随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。</p>
<h3 id="1-1-1-NOSQL和关系型数据库比较"><a href="#1-1-1-NOSQL和关系型数据库比较" class="headerlink" title="1.1.1.NOSQL和关系型数据库比较"></a>1.1.1.NOSQL和关系型数据库比较</h3><ul>
<li>优点：<ul>
<li>成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。</li>
<li>查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。</li>
<li>存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。</li>
<li>扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。</li>
</ul>
</li>
<li>缺点：<ul>
<li>维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。</li>
<li>不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。</li>
<li>不提供关系型数据库对事务的处理。</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-非关系型数据库的优势："><a href="#1-1-2-非关系型数据库的优势：" class="headerlink" title="1.1.2.非关系型数据库的优势："></a>1.1.2.非关系型数据库的优势：</h3><ul>
<li>性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li>
<li>可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li>
</ul>
<h3 id="1-1-3-关系型数据库的优势："><a href="#1-1-3-关系型数据库的优势：" class="headerlink" title="1.1.3.关系型数据库的优势："></a>1.1.3.关系型数据库的优势：</h3><ul>
<li>复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li>
<li>事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</li>
</ul>
<h3 id="1-1-4-总结"><a href="#1-1-4-总结" class="headerlink" title="1.1.4.总结"></a>1.1.4.总结</h3><ul>
<li>关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，让NoSQL数据库对关系型数据库的不足进行弥补。</li>
<li>一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据</li>
</ul>
<h2 id="1-2-主流的NOSQL产品"><a href="#1-2-主流的NOSQL产品" class="headerlink" title="1.2.主流的NOSQL产品"></a>1.2.主流的NOSQL产品</h2><ul>
<li>键值(Key-Value)存储数据库<ul>
<li>相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB</li>
<li>典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 </li>
<li>数据模型： 一系列键值对</li>
<li>优势： 快速查询</li>
<li>劣势： 存储的数据缺少结构化</li>
</ul>
</li>
<li>列存储数据库<ul>
<li>相关产品：Cassandra, HBase, Riak</li>
<li>典型应用：分布式的文件系统</li>
<li>数据模型：以列簇式存储，将同一列数据存在一起</li>
<li>优势：查找速度快，可扩展性强，更容易进行分布式扩展</li>
<li>劣势：功能相对局限</li>
</ul>
</li>
<li>文档型数据库<ul>
<li>相关产品：CouchDB、MongoDB</li>
<li>典型应用：Web应用（与Key-Value类似，Value是结构化的）</li>
<li>数据模型： 一系列键值对</li>
<li>优势：数据结构要求不严格</li>
<li>劣势： 查询性能不高，而且缺乏统一的查询语法</li>
</ul>
</li>
<li>图形(Graph)数据库<ul>
<li>相关数据库：Neo4J、InfoGrid、Infinite Graph</li>
<li>典型应用：社交网络</li>
<li>数据模型：图结构</li>
<li>优势：利用图结构相关算法。</li>
<li>劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。</li>
</ul>
</li>
</ul>
<h2 id="1-3-什么是Redis"><a href="#1-3-什么是Redis" class="headerlink" title="1.3 什么是Redis"></a>1.3 什么是Redis</h2><p>​    Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p>
<ul>
<li>字符串类型 string</li>
<li>哈希类型 hash</li>
<li>列表类型 list</li>
<li>集合类型 set</li>
<li>有序集合类型 sortedset</li>
</ul>
<h3 id="1-3-1-redis的应用场景"><a href="#1-3-1-redis的应用场景" class="headerlink" title="1.3.1 redis的应用场景"></a>1.3.1 redis的应用场景</h3><ol>
<li>缓存（数据查询、短连接、新闻内容、商品内容等等）</li>
<li>聊天室的在线好友列表</li>
<li>任务队列。（秒杀、抢购、12306等等）</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>数据过期处理（可以精确到毫秒</li>
<li>分布式集群架构中的session分离</li>
</ol>
<h1 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2.下载安装"></a>2.下载安装</h1><ol>
<li>官网：<a href="https://redis.io" target="_blank" rel="noopener">https://redis.io</a></li>
<li>中文网：<a href="http://www.redis.net.cn/" target="_blank" rel="noopener">http://www.redis.net.cn/</a></li>
<li>解压直接可以使用：<ul>
<li>redis.windows.conf：配置文件</li>
<li>redis-cli.exe：redis的客户端</li>
<li>redis-server.exe：redis服务器端</li>
</ul>
</li>
</ol>
<h1 id="3-命令操作"><a href="#3-命令操作" class="headerlink" title="3.命令操作"></a>3.命令操作</h1><h2 id="1-redis的数据结构："><a href="#1-redis的数据结构：" class="headerlink" title="1.redis的数据结构："></a>1.redis的数据结构：</h2><ul>
<li>redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构<ul>
<li>value的数据结构：<br>1) 字符串类型 string<br>2) 哈希类型 hash ： map格式<br>3) 列表类型 list ： linkedlist格式。支持重复元素<br>4) 集合类型 set  ： 不允许重复元素<br>5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序</li>
</ul>
</li>
</ul>
<p><img src="../images/rides/2.png" alt="2"></p>
<h2 id="2-字符串类型-string"><a href="#2-字符串类型-string" class="headerlink" title="2.字符串类型 string"></a>2.字符串类型 string</h2><ol>
<li>存储： set key value<br>127.0.0.1:6379&gt; set username zhangsan<br>OK</li>
<li>获取： get key<br>127.0.0.1:6379&gt; get username<br>“zhangsan”</li>
<li>删除： del key<br>127.0.0.1:6379&gt; del age<br>(integer) 1</li>
</ol>
<h2 id="3-哈希类型-hash"><a href="#3-哈希类型-hash" class="headerlink" title="3.哈希类型 hash"></a>3.哈希类型 hash</h2><ol>
<li>存储： hset key field value<br>127.0.0.1:6379&gt; hset myhash username list<br>(integer) 1<br>127.0.0.1:6379&gt; hset myhash password 123<br>(integer) 1</li>
<li>获取： <ul>
<li>hget key field: 获取指定的field对应的值<br>127.0.0.1:6379&gt; hget myhash username<br>“lisi”</li>
<li>hgetall key：获取所有的field和value<br>127.0.0.1:6379&gt; hgetall myhash<br>1) “username”<br>2) “list”<br>3) “password”<br>4) “123”</li>
</ul>
</li>
<li>删除： hdel key field<br>127.0.0.1:6379&gt; hdel myhash username<br>(integer) 1</li>
</ol>
<h2 id="4-列表类型-list"><a href="#4-列表类型-list" class="headerlink" title="4.列表类型 list"></a>4.列表类型 list</h2><p>Redis列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）</p>
<ol>
<li><p>添加：</p>
<ol>
<li><p>lpush key value: 将元素加入列表左表</p>
</li>
<li><p>rpush key value：将元素加入列表右边</p>
<p>127.0.0.1:6379&gt; lpush myList a<br>(integer) 1<br>127.0.0.1:6379&gt; lpush myList b<br>(integer) 2<br>127.0.0.1:6379&gt; rpush myList c<br>(integer) 3</p>
</li>
</ol>
</li>
<li><p>获取：</p>
<ul>
<li>lrange key start end ：范围获取<br>127.0.0.1:6379&gt; lrange myList 0 -1（所有元素）<br>1) “b”<br>2) “a”<br>3) “c”</li>
</ul>
</li>
<li><p>删除：</p>
<ul>
<li>lpop key： 删除列表最左边的元素，并将元素返回</li>
<li>rpop key： 删除列表最右边的元素，并将元素返回</li>
</ul>
</li>
</ol>
<p><img src="../images/rides/3.png" alt="3"></p>
<h2 id="5-集合类型-set-：-不允许重复元素"><a href="#5-集合类型-set-：-不允许重复元素" class="headerlink" title="5.集合类型 set ： 不允许重复元素"></a>5.集合类型 set ： 不允许重复元素</h2><p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。</p>
<p>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p>
<ol>
<li>存储：sadd key value<br>127.0.0.1:6379&gt; sadd myset a<pre><code>(integer) 1
127.0.0.1:6379&gt; sadd myset a
(integer) 0</code></pre></li>
<li>获取：smembers key:获取set集合中所有元素<br>127.0.0.1:6379&gt; smembers myset<pre><code>1) &quot;a&quot;</code></pre></li>
<li>删除：srem key value:删除set集合中的某个元素<br>127.0.0.1:6379&gt; srem myset a<pre><code>(integer) 1</code></pre></li>
</ol>
<h2 id="6-有序集合类型-sortedset"><a href="#6-有序集合类型-sortedset" class="headerlink" title="6.有序集合类型 sortedset"></a>6.有序集合类型 sortedset</h2><p>Redis 有序集合和集合一样也是string类型元素的集合,且不允许重复的成员。</p>
<p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 232 - 1</p>
<p>不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<ol>
<li><p>存储：zadd key score value<br>127.0.0.1:6379&gt; zadd mysort 60 zhangsan</p>
<pre><code>(integer) 1
127.0.0.1:6379&gt; zadd mysort 50 lisi
(integer) 1
127.0.0.1:6379&gt; zadd mysort 80 wangwu
(integer) 1</code></pre></li>
<li><p>获取：zrange key start end [withscores]<br>127.0.0.1:6379&gt; zrange mysort 0 -1</p>
<pre><code> 1) &quot;lisi&quot;
 2) &quot;zhangsan&quot;
 3) &quot;wangwu&quot;

127.0.0.1:6379&gt; zrange mysort 0 -1 withscores
1) &quot;zhangsan&quot;
2) &quot;60&quot;
3) &quot;wangwu&quot;
4) &quot;80&quot;
5) &quot;lisi&quot;
6) &quot;500&quot;</code></pre></li>
<li><p>删除：zrem key value<br>127.0.0.1:6379&gt; zrem mysort lisi</p>
<pre><code>(integer) 1</code></pre></li>
</ol>
<h2 id="7-通用命令"><a href="#7-通用命令" class="headerlink" title="7.通用命令"></a>7.通用命令</h2><ol>
<li>keys * : 查询所有的键</li>
<li>type key ： 获取键对应的value的类型</li>
<li>del key：删除指定的key value</li>
</ol>
<h1 id="4-持久化"><a href="#4-持久化" class="headerlink" title="4.持久化"></a>4.持久化</h1><ol>
<li><p>redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。</p>
</li>
<li><p>redis持久化机制：</p>
<ol>
<li><p>RDB：默认方式，不需要进行配置，默认就使用这种机制</p>
<ul>
<li>在一定的间隔时间中，检测key的变化情况，然后持久化数据</li>
</ul>
<ol>
<li><p>编辑redis.windwos.conf文件</p>
<p>after 900 sec (15 min) if at least 1 key changed</p>
<p>save 900 1（15分钟后有1个key发生改变，持久化一次）</p>
<p>after 300 sec (5 min) if at least 10 keys changed</p>
<p>save 300 10（5分钟后大于10个key发生改变，持久化一次）</p>
<p>after 60 sec if at least 10000 keys changed</p>
<p>save 60 10000（60秒后大于10000个key发生改变，持久化一次）</p>
</li>
<li><p>重新启动redis服务器，并指定配置文件名称<br>D:\redis-2.8.9&gt;redis-server.exe redis.windows.conf    </p>
</li>
</ol>
</li>
<li><p>AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据</p>
<ol>
<li><p>编辑redis.windwos.conf文件<br>appendonly no（关闭aof） –&gt; appendonly yes （开启aof）</p>
<p>appendfsync always ： 每一次操作都进行持久化</p>
<p>appendfsync everysec ： 每隔一秒进行一次持久化</p>
<p>appendfsync no     ： 不进行持久化</p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="5-Java客户端-Jedis"><a href="#5-Java客户端-Jedis" class="headerlink" title="5.Java客户端 Jedis"></a>5.Java客户端 Jedis</h1><p>Jedis: 一款java操作redis数据库的工具.</p>
<p>使用步骤：</p>
<h2 id="1-下载jedis的jar包"><a href="#1-下载jedis的jar包" class="headerlink" title="1.下载jedis的jar包"></a>1.下载jedis的jar包</h2><p>地址：<a href="https://mvnrepository.com/artifact/redis.clients/jedis" target="_blank" rel="noopener">https://mvnrepository.com/artifact/redis.clients/jedis</a></p>
<h2 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//2. 操作</span></span><br><span class="line">    jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">rides：keys *</span><br></pre></td></tr></table></figure>

<h2 id="3-Jedis操作各种redis中的数据结构"><a href="#3-Jedis操作各种redis中的数据结构" class="headerlink" title="3.Jedis操作各种redis中的数据结构"></a>3.Jedis操作各种redis中的数据结构</h2><h3 id="3-1-字符串类型-string：set、get"><a href="#3-1-字符串类型-string：set、get" class="headerlink" title="3-1.字符串类型 string：set、get"></a>3-1.字符串类型 string：set、get</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * string 数据结构操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">    <span class="comment">//如果使用空参构造，默认值 "localhost",6379端口</span></span><br><span class="line">    <span class="comment">//2. 操作</span></span><br><span class="line">    <span class="comment">//存储</span></span><br><span class="line">    jedis.set(<span class="string">"username"</span>,<span class="string">"zhangsan"</span>);</span><br><span class="line">    <span class="comment">//获取</span></span><br><span class="line">    String username = jedis.get(<span class="string">"username"</span>);</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="comment">//可以使用setex()方法存储可以指定过期时间的 key value</span></span><br><span class="line">    jedis.setex(<span class="string">"activecode"</span>,<span class="number">20</span>,<span class="string">"hehe"</span>);</span><br><span class="line">    <span class="comment">//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对</span></span><br><span class="line">    <span class="comment">//3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-哈希类型-hash-：-map格式"><a href="#3-2-哈希类型-hash-：-map格式" class="headerlink" title="3-2.哈希类型 hash ： map格式"></a>3-2.哈希类型 hash ： map格式</h3><p>操作：hset、hget、hgetAll</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">    <span class="comment">//2. 操作</span></span><br><span class="line">    <span class="comment">// 存储hash</span></span><br><span class="line">    jedis.hset(<span class="string">"user"</span>,<span class="string">"name"</span>,<span class="string">"lisi"</span>);</span><br><span class="line">    jedis.hset(<span class="string">"user"</span>,<span class="string">"age"</span>,<span class="string">"23"</span>);</span><br><span class="line">    jedis.hset(<span class="string">"user"</span>,<span class="string">"gender"</span>,<span class="string">"female"</span>);</span><br><span class="line">    <span class="comment">// 获取hash</span></span><br><span class="line">    String name = jedis.hget(<span class="string">"user"</span>, <span class="string">"name"</span>);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">    <span class="comment">// 获取hash的所有map中的数据</span></span><br><span class="line">    Map&lt;String, String&gt; user = jedis.hgetAll(<span class="string">"user"</span>);</span><br><span class="line">    <span class="comment">// keyset</span></span><br><span class="line">    Set&lt;String&gt; keySet = user.keySet();</span><br><span class="line">    <span class="keyword">for</span> (String key : keySet) &#123;</span><br><span class="line">        <span class="comment">//获取value</span></span><br><span class="line">        String value = user.get(key);</span><br><span class="line">        System.out.println(key + <span class="string">":"</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-列表类型-list-：-linkedlist格式、支持重复元素"><a href="#3-3-列表类型-list-：-linkedlist格式、支持重复元素" class="headerlink" title="3-3.列表类型 list ： linkedlist格式、支持重复元素"></a>3-3.列表类型 list ： linkedlist格式、支持重复元素</h3><p>操作：lpush / rpush、lpop / rpop、lrange start end : 范围获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">    <span class="comment">//2. 操作</span></span><br><span class="line">    <span class="comment">// list 存储</span></span><br><span class="line">    <span class="comment">//从左边存</span></span><br><span class="line">    jedis.lpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">    <span class="comment">//从右边存</span></span><br><span class="line">    jedis.rpush(<span class="string">"mylist"</span>,<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">    <span class="comment">// list 范围获取</span></span><br><span class="line">    List&lt;String&gt; mylist = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(mylist);</span><br><span class="line">    <span class="comment">//[c, b, a, a, b, c]</span></span><br><span class="line">    <span class="comment">// list 弹出</span></span><br><span class="line">    String element1 = jedis.lpop(<span class="string">"mylist"</span>);</span><br><span class="line">    System.out.println(element1);</span><br><span class="line">    <span class="comment">//c</span></span><br><span class="line">    String element2 = jedis.rpop(<span class="string">"mylist"</span>);</span><br><span class="line">    System.out.println(element2);</span><br><span class="line">    <span class="comment">//c</span></span><br><span class="line">    <span class="comment">// list 范围获取</span></span><br><span class="line">    List&lt;String&gt; mylist2 = jedis.lrange(<span class="string">"mylist"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(mylist2);</span><br><span class="line">    <span class="comment">//[b, a, a, b]</span></span><br><span class="line">    <span class="comment">//3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-集合类型-set-：-不允许重复元素"><a href="#3-4-集合类型-set-：-不允许重复元素" class="headerlink" title="3-4.集合类型 set  ： 不允许重复元素"></a>3-4.集合类型 set  ： 不允许重复元素</h3><p>操作：sadd、smembers:获取所有元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">    <span class="comment">//2. 操作</span></span><br><span class="line">    <span class="comment">// set 存储</span></span><br><span class="line">    jedis.sadd(<span class="string">"myset"</span>,<span class="string">"java"</span>,<span class="string">"php"</span>,<span class="string">"c++"</span>);</span><br><span class="line">    <span class="comment">// set 获取</span></span><br><span class="line">    Set&lt;String&gt; myset = jedis.smembers(<span class="string">"myset"</span>);</span><br><span class="line">    System.out.println(myset);</span><br><span class="line">    <span class="comment">//3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-有序集合类型-sortedset：不允许重复元素，且元素有顺序"><a href="#3-5-有序集合类型-sortedset：不允许重复元素，且元素有顺序" class="headerlink" title="3-5.有序集合类型 sortedset：不允许重复元素，且元素有顺序"></a>3-5.有序集合类型 sortedset：不允许重复元素，且元素有顺序</h3><p>操作：zadd、zrange</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. 获取连接</span></span><br><span class="line">    Jedis jedis = <span class="keyword">new</span> Jedis();</span><br><span class="line">    <span class="comment">//2. 操作</span></span><br><span class="line">    <span class="comment">// sortedset 存储</span></span><br><span class="line">    jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">3</span>,<span class="string">"亚瑟"</span>);</span><br><span class="line">    jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">30</span>,<span class="string">"后裔"</span>);</span><br><span class="line">    jedis.zadd(<span class="string">"mysortedset"</span>,<span class="number">55</span>,<span class="string">"孙悟空"</span>);</span><br><span class="line">    <span class="comment">// sortedset 获取</span></span><br><span class="line">    Set&lt;String&gt; mysortedset = jedis.zrange(<span class="string">"mysortedset"</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">    System.out.println(mysortedset);</span><br><span class="line">    <span class="comment">//3. 关闭连接</span></span><br><span class="line">    jedis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-jedis连接池：-JedisPool"><a href="#3-6-jedis连接池：-JedisPool" class="headerlink" title="3-6. jedis连接池： JedisPool"></a>3-6. jedis连接池： JedisPool</h3><p>使用：</p>
<ol>
<li>创建JedisPool连接池对象</li>
<li>调用方法 getResource()方法获取Jedis连接</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//0.创建一个配置对象</span></span><br><span class="line">    JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">    <span class="comment">//最大活动对象数</span></span><br><span class="line">    config.setMaxTotal(<span class="number">50</span>);</span><br><span class="line">    <span class="comment">//最大能够保持idel状态的对象数</span></span><br><span class="line">    config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">//1.创建Jedis连接池对象</span></span><br><span class="line">    JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config,<span class="string">"localhost"</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="comment">//2.获取连接</span></span><br><span class="line">    Jedis jedis = jedisPool.getResource();</span><br><span class="line">    <span class="comment">//3. 使用</span></span><br><span class="line">    jedis.set(<span class="string">"hehe"</span>,<span class="string">"heihei"</span>);</span><br><span class="line">    <span class="comment">//4. 关闭 归还到连接池中</span></span><br><span class="line">    jedis.close();;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="jedis详细配置"><a href="#jedis详细配置" class="headerlink" title="jedis详细配置"></a>jedis详细配置</h3><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最大活动对象数     </span></span><br><span class="line"><span class="meta">redis.pool.maxTotal</span>=<span class="string">1000    </span></span><br><span class="line"><span class="comment">#最大能够保持idel状态的对象数      </span></span><br><span class="line"><span class="meta">redis.pool.maxIdle</span>=<span class="string">100  </span></span><br><span class="line"><span class="comment">#最小能够保持idel状态的对象数   </span></span><br><span class="line"><span class="meta">redis.pool.minIdle</span>=<span class="string">50    </span></span><br><span class="line"><span class="comment">#当池内没有返回对象时，最大等待时间    </span></span><br><span class="line"><span class="meta">redis.pool.maxWaitMillis</span>=<span class="string">10000    </span></span><br><span class="line"><span class="comment">#当调用borrow Object方法时，是否进行有效性检查    </span></span><br><span class="line"><span class="meta">redis.pool.testOnBorrow</span>=<span class="string">true    </span></span><br><span class="line"><span class="comment">#当调用return Object方法时，是否进行有效性检查    </span></span><br><span class="line"><span class="meta">redis.pool.testOnReturn</span>=<span class="string">true  </span></span><br><span class="line"><span class="comment">#“空闲链接”检测线程，检测的周期，毫秒数。如果为负值，表示不运行“检测线程”。默认为-1.  </span></span><br><span class="line"><span class="meta">redis.pool.timeBetweenEvictionRunsMillis</span>=<span class="string">30000  </span></span><br><span class="line"><span class="comment">#向调用者输出“链接”对象时，是否检测它的空闲超时；  </span></span><br><span class="line"><span class="meta">redis.pool.testWhileIdle</span>=<span class="string">true  </span></span><br><span class="line"><span class="comment"># 对于“空闲链接”检测线程而言，每次检测的链接资源的个数。默认为3.  </span></span><br><span class="line"><span class="meta">redis.pool.numTestsPerEvictionRun</span>=<span class="string">50  </span></span><br><span class="line"><span class="comment">#redis服务器的IP    </span></span><br><span class="line"><span class="meta">redis.ip</span>=<span class="string">xxxxxx  </span></span><br><span class="line"><span class="comment">#redis服务器的Port    </span></span><br><span class="line"><span class="meta">redis1.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<h3 id="3-7-Jedis连接池工具类"><a href="#3-7-Jedis连接池工具类" class="headerlink" title="3-7.Jedis连接池工具类"></a>3-7.Jedis连接池工具类</h3><p>JedisPool工具类:</p>
<ul>
<li>加载配置文件，配置连接池的参数</li>
<li>提供获取连接的方法</li>
</ul>
<p>jedis.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="attr">port</span>=<span class="string">6379</span></span><br><span class="line"><span class="attr">maxTotal</span>=<span class="string">50</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">10</span></span><br></pre></td></tr></table></figure>

<p>工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//读取配置文件</span></span><br><span class="line">        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");</span><br><span class="line">        <span class="comment">//创建Properties对象</span></span><br><span class="line">        Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//关联文件</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            pro.load(is);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取数据，设置到JedisPoolConfig中</span></span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(Integer.parseInt(pro.getProperty(<span class="string">"maxTotal"</span>)));</span><br><span class="line">        config.setMaxIdle(Integer.parseInt(pro.getProperty(<span class="string">"maxIdle"</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化JedisPool</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config,pro.getProperty(<span class="string">"host"</span>),Integer.parseInt(pro.getProperty(<span class="string">"port"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//通过连接池工具类获取</span></span><br><span class="line">    Jedis jedis = JedisPoolUtils.getJedis();</span><br><span class="line">    <span class="comment">//2. 使用</span></span><br><span class="line">    jedis.set(<span class="string">"hello"</span>,<span class="string">"world"</span>);</span><br><span class="line">    <span class="comment">//3. 关闭 归还到连接池中</span></span><br><span class="line">    jedis.close();;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h1><ol>
<li>提供index.html页面，页面中有一个省份 下拉列表</li>
<li>当页面加载完成后 发送ajax请求，加载所有省份</li>
</ol>
<ul>
<li>注意：使用redis缓存一些不经常发生变化的数据。<ul>
<li>数据库的数据一旦发生改变，则需要更新缓存。<ul>
<li>数据库的表执行增删改的相关操作，需要将redis缓存数据情况，再次存入</li>
<li>在service对应的增删改方法中，将redis数据删除。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="../images/rides/5.png" alt="5"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//domain</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Province</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dao</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProvinceDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Province&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>druif.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/redis?serverTimezone=UTC</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">1234</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">5</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">3000</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//工具类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDBC工具类 使用Durid连接池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds ;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.加载配置文件</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            <span class="comment">//使用ClassLoader加载配置文件，获取字节输入流</span></span><br><span class="line">            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties");</span><br><span class="line">            pro.load(is);</span><br><span class="line">            <span class="comment">//2.初始化连接池对象</span></span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接池对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取连接Connection对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dao/impl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProvinceDaoImpl</span> <span class="keyword">implements</span> <span class="title">ProvinceDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.声明成员变量 jdbctemplement</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate template = <span class="keyword">new</span> JdbcTemplate(JDBCUtils.getDataSource());</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Province&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.定义sql</span></span><br><span class="line">        String sql = <span class="string">"select * from province "</span>;</span><br><span class="line">        <span class="comment">//2.执行sql</span></span><br><span class="line">        List&lt;Province&gt; list = template.query(sql, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Province&gt;(Province<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProvinceService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Province&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//redis+数据库</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAllJson</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//service/impl</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProvinceServiceImpl</span> <span class="keyword">implements</span> <span class="title">ProvinceService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//声明dao</span></span><br><span class="line">    <span class="keyword">private</span> ProvinceDao dao = <span class="keyword">new</span> ProvinceDaoImpl();</span><br><span class="line">    <span class="comment">//查询数据库</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Province&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//使用redis缓存，工具类JedisPoolUtils之前有写</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAllJson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.先从redis中查询数据</span></span><br><span class="line">        <span class="comment">//1.1获取redis客户端连接</span></span><br><span class="line">        Jedis jedis = JedisPoolUtils.getJedis();</span><br><span class="line">        String province_json = jedis.get(<span class="string">"province"</span>);</span><br><span class="line">        <span class="comment">//2判断 province_json 数据是否为null</span></span><br><span class="line">        <span class="keyword">if</span>(province_json == <span class="keyword">null</span> || province_json.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//redis中没有数据</span></span><br><span class="line">            System.out.println(<span class="string">"redis中没数据，查询数据库..."</span>);</span><br><span class="line">            <span class="comment">//2.1从数据中查询</span></span><br><span class="line">            List&lt;Province&gt; ps = dao.findAll();</span><br><span class="line">            <span class="comment">//2.2将list序列化为json</span></span><br><span class="line">            ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                province_json = mapper.writeValueAsString(ps);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.3 将json数据存入redis</span></span><br><span class="line">            jedis.set(<span class="string">"province"</span>,province_json);</span><br><span class="line">            <span class="comment">//归还连接</span></span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"redis中有数据，查询缓存..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> province_json;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>web层：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/provinceServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProvinceServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//数据库</span></span><br><span class="line">        <span class="comment">//1.调用service查询</span></span><br><span class="line">        ProvinceService service = <span class="keyword">new</span> ProvinceServiceImpl();</span><br><span class="line">        List&lt;Province&gt; list = service.findAll();</span><br><span class="line">        <span class="comment">//2.序列化list为json</span></span><br><span class="line">        ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        String json = mapper.writeValueAsString(list);</span><br><span class="line">        <span class="comment">//reids</span></span><br><span class="line">        <span class="comment">//1.调用service查询</span></span><br><span class="line">        ProvinceService service2 = <span class="keyword">new</span> ProvinceServiceImpl();</span><br><span class="line">        String json2 = service.findAllJson();</span><br><span class="line">        System.out.println(json2);</span><br><span class="line">        <span class="comment">//3.响应结果</span></span><br><span class="line">        response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">        response.getWriter().write(json2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>index</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.3.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        $(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">//发送ajax请求，加载所有省份数据</span></span></span><br><span class="line"><span class="javascript">            $.<span class="keyword">get</span>("provinceServlet",&#123;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//1.获取select</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> province = $(<span class="string">"#province"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">//2.遍历json数组</span></span></span><br><span class="line"><span class="javascript">                $(data).each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//3.创建&lt;option&gt;</span></span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">var</span> option = <span class="string">"&lt;option name='"</span>+<span class="keyword">this</span>.id+<span class="string">"'&gt;"</span>+<span class="keyword">this</span>.name+<span class="string">"&lt;/option&gt;"</span>;</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">//4.调用select的append追加option</span></span></span><br><span class="line">                    province.append(option);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"province"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>--请选择省份--<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>代码实现成功</p>
<p><img src="../images/rides/4.png" alt="4"></p>
<p>​    </p>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>rides</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title>线程进阶-JUC的学习</title>
    <url>/post/ca16add5.html</url>
    <content><![CDATA[<p>线程进阶-JUC的学习</p>
<a id="more"></a>

<h2 id="1-Java-JUC-简介"><a href="#1-Java-JUC-简介" class="headerlink" title="1.Java JUC 简介"></a>1.Java JUC 简介</h2><p>​    在 Java 5.0 提供了 java.util.concurrent （简称JUC ）包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池、异步 IO 和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中的 Collection 实现等。</p>
<h2 id="2-volatile-关键字-内存可见性"><a href="#2-volatile-关键字-内存可见性" class="headerlink" title="2.volatile 关键字-内存可见性"></a>2.volatile 关键字-内存可见性</h2><ul>
<li>内存可见性（Memory Visibility）：是指当某个线程正在使用对象状态而另一个线程在同时修改该状态，需要确保当一个线程修改了对象状态后，其他线程能够看到发生的状态变化。</li>
<li>可见性错误：是指当读操作与写操作在不同的线程中执行时，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。</li>
<li>我们可以通过同步来保证对象被安全地发布。除此之外我们也可以<br>使用一种更加轻量级的 volatile 变量。</li>
<li>Java 提供了一种稍弱的同步机制，即 volatile 变量，用来确保将变量的更新操作通知到其他线程。可以将 volatile 看做一个轻量级的锁，但是又与<br>锁有些不同<ul>
<li>对于多线程，不是一种互斥关系</li>
<li>不能保证变量状态的“原子性操作”</li>
</ul>
</li>
</ul>
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(td).start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (td.isFlag()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"发生错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag="</span> + isFlag());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：flag=true</p>
<p>与预期不符：——————    没有打印出来</p>
<h3 id="内存可见性问题："><a href="#内存可见性问题：" class="headerlink" title="内存可见性问题："></a>内存可见性问题：</h3><ul>
<li>当多个线程操作共享数据时，彼此不可见</li>
</ul>
<p>main线程中，while (true)，很快， 可以读了flag=false，随后，线程1才把flag改为true，内存可见性问题</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/7.png" alt="7"></p>
<h3 id="改1：同步锁"><a href="#改1：同步锁" class="headerlink" title="改1：同步锁"></a>改1：同步锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(td).start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(td)&#123;</span><br><span class="line">                <span class="keyword">if</span> (td.isFlag()) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，效率低，如果多个线程的话，会产生效率问题，但是不加锁，会出现内存可见性问题</p>
<h3 id="改2：volatile"><a href="#改2：volatile" class="headerlink" title="改2：volatile"></a>改2：volatile</h3><p>volatile 关键字：</p>
<ul>
<li>当多个线程进行操作共享数据时，可以保证内存中的数据可见。</li>
<li>相较于 synchronized 是一种较为轻量级的同步策略。</li>
</ul>
<ul>
<li>注意：<ul>
<li>volatile 不具备“互斥性”（synchronized 互斥锁，一个线程访问，另一个线程访问不了）</li>
<li>volatile 不能保证变量的“原子性”（原子：不可分割）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestVolatile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(td).start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (td.isFlag()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="keyword">true</span>;</span><br><span class="line">        System.out.println(<span class="string">"flag="</span> + isFlag());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个线程操作直接在主存中操作，效率要比锁的高</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/8.png" alt="8"></p>
<p>volatile的性能低，在于jvm的底层优化，重排序。使用volatile后，不能重排序。</p>
<h2 id="3-原子变量-CAS算法"><a href="#3-原子变量-CAS算法" class="headerlink" title="3.原子变量-CAS算法"></a>3.原子变量-CAS算法</h2><h3 id="原子变量"><a href="#原子变量" class="headerlink" title="原子变量"></a>原子变量</h3><ul>
<li>Java类的小工具包，支持在单个变量上解除锁的线程安全编程。事实上，此包中的类可将 volatile 值、字段和数组元素的概念扩展到那些也提供原子条件更新操作的类。</li>
<li>有类 AtomicBoolean、AtomicInteger、AtomicLong 和 AtomicReference 的实例各自提供对相应类型单个变量的访问和更新。每个类也为该类型提供适当的实用工具方法。</li>
<li>AtomicIntegerArray、AtomicLongArray 和 AtomicReferenceArray 类进一步扩展了原子操作，对这些类型的数组提供了支持。这些类在为其数组元素提供 volatile 访问语义方面也引人注目，这对于普通数组来说是不受支持的。</li>
<li>核心方法：boolean compareAndSet(expectedValue, updateValue)</li>
<li>java.util.concurrent.atomic 包下提供了一些原子操作的常用类:<ul>
<li>AtomicBoolean 、AtomicInteger 、AtomicLong 、 AtomicReference</li>
<li>AtomicIntegerArray 、AtomicLongArray</li>
<li>AtomicMarkableReference</li>
<li>AtomicReferenceArray</li>
<li>AtomicStampedReference</li>
</ul>
</li>
</ul>
<p><strong>例子：i++ 的原子性问题：i++ 的操作实际上分为三个步骤“读-改-写”</strong></p>
<ul>
<li>int i = 10;</li>
<li>i = i++;   </li>
<li>i++底层操作：<ul>
<li>int temp = i;</li>
<li>i = i + 1;</li>
<li>i = temp;</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();	</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(getSerialNumber());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> serialNumber++；</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="产生重复数据，多线程问题（原子性问题）"><a href="#产生重复数据，多线程问题（原子性问题）" class="headerlink" title="产生重复数据，多线程问题（原子性问题）"></a>产生重复数据，多线程问题（原子性问题）</h3><p>线程1获取数据，改数据，但这时候线程2获取了数据，改了数据，当线程1改写数据，线程2又改写数据，发生错误</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/9.png" alt="9"></p>
<h3 id="用volatile去改"><a href="#用volatile去改" class="headerlink" title="用volatile去改"></a>用volatile去改</h3><p>在内存中解决，虽然保证内存可见性，但是因为没有互斥性，不能保证原子性问题</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/10.png" alt="10"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> serialNumber = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="解决方法：原子变量"><a href="#解决方法：原子变量" class="headerlink" title="解决方法：原子变量"></a>解决方法：原子变量</h3><p><strong>在 java.util.concurrent.atomic 包下提供了一些原子变量</strong></p>
<pre><code>1. volatile 保证内存可见性，里面包装封装的值都有volatile 
2. CAS（Compare-And-Swap） 算法保证数据变量的原子性
        1. CAS 算法是硬件对于并发操作的支持
        2. CAS 包含了三个操作数：
                1. 内存值  V
                2. 预估值  A
                3. 更新值  B
                4. 当且仅当 V == A 时，赋值： V = B；否则，不会执行任何操作。</code></pre><p>CAS算法，如果当多个线程并发了，对主存中数据进行修改时，有且只有一个线程能成功，其他线程失败时，下一次不会阻塞，不会CPU争权，立即尝试</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/11.png" alt="11"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAtomicDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		AtomicDemo ad = <span class="keyword">new</span> AtomicDemo();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ad).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AtomicDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AtomicInteger serialNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">200</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(getSerialNumber());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSerialNumber</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//i++，获取并自增</span></span><br><span class="line">		<span class="keyword">return</span> serialNumber.getAndIncrement();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模拟CAS算法"><a href="#模拟CAS算法" class="headerlink" title="模拟CAS算法"></a>模拟CAS算法</h3><ul>
<li>CAS (Compare-And-Swap) 是一种硬件对并发的支持，针对多处理器操作而设计的处理器中的一种特殊指令，用于管理对共享数据的并发访问。</li>
<li>CAS 是一种无锁的非阻塞算法的实现。</li>
<li>CAS 包含了 3 个操作数：<ul>
<li>需要读写的内存值 V</li>
<li>进行比较的值 A</li>
<li>拟写入的新值 B</li>
</ul>
</li>
<li>当且仅当 V 的值等于 A 时，CAS 通过原子方式用新值 B 来更新 V 的值，否则不会执行任何操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 模拟 CAS 算法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCompareAndSwap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> CompareAndSwap cas = <span class="keyword">new</span> CompareAndSwap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> expectedValue = cas.get();</span><br><span class="line">                    <span class="keyword">boolean</span> b = cas.compareAndSet(expectedValue, (<span class="keyword">int</span>)(Math.random() * <span class="number">101</span>));</span><br><span class="line">                    System.out.println(b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CompareAndSwap</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="comment">//获取内存值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较（预估值，新值）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">compareAndSwap</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> oldValue = value;</span><br><span class="line">        <span class="keyword">if</span>(oldValue == expectedValue)&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = newValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expectedValue, <span class="keyword">int</span> newValue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expectedValue == compareAndSwap(expectedValue, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-ConcurrentHashMap-锁分段机制"><a href="#4-ConcurrentHashMap-锁分段机制" class="headerlink" title="4.ConcurrentHashMap 锁分段机制"></a>4.ConcurrentHashMap 锁分段机制</h2><ul>
<li>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器<br>的性能。</li>
<li>ConcurrentHashMap 同步容器类是Java 5 增加的一个线程安全的哈希表。对与多线程的操作，介于 HashMap 与 Hashtable 之间。内部采用“锁分段”机制替代 Hashtable 的独占锁。进而提高性能。</li>
<li>此包还提供了设计用于多线程上下文中的 Collection 实现：<ul>
<li>ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、CopyOnWriteArrayList 和 CopyOnWriteArraySet。</li>
<li>当期望许多线程访问一个给定 collection 时，ConcurrentHashMap 通常优于同步的 HashMap，ConcurrentSkipListMap 通常优于同步的 TreeMap。当期望的读数和遍历远远大于列表的更新数时，CopyOnWriteArrayList 优于同步的 ArrayList。</li>
</ul>
</li>
</ul>
<p>HashMap是线程不安全的，HashTable是线程安全的，HashTable有锁，并行转换为串行，效率低</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/12.png" alt="12"></p>
<p>ConcurrentHashMap，采用锁分段机制，concurrentLeve，l默认有16个段，长度16，每个段是独立的锁，当多个线程并发访问时，并行，支持多个线程同时访问，效率高，也提供复合操作</p>
<p>JDK1.8，升级，Segment取消了，采用CAS算法</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/13.png" alt="13"></p>
<p>例子：</p>
<p>CopyOnWriteArrayList/CopyOnWriteArraySet : “写入并复制”</p>
<p>注意：</p>
<ul>
<li>添加操作多时，效率低，因为每次添加时都会进行复制，开销非常的大。并发迭代操作多时可以选择。</li>
<li>适合迭代，又有并发问题，适合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCopyOnWriteArrayList</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		HelloThread ht = <span class="keyword">new</span> HelloThread();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ht).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//线程安全的集合</span></span><br><span class="line">	<span class="comment">//并发修改异常</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; list2 = Collections.synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">	<span class="comment">//改法，CopyOnWriteArrayList当每次写入时，都会在底层完成复制，复制一个新的链表，再继续添加</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		list.add(<span class="string">"AA"</span>);</span><br><span class="line">		list.add(<span class="string">"BB"</span>);</span><br><span class="line">		list.add(<span class="string">"CC"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line">		<span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">			System.out.println(it.next());</span><br><span class="line">			list.add(<span class="string">"AA"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Collections.synchronizedList，在线程-1中最后可以看</p>
<h2 id="5-CountDownLatch-闭锁"><a href="#5-CountDownLatch-闭锁" class="headerlink" title="5.CountDownLatch 闭锁"></a>5.CountDownLatch 闭锁</h2><ul>
<li>Java 5.0 在 java.util.concurrent 包中提供了多种并发容器类来改进同步容器<br>的性能。</li>
<li>CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。</li>
<li>闭锁可以延迟线程的进度直到其到达终止状态，闭锁可以用来确保某些活动直到其他活动都完成才继续执行：<ul>
<li>确保某个计算在其需要的所有资源都被初始化之后才继续执行;</li>
<li>确保某个服务在其依赖的所有其他服务都已经启动之后才启动;</li>
<li>等待直到某个操作所有参与者都准备就绪再继续执行。</li>
</ul>
</li>
</ul>
<p>CountDownLatch ：闭锁，在完成某些运算是，只有其他所有线程的运算全部完成，当前运算才继续执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCountDownLatch</span> </span>&#123;</span><br><span class="line">	<span class="comment">//10个线程，主线程，没有办法计算出时间，主线程等待10个分线程执行完在计算</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//10，CountDownLatch(10)，线程执行完后会-1</span></span><br><span class="line">		<span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">		LatchDemo ld = <span class="keyword">new</span> LatchDemo(latch);</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(ld).start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//不为0时，等待</span></span><br><span class="line">			latch.await();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"耗费时间为："</span> + (end - start));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatchDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">LatchDemo</span><span class="params">(CountDownLatch latch)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.latch = latch;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">					System.out.println(i);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//CountDownLatch，-1操作</span></span><br><span class="line">			latch.countDown();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-实现-Callable-接口"><a href="#6-实现-Callable-接口" class="headerlink" title="6.实现 Callable 接口"></a>6.实现 Callable 接口</h2><ul>
<li>Java 5.0 在 java.util.concurrent 提供了一个新的创建执行线程的方式：Callable 接口</li>
<li>Callable 接口类似于 Runnable，两者都是为那些其实例可能被另一个线程执行的类设计的。但是 Runnable 不会返回结果，并且无法抛出经过检查的异常。</li>
<li>Callable 需要依赖FutureTask ，FutureTask 也可以用作闭锁。</li>
</ul>
<p><strong>例子：</strong></p>
<p>创建执行线程的方式三：实现 Callable 接口。 </p>
<ul>
<li>相较于实现 Runnable 接口的方式，方法可以有返回值，并且可以抛出异常。</li>
<li>执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。  FutureTask 是  Future 接口的实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCallable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">		<span class="comment">//1.执行 Callable 方式，需要 FutureTask 实现类的支持，用于接收运算结果。</span></span><br><span class="line">		FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line">		<span class="keyword">new</span> Thread(result).start();</span><br><span class="line">		<span class="comment">//2.接收线程运算后的结果</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Integer sum = result.get();  <span class="comment">//FutureTask 可用于 闭锁</span></span><br><span class="line">			System.out.println(sum);</span><br><span class="line">			System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException | ExecutionException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100000</span>; i++) &#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class ThreadDemo implements Runnable&#123;</span></span><br><span class="line"><span class="comment">	@Override</span></span><br><span class="line"><span class="comment">	public void run() &#123;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="../images/%E7%BA%BF%E7%A8%8B/14.png" alt="14"></p>
<h2 id="7-Lock-同步锁"><a href="#7-Lock-同步锁" class="headerlink" title="7.Lock 同步锁"></a>7.Lock 同步锁</h2><ul>
<li>在 Java 5.0 之前，协调共享对象的访问时可以使用的机制只有 synchronized 和 volatile 。Java 5.0 后增加了一些新的机制，但并不是一种替代内置锁的方法，而是当内置锁不适用时，作为一种可选择的高级功能。</li>
<li>ReentrantLock 实现了 Lock 接口，并提供了与synchronized 相同的互斥性和内存可见性。但相较于synchronized 提供了更高的处理锁的灵活性。</li>
</ul>
<h3 id="用于解决多线程安全问题的方式："><a href="#用于解决多线程安全问题的方式：" class="headerlink" title="用于解决多线程安全问题的方式："></a>用于解决多线程安全问题的方式：</h3><ul>
<li><p>synchronized:隐式锁</p>
<ul>
<li>同步代码块</li>
<li>同步方法</li>
</ul>
<p>jdk 1.5 后：</p>
</li>
<li><p>同步锁 Lock</p>
</li>
<li><p>注意</p>
<ul>
<li>是一个显示锁，需要通过 lock() 方法上锁，必须通过 unlock() 方法进行释放锁</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestLock</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Ticket ticket = <span class="keyword">new</span> Ticket();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket, <span class="string">"1号窗口"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket, <span class="string">"2号窗口"</span>).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(ticket, <span class="string">"3号窗口"</span>).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tick = <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			lock.lock(); <span class="comment">//上锁</span></span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(tick &gt; <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">200</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">" 完成售票，余票为："</span> + --tick);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				lock.unlock(); <span class="comment">//释放锁</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生产者和消费者案例-虚假唤醒"><a href="#生产者和消费者案例-虚假唤醒" class="headerlink" title="生产者和消费者案例-虚假唤醒"></a>生产者和消费者案例-虚假唤醒</h3><p>因为有共享数据，所以使用同步代码，synchronized</p>
<p>因为当生产者进货后，消费者要消费，所以两个循环，要等待唤醒机制。</p>
<p><strong>出现问题：</strong></p>
<h4 id="1-当出现延迟，product-gt-1来回交替，程序没有停止"><a href="#1-当出现延迟，product-gt-1来回交替，程序没有停止" class="headerlink" title="1.当出现延迟，product &gt;= 1来回交替，程序没有停止"></a>1.当出现延迟，product &gt;= 1来回交替，程序没有停止</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.sleep(<span class="number">200</span>);</span><br><span class="line">product &gt;= <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span>(product &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">"产品已满！"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + ++product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者：product = 0; 循环次数：1–&gt;0，wait（）–&gt;停止了</p>
<p>生产者：product = 0–&gt;1; 循环次数：2–&gt;1，notifyAll（）–&gt;唤醒消费者</p>
<p>消费者：product = 1; 循环次数：0，从wait（）往下走，所以消费者结束了</p>
<p>生产者：product = 1; 循环次数：1–&gt;0，wait（）–&gt;停止了，但是没人唤醒，程序没结束</p>
<p>所以，去掉else</p>
<h4 id="2-wait（）方法可能会出现虚假唤醒问题"><a href="#2-wait（）方法可能会出现虚假唤醒问题" class="headerlink" title="2.wait（）方法可能会出现虚假唤醒问题"></a>2.wait（）方法可能会出现虚假唤醒问题</h4><p>虚假唤醒问题，文档中建议应该总是使用在循环中</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/15.png" alt="15"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProductorAndConsumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Productor pro = <span class="keyword">new</span> Productor(clerk);</span><br><span class="line">        Consumer cus = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        <span class="keyword">new</span> Thread(pro, <span class="string">"生产者 A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(cus, <span class="string">"消费者 B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(pro, <span class="string">"生产者 C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(cus, <span class="string">"消费者 D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//店员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//进货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;<span class="comment">//循环次数：0</span></span><br><span class="line">        <span class="keyword">while</span>(product &gt;= <span class="number">1</span>)&#123;<span class="comment">//为了避免虚假唤醒问题，应该总是使用在循环中</span></span><br><span class="line">            System.out.println(<span class="string">"产品已满！"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + ++product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//卖货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>&#123;<span class="comment">//product = 0; 循环次数：0</span></span><br><span class="line">        <span class="keyword">while</span>(product &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"缺货！"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + --product);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Condition-控制线程通信"><a href="#8-Condition-控制线程通信" class="headerlink" title="8.Condition 控制线程通信"></a>8.Condition 控制线程通信</h2><ul>
<li>Condition 接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用 Object.wait 访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，单个 Lock 可能与多个 Condition 对象关联。为了避免兼容性问题，Condition 方法的名称与对应的 Object 版本中的不同。</li>
<li>在 Condition 对象中，与 wait、notify 和 notifyAll 方法对应的分别是await、signal 和 signalAll。</li>
<li>Condition 实例实质上被绑定到一个锁上。要为特定 Lock 实例获得Condition 实例，请使用其 newCondition() 方法。</li>
</ul>
<h3 id="生产者和消费者案例-Lock改良"><a href="#生产者和消费者案例-Lock改良" class="headerlink" title="生产者和消费者案例-Lock改良"></a>生产者和消费者案例-Lock改良</h3><ul>
<li>this.wait()——&gt;condition.await();</li>
<li>this.notifyAll()——&gt; condition.signalAll();</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestProductorAndConsumerForLock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Productor pro = <span class="keyword">new</span> Productor(clerk);</span><br><span class="line">        Consumer con = <span class="keyword">new</span> Consumer(clerk);</span><br><span class="line">        <span class="keyword">new</span> Thread(pro, <span class="string">"生产者 A"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(con, <span class="string">"消费者 B"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(pro, <span class="string">"生产者 C"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(con, <span class="string">"消费者 D"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> product = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">//调用控制线程通信，等待唤醒机制</span></span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line">    <span class="comment">// 进货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (product &gt;= <span class="number">1</span>) &#123; <span class="comment">// 为了避免虚假唤醒，应该总是使用在循环中。</span></span><br><span class="line">                System.out.println(<span class="string">"产品已满！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span></span><br><span class="line">                               + ++product);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 卖货</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"缺货！"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    condition.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span></span><br><span class="line">                               + --product);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Productor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Productor</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.get();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            clerk.sale();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-线程按序交替"><a href="#9-线程按序交替" class="headerlink" title="9.线程按序交替"></a>9.线程按序交替</h2><p>编写一个程序，开启 3 个线程，这三个线程的 ID 分别为A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出的结果必须按顺序显示。</p>
<p>如：ABCABCABC…… 依次递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestABCAlternate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AlternateDemo ad = <span class="keyword">new</span> AlternateDemo();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ad.loopA(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"A"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ad.loopB(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"B"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">                    ad.loopC(i);</span><br><span class="line">                    System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"C"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlternateDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当前正在执行线程的标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition1 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition2 = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition condition3 = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> totalLoop : 循环第几轮</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopA</span><span class="params">(<span class="keyword">int</span> totalLoop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 判断</span></span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3. 唤醒</span></span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopB</span><span class="params">(<span class="keyword">int</span> totalLoop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 判断</span></span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3. 唤醒</span></span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loopC</span><span class="params">(<span class="keyword">int</span> totalLoop)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1. 判断</span></span><br><span class="line">            <span class="keyword">if</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 打印</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"\t"</span> + i + <span class="string">"\t"</span> + totalLoop);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//3. 唤醒</span></span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>A    1    1<br>B    1    1</p>
<p>C    1    1</p>
<hr>
<p>A    1    2<br>B    1    2<br>C    1    2</p>
<h2 id="10ReadWriteLock-读写锁"><a href="#10ReadWriteLock-读写锁" class="headerlink" title="10ReadWriteLock 读写锁"></a>10ReadWriteLock 读写锁</h2><ul>
<li>ReadWriteLock 维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。。</li>
<li>ReadWriteLock 读取操作通常不会改变共享资源，但执行写入操作时，必须独占方式来获取锁。对于读取操作占多数的数据结构。 ReadWriteLock 能提供比独占锁更高的并发性。而对于只读的数据结构，其中包含的不变性可以完全不需要考虑加锁操作。</li>
</ul>
<p>ReadWriteLock : 读写锁</p>
<ul>
<li>写写/读写：需要“互斥”</li>
<li>读读：不需要互斥</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestReadWriteLock</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ReadWriteLockDemo rw = <span class="keyword">new</span> ReadWriteLockDemo();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				rw.set((<span class="keyword">int</span>)(Math.random() * <span class="number">101</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, <span class="string">"Write:"</span>).start();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					rw.get();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">private</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">	<span class="comment">//读</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//上锁</span></span><br><span class="line">		lock.readLock().lock(); </span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + number);</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">			lock.readLock().unlock(); </span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		lock.writeLock().lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName());</span><br><span class="line">			<span class="keyword">this</span>.number = number;</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.writeLock().unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-线程八锁"><a href="#11-线程八锁" class="headerlink" title="11.线程八锁"></a>11.线程八锁</h2><ul>
<li>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的一个synchronized方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized方法</li>
<li>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的<br>synchronized方法</li>
<li>加个普通方法后发现和同步锁无关</li>
<li>换成两个对象后，不是同一把锁了，情况立刻变化。</li>
<li>都换成静态同步方法后，情况又变化</li>
<li>所有的非静态同步方法用的都是同一把锁  ——  实例对象本身，也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。</li>
<li>所有的静态同步方法用的也是同一把锁  ——  类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！</li>
</ul>
<h3 id="题目：判断打印的-“one”-or-“two”-？"><a href="#题目：判断打印的-“one”-or-“two”-？" class="headerlink" title="题目：判断打印的 “one” or “two” ？"></a>题目：判断打印的 “one” or “two” ？</h3><ol>
<li><h4 id="两个普通同步方法，两个线程，标准打印，-打印-one-two"><a href="#两个普通同步方法，两个线程，标准打印，-打印-one-two" class="headerlink" title="两个普通同步方法，两个线程，标准打印， 打印? //one  two"></a>两个普通同步方法，两个线程，标准打印， 打印? //one  two</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><h4 id="新增-Thread-sleep-给-getOne-打印-one-two"><a href="#新增-Thread-sleep-给-getOne-打印-one-two" class="headerlink" title="新增 Thread.sleep() 给 getOne() ,打印? //one  two"></a>新增 Thread.sleep() 给 getOne() ,打印? //one  two</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><h4 id="新增普通方法-getThree-打印-three-one-two"><a href="#新增普通方法-getThree-打印-three-one-two" class="headerlink" title="新增普通方法 getThree() , 打印? //three  one   two"></a>新增普通方法 getThree() , 打印? //three  one   two</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getThree();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getThree</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"three"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="4">
<li><h4 id="两个普通同步方法，两个-Number-对象，打印-two-one"><a href="#两个普通同步方法，两个-Number-对象，打印-two-one" class="headerlink" title="两个普通同步方法，两个 Number 对象，打印?  //two  one"></a>两个普通同步方法，两个 Number 对象，打印?  //two  one</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		Number number2 = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//number.getTwo();</span></span><br><span class="line">				number2.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="5">
<li><h4 id="修改-getOne-为静态同步方法，打印-two-one"><a href="#修改-getOne-为静态同步方法，打印-two-one" class="headerlink" title="修改 getOne() 为静态同步方法，打印?  //two   one"></a>修改 getOne() 为静态同步方法，打印?  //two   one</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><h4 id="修改两个方法均为静态同步方法，一个-Number-对象-one-two"><a href="#修改两个方法均为静态同步方法，一个-Number-对象-one-two" class="headerlink" title="修改两个方法均为静态同步方法，一个 Number 对象?  //one   two"></a>修改两个方法均为静态同步方法，一个 Number 对象?  //one   two</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="7">
<li><h4 id="一个静态同步方法，一个非静态同步方法，两个-Number-对象-two-one"><a href="#一个静态同步方法，一个非静态同步方法，两个-Number-对象-two-one" class="headerlink" title="一个静态同步方法，一个非静态同步方法，两个 Number 对象?  //two  one"></a>一个静态同步方法，一个非静态同步方法，两个 Number 对象?  //two  one</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		Number number2 = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number2.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ol start="8">
<li><h4 id="两个静态同步方法，两个-Number-对象-one-two"><a href="#两个静态同步方法，两个-Number-对象-one-two" class="headerlink" title="两个静态同步方法，两个 Number 对象?   //one  two"></a>两个静态同步方法，两个 Number 对象?   //one  two</h4></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThread8Monitor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Number number = <span class="keyword">new</span> Number();</span><br><span class="line">		Number number2 = <span class="keyword">new</span> Number();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable () &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number.getOne();</span><br><span class="line">			&#125; </span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				number2.getTwo();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"one"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">getTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"two"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程八锁的关键："><a href="#线程八锁的关键：" class="headerlink" title="线程八锁的关键："></a>线程八锁的关键：</h3><ul>
<li>非静态方法的锁默认为  this</li>
<li>静态方法的锁为 对应的 Class 实例</li>
<li>某一个时刻内，只能有一个线程持有锁，无论几个方法。</li>
</ul>
<h2 id="12-线程池"><a href="#12-线程池" class="headerlink" title="12.线程池"></a>12.线程池</h2><ul>
<li>第四种获取线程的方法：线程池，一个 ExecutorService，它使用可能的几个池线程之一执行每个提交的任务，通常使用 Executors 工厂方法配置。</li>
<li>线程池可以解决两个不同问题：由于减少了每个任务调用的开销，它们通常可以在执行大量异步任务时提供增强的性能，并且还可以提供绑定和管理资源（包括执行任务集时使用的线程）的方法。每个 ThreadPoolExecutor 还维护着一些基本的统计数据，如完成的任务数。</li>
<li>为了便于跨大量上下文使用，此类提供了很多可调整的参数和扩展钩子 (hook)。但<br>是，强烈建议程序员使用较为方便的 Executors 工厂方法 ：<ul>
<li>Executors.newCachedThreadPool()（无界线程池，可以进行自动线程回收）</li>
<li>Executors.newFixedThreadPool(int)（固定大小线程池）</li>
<li>Executors.newSingleThreadExecutor()（单个后台线程）</li>
</ul>
</li>
<li>它们均为大多数使用场景预定义了设置。</li>
</ul>
<p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建与销毁额外开销，提高了响应的速度。</p>
<h3 id="线程池的体系结构："><a href="#线程池的体系结构：" class="headerlink" title="线程池的体系结构："></a>线程池的体系结构：</h3><ul>
<li><p>java.util.concurrent.Executor : 负责线程的使用与调度的根接口</p>
<ul>
<li><p>|–**ExecutorService 子接口: 线程池的主要接口</p>
<ul>
<li><p>|–ThreadPoolExecutor 线程池的实现类</p>
</li>
<li><p>|–ScheduledExecutorService 子接口：负责线程的调度</p>
<ul>
<li>|–ScheduledThreadPoolExecutor ：继承 ThreadPoolExecutor， 实现 ScheduledExecutorService</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>工具类 : Executors</p>
<ul>
<li>ExecutorService newFixedThreadPool() : 创建固定大小的线程池</li>
<li>ExecutorService newCachedThreadPool() : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量。</li>
<li>ExecutorService newSingleThreadExecutor() : 创建单个线程池。线程池中只有一个线程</li>
<li>ScheduledExecutorService newScheduledThreadPool() : 创建固定大小的线程，可以延迟或定时的执行任务。</li>
</ul>
</li>
</ul>
<h3 id="1-Runnable"><a href="#1-Runnable" class="headerlink" title="1.Runnable"></a>1.Runnable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">		ThreadPoolDemo tpd = <span class="keyword">new</span> ThreadPoolDemo();	</span><br><span class="line">		<span class="comment">//2. 为线程池中的线程分配任务</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			pool.submit(tpd);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//3. 关闭线程池</span></span><br><span class="line">		<span class="comment">//shutdown,平和方式关闭，等待线程结束再关闭</span></span><br><span class="line">		pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolDemo</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + i++);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-Callable"><a href="#2-Callable" class="headerlink" title="2.Callable"></a>2.Callable</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1. 创建线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        List&lt;Future&lt;Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Future&lt;Integer&gt; future = pool.submit(<span class="keyword">new</span> &lt;Integer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">                        sum += i;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            list.add(future);</span><br><span class="line">        &#125;</span><br><span class="line">        pool.shutdown();</span><br><span class="line">        <span class="keyword">for</span> (Future&lt;Integer&gt; future : list) &#123;</span><br><span class="line">            System.out.println(future.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="13-线程调度"><a href="#13-线程调度" class="headerlink" title="13.线程调度"></a>13.线程调度</h2><p>ScheduledExecutorService</p>
<p>一个 ExecutorService，可安排在给定的延迟后运行或定期执行的命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestScheduledThreadPool</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">      <span class="comment">//任务，数值，单位（天，秒，小时...）</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">         Future&lt;Integer&gt; result = pool.schedule(<span class="keyword">new</span> Callable&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">int</span> num = <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);<span class="comment">//生成随机数</span></span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">" : "</span> + num);</span><br><span class="line">               <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">         System.out.println(result.get());</span><br><span class="line">      &#125;</span><br><span class="line">      pool.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-ForkJoinPool-分支-合并框架-工作窃取"><a href="#14-ForkJoinPool-分支-合并框架-工作窃取" class="headerlink" title="14.ForkJoinPool 分支/合并框架 工作窃取"></a>14.ForkJoinPool 分支/合并框架 工作窃取</h2><p>Fork/Join 框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总。</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/16.png" alt="16"></p>
<p>Fork/Join 框架与线程池的区别</p>
<ul>
<li>采用 “工作窃取”模式（work-stealing）：当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</li>
<li>相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上.在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。</li>
<li>而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行.这种方式减少了线程的等待时间，提高了性能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoinPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * ForkJoin框架</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line">        ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinSumCalculate(<span class="number">0L</span>, <span class="number">50000000000L</span>);</span><br><span class="line">        Long sum = pool.invoke(task);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//166-1996-10590</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 普通for</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt;= <span class="number">50000000000L</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//35-3142-15704</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     *     java8 新特性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line">        Long sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">50000000000L</span>)</span><br><span class="line">            .parallel()</span><br><span class="line">            .reduce(<span class="number">0L</span>, Long::sum);</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        Instant end = Instant.now();</span><br><span class="line">        System.out.println(<span class="string">"耗费时间为："</span> + Duration.between(start, end).toMillis());<span class="comment">//1536-8118</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Recursive，递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ForkJoinSumCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">259195479995561737L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">    <span class="comment">//临界值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THURSHOLD = <span class="number">10000L</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForkJoinSumCalculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> length = end - start;</span><br><span class="line">        <span class="comment">//临界值不拆</span></span><br><span class="line">        <span class="keyword">if</span> (length &lt;= THURSHOLD) &#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">            ForkJoinSumCalculate left = <span class="keyword">new</span> ForkJoinSumCalculate(start, middle);</span><br><span class="line">            <span class="comment">//进行拆分，同时压入线程队列</span></span><br><span class="line">            left.fork();</span><br><span class="line">            ForkJoinSumCalculate right = <span class="keyword">new</span> ForkJoinSumCalculate(middle + <span class="number">1</span>, end);</span><br><span class="line">            right.fork();</span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JUC</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/post/364ea8cc.html</url>
    <content><![CDATA[<p>设计模式一部分</p>
<a id="more"></a>

<h2 id="1-面向对象思想设计原则"><a href="#1-面向对象思想设计原则" class="headerlink" title="1.面向对象思想设计原则"></a>1.面向对象思想设计原则</h2><h3 id="1-1-单一职责原则"><a href="#1-1-单一职责原则" class="headerlink" title="1-1.单一职责原则"></a>1-1.单一职责原则</h3><ul>
<li>其实就是开发人员经常说的”高内聚，低耦合“</li>
<li>也就是说，每个类应该只有一个职责，对外只能提供一种功能，而引起类变化的原因应该只有一个。在设计模式中，所有的设计模式都遵循这一原则</li>
</ul>
<h3 id="1-2-开闭原则"><a href="#1-2-开闭原则" class="headerlink" title="1-2.开闭原则"></a>1-2.开闭原则</h3><ul>
<li>核心思想是：一个对象对扩展开放，对修改关闭。</li>
<li>其实开闭原则的意思就是：对类的改动是通过增加代码进行的，而不是修改现有代码。</li>
<li>也就是说软件开发人员一旦写出了可以运行的代码，就不应该去改动它，而是要保证它能一直运行下去，如何能够做到这一点呢?这就需要借助于抽象和多态，即把可能变化的内容抽象出来，从而使抽象的部分是相对稳定的，而具体的实现则是可以改变和扩展的。</li>
</ul>
<h3 id="1-3-里氏替换原则"><a href="#1-3-里氏替换原则" class="headerlink" title="1-3.里氏替换原则"></a>1-3.里氏替换原则</h3><ul>
<li>核心思想：在任何父类出现的地方都可以用它的子类来替代。</li>
<li>其实就是说：同一个继承体系中的对象应该有共同的行为特征。</li>
</ul>
<h3 id="1-4-依赖注入原则"><a href="#1-4-依赖注入原则" class="headerlink" title="1-4.依赖注入原则"></a>1-4.依赖注入原则</h3><ul>
<li>核心思想：要依赖于抽象，不要依赖于具体实现。</li>
<li>其实就是说：在应用程序中，所有的类如果使用或依赖于其他的类，则应该依赖这些其他类的抽象类，而不是这些其他类的具体类。为了实现这一原则，就要求我们在编程的时候针对抽象类或者接口编程，而不是针对具体实现编程。</li>
</ul>
<h3 id="1-5-接口分离原则"><a href="#1-5-接口分离原则" class="headerlink" title="1-5.接口分离原则"></a>1-5.接口分离原则</h3><ul>
<li>核心思想：不应该强迫程序依赖它们不需要使用的方法。</li>
<li>其实就是说：一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口中。</li>
</ul>
<h3 id="1-6-迪米特原则"><a href="#1-6-迪米特原则" class="headerlink" title="1-6.迪米特原则"></a>1-6.迪米特原则</h3><ul>
<li>核心思想：一个对象应当对其他对象尽可能少的了解</li>
<li>其实就是说：降低各个对象之间的耦合，提高系统的可维护性。在模块之间应该只通过接口编程，而不理会模块的内部工作原理，它可以使各个模块耦合度降到最低，促进软件的复用</li>
</ul>
<h2 id="2-设计模式"><a href="#2-设计模式" class="headerlink" title="2.设计模式"></a>2.设计模式</h2><p>​    设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。</p>
<p>​    设计模式不是一种方法和技术，而是一种思想</p>
<p>​    设计模式和具体的语言无关，学习设计模式就是要建立面向对象的思想，尽可能的面向接口编程，低耦合，高内聚，是设计的程序可复用</p>
<p>​    学习设计模式能够促进对面向对象思想的理解，反之亦然。它们相辅相成</p>
<p><strong>设计模式的几个要素：</strong></p>
<ul>
<li>名字：必须有一个简单，有意义的名字</li>
<li>问题：描述在何时使用模式</li>
<li>解决方案：描述设计的组成部分以及如何解决问题</li>
<li>效果：描述模式的效果以及优缺点</li>
</ul>
<p><strong>设计模式的分类：</strong></p>
<ul>
<li><p>创建型模式：对象的创建</p>
</li>
<li><p>结构型模式：对象的组成(结构)</p>
</li>
<li><p>行为型模式：对象的行为</p>
</li>
<li><p>创建型模式</p>
<ul>
<li>简单工厂模式，工厂方法模式，抽象工厂模式，建造者模式，原型模式，单例模式。(6个)</li>
</ul>
</li>
<li><p>结构型模式</p>
<ul>
<li>外观模式、适配器模式、代理模式、装饰模式、桥接模式、组合模式、享元模式。(7个)</li>
</ul>
</li>
<li><p>行为型模式</p>
<ul>
<li>模版方法模式、观察者模式、状态模式、职责链模式、命令模式、访问者模式、策略模式、备忘录模式、迭代器模式、解释器模式。(10个)</li>
</ul>
</li>
</ul>
<h2 id="3-简单工厂模式"><a href="#3-简单工厂模式" class="headerlink" title="3.简单工厂模式"></a>3.简单工厂模式</h2><p><strong>工厂方法模式概述：</strong></p>
<ul>
<li>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要额外的编写代码，增加了工作量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//猫工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//狗工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"狗吃肉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化，动物工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AnimalFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dog <span class="title">createDog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Cat <span class="title">createCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//优化，动物</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Animal <span class="title">createAnimal</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"dog"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"cat"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体类调用</span></span><br><span class="line">        Dog d = <span class="keyword">new</span> Dog();</span><br><span class="line">        d.eat();</span><br><span class="line">        Cat c = <span class="keyword">new</span> Cat();</span><br><span class="line">        c.eat();</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        <span class="comment">// 工厂有了后，通过工厂给造</span></span><br><span class="line">        Dog dd = AnimalFactory.createDog();</span><br><span class="line">        Cat cc = AnimalFactory.createCat();</span><br><span class="line">        dd.eat();</span><br><span class="line">        cc.eat();</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line">        <span class="comment">// 工厂改进后</span></span><br><span class="line">        Animal a = AnimalFactory.createAnimal(<span class="string">"dog"</span>);</span><br><span class="line">        a.eat();</span><br><span class="line">        a = AnimalFactory.createAnimal(<span class="string">"cat"</span>);</span><br><span class="line">        a.eat();</span><br><span class="line">        <span class="comment">// NullPointerException</span></span><br><span class="line">        a = AnimalFactory.createAnimal(<span class="string">"pig"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            a.eat();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"对不起，暂时不提供这种动物"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-工厂方法"><a href="#4-工厂方法" class="headerlink" title="4.工厂方法"></a>4.工厂方法</h2><p><strong>工厂方法模式概述：</strong></p>
<ul>
<li>工厂方法模式中抽象工厂类负责定义创建对象的接口，具体对象的创建工作由继承抽象工厂的具体类实现。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>客户端不需要在负责对象的创建，从而明确了各个类的职责，如果有新的对象增加，只需要增加一个具体的类和具体的工厂类即可，不影响已有的代码，后期维护容易，增强了系统的扩展性</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要额外的编写代码，增加了工作量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动物</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Animal <span class="title">createAnimal</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//狗</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"狗吃肉"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//狗工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DogFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"猫吃鱼"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Animal <span class="title">createAnimal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnimalDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 需求：我要买只狗</span></span><br><span class="line">        <span class="comment">// 启动工厂</span></span><br><span class="line">		Factory f = <span class="keyword">new</span> DogFactory();</span><br><span class="line">		Animal a = f.createAnimal();</span><br><span class="line">		a.eat();</span><br><span class="line">		System.out.println(<span class="string">"-------"</span>);</span><br><span class="line">		<span class="comment">//需求：我要买只猫</span></span><br><span class="line">		f = <span class="keyword">new</span> CatFactory();</span><br><span class="line">		a = f.createAnimal();</span><br><span class="line">		a.eat();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-单例模式"><a href="#5-单例模式" class="headerlink" title="5.单例模式"></a>5.单例模式</h2><p><strong>单例设计模式概述：</strong></p>
<ul>
<li>单例模式就是要确保类在内存中只有一个对象，该实例必须自动创建，并且对外提供。</li>
</ul>
<p><strong>优点：</strong></p>
<ul>
<li>在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><p>没有抽象层，因此扩展很难。</p>
</li>
<li><p>职责过重，在一定程序上违背了单一职责</p>
</li>
</ul>
<p>单例模式：保证类在内存中只有一个对象。</p>
<p><strong>如何保证类在内存中只有一个对象呢?</strong></p>
<ul>
<li>把构造方法私有</li>
<li>在成员位置自己创建一个对象</li>
<li>通过一个公共的方法提供访问</li>
</ul>
<h3 id="5-1-饿汉式：类一加载就创建对象"><a href="#5-1-饿汉式：类一加载就创建对象" class="headerlink" title="5-1.饿汉式：类一加载就创建对象"></a>5-1.饿汉式：类一加载就创建对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 构造私有</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 自己造一个</span></span><br><span class="line">	<span class="comment">// 静态方法只能访问静态成员变量，加静态</span></span><br><span class="line">	<span class="comment">// 为了不让外界直接访问修改这个值，加private</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Student s = <span class="keyword">new</span> Student();</span><br><span class="line">	<span class="comment">// 提供公共的访问方式</span></span><br><span class="line">	<span class="comment">// 为了保证外界能够直接使用该方法，加静态</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//一开始</span></span><br><span class="line">		Student s1 = <span class="keyword">new</span> Student();</span><br><span class="line">		Student s2 = <span class="keyword">new</span> Student();</span><br><span class="line">		System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通过单例如何得到对象呢?</span></span><br><span class="line">		Student s1 = Student.getStudent();</span><br><span class="line">		Student s2 = Student.getStudent();</span><br><span class="line">		System.out.println(s1 == s2);</span><br><span class="line">		<span class="comment">// 外部修改对象</span></span><br><span class="line">		<span class="comment">// Student.s = null;</span></span><br><span class="line">		System.out.println(s1); <span class="comment">// null，cn.itcast_03.Student@175078b</span></span><br><span class="line">		System.out.println(s2);<span class="comment">// null，cn.itcast_03.Student@175078b</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-懒汉式：用的时候，才去创建对象"><a href="#5-2-懒汉式：用的时候，才去创建对象" class="headerlink" title="5-2.懒汉式：用的时候，才去创建对象"></a>5-2.懒汉式：用的时候，才去创建对象</h3><p><strong>面试题：单例模式的思想是什么?请写一个代码体现。</strong></p>
<ul>
<li>开发：饿汉式(是不会出问题的单例模式)</li>
<li>面试：懒汉式(可能会出问题的单例模式)<br>懒加载(延迟加载) ，可能会线程安全问题，要加synchronized</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Teacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Teacher t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//改良，加synchronized</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Teacher <span class="title">getTeacher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// t1,t2,t3</span></span><br><span class="line">		<span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//t1,t2,t3</span></span><br><span class="line">			t = <span class="keyword">new</span> Teacher();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TeacherDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Teacher t1 = Teacher.getTeacher();</span><br><span class="line">		Teacher t2 = Teacher.getTeacher();</span><br><span class="line">		System.out.println(t1 == t2);</span><br><span class="line">		System.out.println(t1); <span class="comment">// cn.itcast_03.Teacher@175078b</span></span><br><span class="line">		System.out.println(t2);<span class="comment">// cn.itcast_03.Teacher@175078b</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-Runtime类的概述和使用"><a href="#5-3-Runtime类的概述和使用" class="headerlink" title="5-3.Runtime类的概述和使用"></a>5-3.Runtime类的概述和使用</h3><p>Runtime类概述</p>
<ul>
<li>每个 Java 应用程序都有一个 Runtime 类实例，使应用程序能够与其运行的环境相连接。可以通过 getRuntime 方法获取当前运行时。 </li>
<li>应用程序不能创建自己的 Runtime 类实例。 </li>
</ul>
<p>Runtime类使用</p>
<ul>
<li>public Process  exec(String command)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		Runtime r = Runtime.getRuntime();</span><br><span class="line">        <span class="comment">//打开扫雷</span></span><br><span class="line">        r.exec(<span class="string">"winmine"</span>);</span><br><span class="line">        <span class="comment">//打开记事本</span></span><br><span class="line">		r.exec(<span class="string">"notepad"</span>);</span><br><span class="line">        <span class="comment">//打开计算器</span></span><br><span class="line">		r.exec(<span class="string">"calc"</span>);</span><br><span class="line">        <span class="comment">//关机，10000秒后</span></span><br><span class="line">        r.exec(<span class="string">"shutdown -s -t 10000"</span>);</span><br><span class="line">        <span class="comment">//取消关机命令</span></span><br><span class="line">		r.exec(<span class="string">"shutdown -a"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//源码，提供一个静态的公共对象，饿汉式</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * class Runtime &#123;</span></span><br><span class="line"><span class="comment"> * 		private Runtime() &#123;&#125;</span></span><br><span class="line"><span class="comment"> * 		private static Runtime currentRuntime = new Runtime();</span></span><br><span class="line"><span class="comment"> * 		public static Runtime getRuntime() &#123;</span></span><br><span class="line"><span class="comment"> *       	return currentRuntime;</span></span><br><span class="line"><span class="comment"> *   	&#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线程-2</title>
    <url>/post/94189774.html</url>
    <content><![CDATA[<p>​    线程的使用，第二部分</p>
<a id="more"></a>

<h2 id="1-线程的Lock锁的使用"><a href="#1-线程的Lock锁的使用" class="headerlink" title="1.线程的Lock锁的使用"></a>1.线程的Lock锁的使用</h2><p>​    虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock</p>
<p>Lock：ReentrantLock是Lock的实现类.</p>
<ul>
<li>void lock()： 获取锁。</li>
<li>void unlock()： 释放锁。  </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义票</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// 定义锁对象</span></span><br><span class="line">	<span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 加锁</span></span><br><span class="line">				lock.lock();</span><br><span class="line">				<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 释放锁</span></span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建资源对象</span></span><br><span class="line">		SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">		<span class="comment">// 创建三个窗口</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了避免出现错误，释放不了锁，在finally里搞lock.unlock();</p>
<h2 id="2-死锁问题"><a href="#2-死锁问题" class="headerlink" title="2.死锁问题"></a>2.死锁问题</h2><p>同步的弊端：效率低、容易产生死锁</p>
<p>死锁：两个或两个以上的线程在争夺资源的过程中，发生的一种相互等待的现象。</p>
<p> 举例：<br>     中国人，美国人吃饭案例。<br>     正常情况：<br>        中国人:筷子两支<br>        美国人:刀和叉<br>     现在：<br>       中国人：筷子1支，刀一把<br>        美国人：筷子1支，叉一把</p>
<p><strong>同步代码块的嵌套案例</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLock</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 创建两把锁对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object objA = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Object objB = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DieLock</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DieLock</span><span class="params">(<span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.flag = flag;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (flag) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (MyLock.objA) &#123;</span><br><span class="line">				System.out.println(<span class="string">"if objA"</span>);</span><br><span class="line">				<span class="keyword">synchronized</span> (MyLock.objB) &#123;</span><br><span class="line">					System.out.println(<span class="string">"if objB"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (MyLock.objB) &#123;</span><br><span class="line">				System.out.println(<span class="string">"else objB"</span>);</span><br><span class="line">				<span class="keyword">synchronized</span> (MyLock.objA) &#123;</span><br><span class="line">					System.out.println(<span class="string">"else objA"</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DieLockDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		DieLock dl1 = <span class="keyword">new</span> DieLock(<span class="keyword">true</span>);</span><br><span class="line">		DieLock dl2 = <span class="keyword">new</span> DieLock(<span class="keyword">false</span>);</span><br><span class="line">		dl1.start();</span><br><span class="line">		dl2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理想状态：if objA    if objB    else objB    “else objA</p>
<p>死锁状态：if objA    else objB（卡住了，死锁）</p>
<p>解决在后面</p>
<h2 id="3-线程间通信–等待唤醒机制"><a href="#3-线程间通信–等待唤醒机制" class="headerlink" title="3.线程间通信–等待唤醒机制"></a>3.线程间通信–等待唤醒机制</h2><p>线程间通信问题：针对同一个资源的操作有不同种类的线程</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/4.png" alt="4"></p>
<p>以学生作为资源来实现的</p>
<h4 id="1-最基本的版本，只有一个数据"><a href="#1-最基本的版本，只有一个数据" class="headerlink" title="1.最基本的版本，只有一个数据"></a>1.最基本的版本，只有一个数据</h4><p><strong>问题1：按照思路写代码，发现数据每次都是:null—0</strong></p>
<p>​    原因：我们在每个线程中都创建了新的资源,而我们要求的时候设置和获取线程的资源应该是同一个</p>
<p><strong>如何实现呢?</strong></p>
<p>​    在外界把这个数据创建出来，通过构造方法传递给其他的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源类：Student	</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取学生数据：GetThread(消费者)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Student s = new Student();</span></span><br><span class="line">		System.out.println(s.name + <span class="string">"---"</span> + s.age);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置学生数据:SetThread(生产者)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Student s = new Student();</span></span><br><span class="line">		s.name = <span class="string">"林青霞"</span>;</span><br><span class="line">		s.age = <span class="number">27</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类:StudentDemo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建资源</span></span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		<span class="comment">//设置和获取的类</span></span><br><span class="line">		SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">		GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line">		<span class="comment">//线程类</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-改进版本，给出了不同的数据，并加入了同步机制"><a href="#2-改进版本，给出了不同的数据，并加入了同步机制" class="headerlink" title="2.改进版本，给出了不同的数据，并加入了同步机制"></a>2.改进版本，给出了不同的数据，并加入了同步机制</h4><p>​    为了数据的效果好一些，我加入了循环和判断，给出不同的值，这个时候产生了新的问题。</p>
<ul>
<li>同一个数据出现多次？<ul>
<li>CPU的一点点时间片的执行权，就足够你执行很多次。</li>
</ul>
</li>
</ul>
<ul>
<li>姓名和年龄不匹配？<ul>
<li>线程运行的随机性</li>
</ul>
</li>
</ul>
<p>​    所以又回到了线程安全问题<br>​    <strong>解决方案：加锁。</strong></p>
<p><strong>注意：</strong></p>
<ul>
<li>不同种类的线程都要加锁。</li>
<li>不同种类的线程加的锁必须是同一把。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//资源类：Student	</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取学生数据：GetThread(消费者)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">				System.out.println(s.name + <span class="string">"---"</span> + s.age);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置学生数据:SetThread(生产者)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">				<span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//刚走到这里，就被别人抢到了执行权</span></span><br><span class="line">					s.name = <span class="string">"小明"</span>;</span><br><span class="line">					s.age = <span class="number">27</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//刚走到这里，就被别人抢到了执行权</span></span><br><span class="line">					s.name = <span class="string">"小红"</span>;</span><br><span class="line">					s.age = <span class="number">30</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				x++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类:StudentDemo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建资源</span></span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		<span class="comment">//设置和获取的类</span></span><br><span class="line">		SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">		GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line">		<span class="comment">//线程类</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-等待唤醒机制"><a href="#3-2-等待唤醒机制" class="headerlink" title="3-2.等待唤醒机制"></a>3-2.等待唤醒机制</h3><p><img src="../images/%E7%BA%BF%E7%A8%8B/5.png" alt="5"></p>
<ul>
<li>如果消费者先抢到了CPU的执行权，就会去消费数据，但是现在的数据是默认值，没有意义，应该等着数据有意义，再消费</li>
<li>如果生产者先抢到了CPU的执行权，就会去产生数据，但是，产生数据后，还继续拥有执行权，继续产生数据，是有问题的，应该等着消费者把数据收费掉，再生产</li>
</ul>
<p><strong>思路：</strong></p>
<p>​    生产者：先看是否有数据，有就等待，没有就生产，生产完之后通知消费者消费数据</p>
<p>​    消费者：先看是否有数据，有就消费，没有就等待，通知生产者生产数据。</p>
<p><strong>Java提供机制：等待唤醒机制</strong></p>
<p>Object类中提供了三个方法：</p>
<ul>
<li><p>wait():等待</p>
</li>
<li><p>notify():唤醒单个线程</p>
</li>
<li><p>notifyAll():唤醒所有线程</p>
</li>
</ul>
<p>为什么这些方法不定义在Thread类中呢?</p>
<p>​    这些方法的调用必须通过锁对象调用，而我们刚才使用的锁对象是任意锁对象。所以，这些方法必须定义在Object类中。</p>
<h4 id="3-等待唤醒机制改进该程序，让数据能够实现依次的出现"><a href="#3-等待唤醒机制改进该程序，让数据能够实现依次的出现" class="headerlink" title="3.等待唤醒机制改进该程序，让数据能够实现依次的出现"></a>3.等待唤醒机制改进该程序，让数据能够实现依次的出现</h4><p>​    虽然数据安全了，但是呢，一次一大片不好看，我就想依次的一次一个输出。如何实现呢?</p>
<p>​    通过Java提供的等待唤醒机制解决。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	String name;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">// 默认情况是没有数据，如果是true，说明有数据</span></span><br><span class="line">	<span class="keyword">boolean</span> flag; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">				<span class="keyword">if</span>(!s.flag)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						s.wait(); </span><br><span class="line">                        <span class="comment">//t2就等待了。立即释放锁。将来醒过来的时候，是从这里醒过来的时候</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(s.name + <span class="string">"---"</span> + s.age);</span><br><span class="line">				<span class="comment">//修改标记</span></span><br><span class="line">				s.flag = <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">//唤醒线程</span></span><br><span class="line">				s.notify(); <span class="comment">//唤醒t1</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (s) &#123;</span><br><span class="line">				<span class="comment">//判断有没有</span></span><br><span class="line">				<span class="keyword">if</span>(s.flag)&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						s.wait(); <span class="comment">//t1等着，释放锁</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">					s.name = <span class="string">"小明"</span>;</span><br><span class="line">					s.age = <span class="number">27</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					s.name = <span class="string">"小红"</span>;</span><br><span class="line">					s.age = <span class="number">30</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				x++; <span class="comment">//x=1</span></span><br><span class="line">				<span class="comment">//修改标记</span></span><br><span class="line">				s.flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">//唤醒线程</span></span><br><span class="line">				s.notify(); </span><br><span class="line">                <span class="comment">//唤醒t2,唤醒并不表示你立马可以执行，必须还得抢CPU的执行权。</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//t1有，或者t2有</span></span><br><span class="line">			<span class="comment">//就算你抢到了，也要等待，直到另一边执行结束来唤醒你</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建资源</span></span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		<span class="comment">//设置和获取的类</span></span><br><span class="line">		SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">		GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line">		<span class="comment">//线程类</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-等待唤醒机制的代码优化。把数据及操作都写在了资源类中"><a href="#4-等待唤醒机制的代码优化。把数据及操作都写在了资源类中" class="headerlink" title="4.等待唤醒机制的代码优化。把数据及操作都写在了资源类中"></a>4.等待唤醒机制的代码优化。把数据及操作都写在了资源类中</h4><p>方法：</p>
<ul>
<li>把Student的成员变量给私有的了。</li>
<li>把设置和获取的操作给封装成了功能，并加了同步。</li>
<li>设置或者获取的线程里面只需要调用方法即可。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">GetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			s.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SetThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Student s;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SetThread</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.s = s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (x % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				s.set(<span class="string">"林青霞"</span>, <span class="number">27</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				s.set(<span class="string">"刘意"</span>, <span class="number">30</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			x++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> flag; </span><br><span class="line">    <span class="comment">// 默认情况是没有数据，如果是true，说明有数据</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果有数据，就等待</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 设置数据</span></span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="comment">// 修改标记</span></span><br><span class="line">		<span class="keyword">this</span>.flag = <span class="keyword">true</span>;</span><br><span class="line">		<span class="keyword">this</span>.notify();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 如果没有数据，就等待</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.flag) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">this</span>.wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 获取数据</span></span><br><span class="line">		System.out.println(<span class="keyword">this</span>.name + <span class="string">"---"</span> + <span class="keyword">this</span>.age);</span><br><span class="line">		<span class="comment">// 修改标记</span></span><br><span class="line">		<span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">this</span>.notify();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建资源</span></span><br><span class="line">		Student s = <span class="keyword">new</span> Student();</span><br><span class="line">		<span class="comment">//设置和获取的类</span></span><br><span class="line">		SetThread st = <span class="keyword">new</span> SetThread(s);</span><br><span class="line">		GetThread gt = <span class="keyword">new</span> GetThread(s);</span><br><span class="line">		<span class="comment">//线程类</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(gt);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-线程的状态转换"><a href="#3-3-线程的状态转换" class="headerlink" title="3-3.线程的状态转换"></a>3-3.线程的状态转换</h3><p><strong>情况：</strong></p>
<ul>
<li>新建–就绪–运行–死亡</li>
<li>新建–就绪–运行–就绪–运行–死亡</li>
<li>新建–就绪–运行–其他阻塞–就绪–运行–死亡</li>
<li>新建–就绪–运行–同步阻塞–就绪–运行–死亡</li>
<li>新建–就绪–运行–等待阻塞–同步阻塞–就绪–运行–死亡</li>
</ul>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/6.png" alt="6"></p>
<h2 id="4-线程组"><a href="#4-线程组" class="headerlink" title="4.线程组"></a>4.线程组</h2><p>​    线程组： 把多个线程组合到一起。</p>
<p>​    Java中使用ThreadGroup来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。默认情况下，所有的线程都属于主线程组。</p>
<ul>
<li>public final ThreadGroup getThreadGroup()</li>
</ul>
<p>我们也可以给线程设置分组</p>
<ul>
<li>Thread(ThreadGroup group, Runnable target, String name) </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadGroupDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// method1();</span></span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 我们如何修改线程所在的组呢?</span></span><br><span class="line">		<span class="comment">// 创建一个线程组</span></span><br><span class="line">		<span class="comment">// 创建其他线程的时候，把其他线程的组指定为我们自己新建线程组</span></span><br><span class="line">		method2();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// ThreadGroup(String name)</span></span><br><span class="line">		ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"这是一个新的组"</span>);</span><br><span class="line">		MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">		<span class="comment">// Thread(ThreadGroup group, Runnable target, String name)</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"t1"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(tg, my, <span class="string">"t2"</span>);</span><br><span class="line">		System.out.println(t1.getThreadGroup().getName());</span><br><span class="line">		System.out.println(t2.getThreadGroup().getName());</span><br><span class="line">		<span class="comment">//通过组名称设置后台线程，表示该组的线程都是后台线程</span></span><br><span class="line">		tg.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(my, <span class="string">"t1"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(my, <span class="string">"t2"</span>);</span><br><span class="line">		<span class="comment">// 我不知道他们属于那个线程组,我想知道，怎么办</span></span><br><span class="line">		<span class="comment">// 线程类里面的方法：public final ThreadGroup getThreadGroup():返回该线程所属的线程组</span></span><br><span class="line">		ThreadGroup tg1 = t1.getThreadGroup();</span><br><span class="line">		ThreadGroup tg2 = t2.getThreadGroup();</span><br><span class="line">		<span class="comment">// 线程组里面的方法：public final String getName():返回此线程组的名称。</span></span><br><span class="line">		String name1 = tg1.getName();</span><br><span class="line">		String name2 = tg2.getName();</span><br><span class="line">		System.out.println(name1);</span><br><span class="line">		System.out.println(name2);</span><br><span class="line">		<span class="comment">// 通过结果我们知道了：线程默认情况下属于main线程组</span></span><br><span class="line">		<span class="comment">// 通过下面的测试，你应该能够看到，默任情况下，所有的线程都属于同一个组</span></span><br><span class="line">		System.out.println(Thread.currentThread().getThreadGroup().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h2><p>​    程序启动一个新线程成本是比较高的，因为它涉及到要与操作系统进行交互。而使用线程池可以很好的提高性能，尤其是当程序中要创建大量生存期很短的线程时，更应该考虑使用线程池。</p>
<p>​    线程池里的每一个线程代码结束后，并不会死亡，而是再次回到线程池中成为空闲状态，等待下一个对象来使用。</p>
<p>​    在JDK5之前，我们必须手动实现自己的线程池，从JDK5开始，Java内置支持线程池</p>
<p>​    JDK5新增了一个Executors工厂类来产生线程池</p>
<ul>
<li>public static ExecutorService newCachedThreadPool()</li>
<li>public static ExecutorService newFixedThreadPool(int nThreads)</li>
<li>public static ExecutorService newSingleThreadExecutor()</li>
<li>这些方法的返回值是ExecutorService对象，该对象表示一个线程池，可以执行Runnable对象或者Callable对象代表的线程。</li>
</ul>
<p>如何实现线程的代码呢?</p>
<ul>
<li><p>创建一个线程池对象，控制要创建几个线程对象。</p>
<ul>
<li>public static ExecutorService newFixedThreadPool(int nThreads)</li>
</ul>
</li>
<li><p>这种线程池的线程可以执行：</p>
<ul>
<li>可以执行Runnable对象或者Callable对象代表的线程</li>
<li>做一个类实现Runnable接口。</li>
</ul>
</li>
<li><p>调用如下方法即可</p>
<ul>
<li>Future&lt;?&gt; submit(Runnable task)</li>
<li><T> Future<T> submit(Callable<T> task)</T></T></T></li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建一个线程池对象，控制要创建几个线程对象。</span></span><br><span class="line">		<span class="comment">// public static ExecutorService newFixedThreadPool(int nThreads)</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">		pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">		pool.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">		<span class="comment">//结束线程池</span></span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-线程的第三种方式：实现Callable接口"><a href="#5-1-线程的第三种方式：实现Callable接口" class="headerlink" title="5-1.线程的第三种方式：实现Callable接口"></a>5-1.线程的第三种方式：实现Callable接口</h3><p>​    Callable：是带泛型的接口。这里指定的泛型其实是call()方法的返回值类型。创建Callable步骤和Runnable对象的差不多。</p>
<ul>
<li><p>好处：</p>
<ul>
<li>可以有返回值</li>
<li>可以抛出异常</li>
</ul>
</li>
<li><p>弊端：</p>
<ul>
<li>代码比较复杂，所以一般不用</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建线程池对象</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">//可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">		pool.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">		pool.submit(<span class="keyword">new</span> MyCallable());</span><br><span class="line">		<span class="comment">//结束</span></span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-线程求和案例"><a href="#5-2-线程求和案例" class="headerlink" title="5-2.线程求和案例"></a>5-2.线程求和案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计算求和</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyCallable</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= number; x++) &#123;</span><br><span class="line">			sum += x;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">		<span class="comment">// 创建线程池对象</span></span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">// 可以执行Runnable对象或者Callable对象代表的线程</span></span><br><span class="line">		Future&lt;Integer&gt; f1 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">100</span>));</span><br><span class="line">		Future&lt;Integer&gt; f2 = pool.submit(<span class="keyword">new</span> MyCallable(<span class="number">200</span>));</span><br><span class="line">		<span class="comment">// V get()</span></span><br><span class="line">		Integer i1 = f1.get();</span><br><span class="line">		Integer i2 = f2.get();</span><br><span class="line">		System.out.println(i1);</span><br><span class="line">		System.out.println(i2);</span><br><span class="line">		<span class="comment">// 结束</span></span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-匿名内部类方式使用多线程"><a href="#6-匿名内部类方式使用多线程" class="headerlink" title="6.匿名内部类方式使用多线程"></a>6.匿名内部类方式使用多线程</h2><p>匿名内部类的格式：</p>
<p>new 类名或者接口名() {<br>        重写方法;<br>};</p>
<p>本质：是该类或者接口的子类对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 继承Thread类来实现多线程</span></span><br><span class="line">		<span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">":"</span></span><br><span class="line">							+ x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		<span class="comment">// 实现Runnable接口来实现多线程</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">":"</span></span><br><span class="line">							+ x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;) &#123;</span><br><span class="line">		&#125;.start();</span><br><span class="line">		<span class="comment">// 更有难度的，要走的话，走子类“world”的</span></span><br><span class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">					System.out.println(<span class="string">"hello"</span> + <span class="string">":"</span> + x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">					System.out.println(<span class="string">"world"</span> + <span class="string">":"</span> + x);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-定时器"><a href="#7-定时器" class="headerlink" title="7.定时器"></a>7.定时器</h2><p>​    定时器是一个应用十分广泛的线程工具，可用于调度多个定时任务以后台线程的方式执行。在Java中，可以通过Timer和TimerTask类来实现定义调度的功能</p>
<p>​    定时器：可以让我们在指定的时间做某件事情，还可以重复的做某件事情。</p>
<p>​    依赖Timer和TimerTask这两个类：</p>
<ul>
<li><p>Timer：定时</p>
<ul>
<li>public Timer()</li>
<li>public void schedule(TimerTask task,long delay) ：安排在指定延迟后执行指定的任务。</li>
<li>public void schedule(TimerTask task,long delay,long period)：安排指定的任务从指定的延迟后开始进行重复的固定延迟执行。</li>
<li>public void cancel()</li>
</ul>
</li>
<li><p>TimerTask：任务</p>
<ul>
<li>public abstract void run()</li>
<li>public boolean cancel()</li>
</ul>
</li>
</ul>
<p>开发中：Quartz是一个完全由java编写的开源调度框架。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建定时器对象</span></span><br><span class="line">		Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line">		<span class="comment">// 3秒后执行爆炸任务</span></span><br><span class="line">		<span class="comment">// t.schedule(new MyTask(), 3000);</span></span><br><span class="line">		<span class="comment">//结束任务</span></span><br><span class="line">		t.schedule(<span class="keyword">new</span> MyTask(t), <span class="number">3000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 做一个任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Timer t;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(Timer t)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"beng,爆炸了"</span>);</span><br><span class="line">        <span class="comment">//结束</span></span><br><span class="line">		t.cancel();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例子2：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建定时器对象</span></span><br><span class="line">		Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line">		<span class="comment">// 3秒后执行爆炸任务第一次，如果不成功，每隔2秒再继续炸</span></span><br><span class="line">		t.schedule(<span class="keyword">new</span> MyTask2(), <span class="number">3000</span>, <span class="number">2000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 做一个任务</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask2</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"beng,爆炸了"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>练习：在指定的时间删除我们的指定目录(你可以指定c盘，但是我不建议，我使用项目路径下的demo)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeleteFolder</span> <span class="keyword">extends</span> <span class="title">TimerTask</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		File srcFolder = <span class="keyword">new</span> File(<span class="string">"demo"</span>);</span><br><span class="line">		deleteFolder(srcFolder);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 递归删除目录</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFolder</span><span class="params">(File srcFolder)</span> </span>&#123;</span><br><span class="line">		File[] fileArray = srcFolder.listFiles();</span><br><span class="line">		<span class="keyword">if</span> (fileArray != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (File file : fileArray) &#123;</span><br><span class="line">				<span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">					deleteFolder(file);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					System.out.println(file.getName() + <span class="string">":"</span> + file.delete());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(srcFolder.getName() + <span class="string">":"</span> + srcFolder.delete());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">		Timer t = <span class="keyword">new</span> Timer();</span><br><span class="line">		<span class="comment">//String s = "2020-04-02 15:45:00";</span></span><br><span class="line">		SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">		Date d = sdf.parse(s);</span><br><span class="line">		t.schedule(<span class="keyword">new</span> DeleteFolder(), d);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-多线程面试题"><a href="#8-多线程面试题" class="headerlink" title="8.多线程面试题"></a>8.多线程面试题</h2><ol>
<li><p>多线程有几种实现方案，分别是哪几种?</p>
<ol>
<li>两种：继承Thread类、实现Runnable接口</li>
<li>扩展一种：实现Callable接口。这个得和线程池结合。</li>
</ol>
</li>
<li><p>同步有几种方式，分别是什么?</p>
</li>
</ol>
<p>​    两种：同步代码块、同步方法</p>
<ol start="3">
<li><p>启动一个线程是run()还是start()?它们的区别?</p>
<ol>
<li>run()：封装了被线程执行的代码,直接调用仅仅是普通方法的调用</li>
<li>start()：启动线程，并由JVM自动调用run()方法</li>
</ol>
</li>
<li><p>sleep()和wait()方法的区别</p>
<ol>
<li>sleep()：必须指时间;不释放锁。wait():可以不指定时间，也可以指定时间;释放锁。</li>
<li>wait()：可以不指定时间，也可以指定时间;释放锁。</li>
</ol>
</li>
<li><p>为什么wait()、notify()、notifyAll()等方法都定义在Object类中</p>
</li>
</ol>
<p>​    因为这些方法的调用是依赖于锁对象的，而同步代码块的锁对象是任意锁。而Object代码任意的对象，所以，定义在这里面。</p>
<ol start="6">
<li>线程的生命周期图</li>
</ol>
<ul>
<li>新建 – 就绪 – 运行 – 死亡</li>
<li>新建 – 就绪 – 运行 – 阻塞 – 就绪 – 运行 – 死亡</li>
<li>建议：画图解释。</li>
</ul>
]]></content>
      <tags>
        <tag>JAVA线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程-1</title>
    <url>/post/d11c6ce.html</url>
    <content><![CDATA[<p>​    线程的使用，第一部分</p>
<a id="more"></a>

<h2 id="1-多线程理解"><a href="#1-多线程理解" class="headerlink" title="1.多线程理解"></a>1.多线程理解</h2><p>​    如果程序只有一条执行路径，那么该程序是单线程程序。如果该程序有多条执行路径，那么该程序是多线程程序。</p>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/1.png" alt="1"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">1:要想了解多线程，必须先了解线程，而要想了解线程，必须先了解进程，因为线程是依赖于进程而存在。</span><br><span class="line"></span><br><span class="line">2:什么是进程?</span><br><span class="line">   通过任务管理器我们就看到了进程的存在。</span><br><span class="line">   而通过观察，我们发现只有运行的程序才会出现进程。</span><br><span class="line">   进程：就是正在运行的程序。</span><br><span class="line">   进程是系统进行资源分配和调用的独立单位。每一个进程都有它自己的内存空间和系统资源。</span><br><span class="line">   </span><br><span class="line">3:多进程有什么意义呢?</span><br><span class="line">   单进程的计算机只能做一件事情，而我们现在的计算机都可以做多件事情。</span><br><span class="line">   举例：一边玩游戏(游戏进程)，一边听音乐(音乐进程)。</span><br><span class="line">   也就是说现在的计算机都是支持多进程的，可以在一个时间段内执行多个任务。</span><br><span class="line">   并且呢，可以提高CPU的使用率。</span><br><span class="line">   </span><br><span class="line">   问题：</span><br><span class="line">      一边玩游戏，一边听音乐是同时进行的吗?</span><br><span class="line">      不是。因为单CPU在某一个时间点上只能做一件事情。</span><br><span class="line">      而我们在玩游戏，或者听音乐的时候，是CPU在做着程序间的高效切换让我们觉得是同时进行的。</span><br><span class="line">      </span><br><span class="line">4:什么是线程呢?</span><br><span class="line">   在同一个进程内又可以执行多个任务，而这每一个任务我就可以看出是一个线程。</span><br><span class="line">   线程：是程序的执行单元，执行路径。是程序使用CPU的最基本单位。</span><br><span class="line">   单线程：如果程序只有一条执行路径。</span><br><span class="line">   多线程：如果程序有多条执行路径。</span><br><span class="line">   </span><br><span class="line">5:多线程有什么意义呢?</span><br><span class="line">   多线程的存在，不是提高程序的执行速度。其实是为了提高应用程序的使用率。</span><br><span class="line">   程序的执行其实都是在抢CPU的资源，CPU的执行权。</span><br><span class="line">   多个进程是在抢这个资源，而其中的某一个进程如果执行路径比较多，就会有更高的几率抢到CPU的执行权。</span><br><span class="line">   我们是不敢保证哪一个线程能够在哪个时刻抢到，所以线程的执行有随机性。</span><br><span class="line">   而多线程却给了我们一个错觉：让我们认为多个线程是并发执行的。其实不是。</span><br><span class="line">   因为多个线程共享同一个进程的资源(堆内存和方法区)，但是栈内存是独立的，一个线程一个栈。</span><br><span class="line">   所以他们仍然是在抢CPU的资源执行。一个时间点上只有能有一个线程执行。而且谁抢到，这个不一定，所以，造成了线程运行的随机性。</span><br><span class="line"></span><br><span class="line">6：那么什么又是并发呢？</span><br><span class="line">    大家注意两个词汇的区别：并行和并发。</span><br><span class="line">    前者是逻辑上同时发生，指在某一个时间内同时运行多个程序。</span><br><span class="line">    后者是物理上同时发生，指在某一个时间点同时运行多个程序。</span><br><span class="line">    那么，我们能不能实现真正意义上的并发呢，是可以的，多个CPU就可以实现，不过你得知道如何调度和控制它们。</span><br></pre></td></tr></table></figure>

<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>进程：<ul>
<li>正在运行的程序，是系统进行资源分配和调用的独立单位。</li>
<li>每一个进程都有它自己的内存空间和系统资源。</li>
</ul>
</li>
<li>线程：<ul>
<li>是进程中的单个顺序控制流，是一条执行路径</li>
<li>一个进程如果只有一条执行路径，则称为单线程程序。</li>
<li>一个进程如果有多条执行路径，则称为多线程程序。</li>
</ul>
</li>
</ul>
<p>Java程序的运行原理：</p>
<p>​    由java命令启动JVM，JVM启动就相当于启动了一个进程。接着有该进程创建了一个主线程去调用main方法。</p>
<p>jvm虚拟机的启动是单线程的还是多线程的?</p>
<p>​    多线程的。</p>
<p>​    原因是垃圾回收线程也要先启动，否则很容易会出现内存溢出。现在的垃圾回收线程加上前面的主线程，最低启动了两个线程，所以，jvm的启动其实是多线程的。</p>
<h2 id="2-实现多线程的程序"><a href="#2-实现多线程的程序" class="headerlink" title="2.实现多线程的程序"></a>2.实现多线程的程序</h2><h3 id="2-1-如何实现呢"><a href="#2-1-如何实现呢" class="headerlink" title="2-1.如何实现呢?"></a>2-1.如何实现呢?</h3><p>​    由于线程是依赖进程而存在的，所以我们应该先创建一个进程出来。而进程是由系统创建的，所以我们应该去调用系统功能创建一个进程。Java是不能直接调用系统功能的，所以，我们没有办法直接实现多线程程序。Java可以去调用写好的程序来实现多线程程序。由JAVA去调用这样的东西，然后提供一些类供我们使用。我们就可以实现多线程程序了。</p>
<h3 id="2-2-那么Java提供的类是什么呢"><a href="#2-2-那么Java提供的类是什么呢" class="headerlink" title="2-2.那么Java提供的类是什么呢?"></a>2-2.那么Java提供的类是什么呢?</h3><p>​    Thread。通过查看API，我们知道了有2中方式实现多线程程序。</p>
<h4 id="方式1：继承Thread类。"><a href="#方式1：继承Thread类。" class="headerlink" title="方式1：继承Thread类。"></a>方式1：继承Thread类。</h4><p>步骤：</p>
<ul>
<li>A:自定义类MyThread继承Thread类。</li>
<li>B:MyThread类里面重写run()</li>
<li>C:创建对象</li>
<li>D:启动线程</li>
</ul>
<p><strong>问题1：该类要重写run()方法,为什么呢?</strong></p>
<p>​    不是类中的所有代码都需要被线程执行的。而这个时候，为了区分哪些代码能够被线程执行，java提供了Thread类中的run()用来包含那些被线程执行的代码。</p>
<p><strong>问题2：调用run()方法为什么是单线程的呢?</strong></p>
<p>​     因为run()方法直接调用其实就相当于普通的方法调用,所以你看到的是单线程的效果要想看到多线程的效果，就必须说说另一个方法：start()。</p>
<p> <strong>面试题：run()和start()的区别?</strong></p>
<ul>
<li>run():仅仅是封装被线程执行的代码，直接调用是普通方法</li>
<li>start():首先启动了线程，然后再由jvm去调用该线程的run()方法。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 一般来说，被线程执行的代码肯定是比较耗时的。所以我们用循环改进</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">200</span>; x++) &#123;</span><br><span class="line">			System.out.println(x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建线程对象</span></span><br><span class="line">		MyThread my = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		my.run();</span><br><span class="line">		my.run();</span><br><span class="line">		<span class="comment">// MyThread my = new MyThread();</span></span><br><span class="line">		<span class="comment">// my.start();</span></span><br><span class="line">		<span class="comment">// IllegalThreadStateException:非法的线程状态异常</span></span><br><span class="line">		<span class="comment">// 为什么呢?</span></span><br><span class="line">        <span class="comment">//因为这个相当于是my线程被调用了两次。而不是两个线程启动。</span></span><br><span class="line">		<span class="comment">// my.start();</span></span><br><span class="line">		<span class="comment">// 创建两个线程对象</span></span><br><span class="line">		MyThread my1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">		MyThread my2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">		my1.start();</span><br><span class="line">		my2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方式2：实现Runnable接口"><a href="#方式2：实现Runnable接口" class="headerlink" title="方式2：实现Runnable接口"></a>方式2：实现Runnable接口</h4><p>步骤：</p>
<ul>
<li>自定义类MyRunnable实现Runnable接口</li>
<li>重写run()方法</li>
<li>创建MyRunnable类的对象</li>
<li>创建Thread类的对象，并把C步骤的对象作为构造参数传递</li>
</ul>
<p>实现接口方式的好处：</p>
<ul>
<li>可以避免由于Java单继承带来的局限性。</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码，数据有效分离，较好的体现了面向对象的设计思想。</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">			<span class="comment">// 由于实现接口的方式就不能直接使用Thread类的方法了,但是可以间接的使用</span></span><br><span class="line">			<span class="comment">// getName()不能直接用</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnableDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建MyRunnable类的对象</span></span><br><span class="line">		MyRunnable my = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">		<span class="comment">// 创建Thread类的对象，并把C步骤的对象作为构造参数传递</span></span><br><span class="line">		<span class="comment">// Thread(Runnable target)</span></span><br><span class="line">		<span class="comment">// Thread t1 = new Thread(my);</span></span><br><span class="line">		<span class="comment">// Thread t2 = new Thread(my);</span></span><br><span class="line">		<span class="comment">// t1.setName("t1");</span></span><br><span class="line">		<span class="comment">// t2.setName("t2");</span></span><br><span class="line">        <span class="comment">// 方法使用</span></span><br><span class="line">		<span class="comment">// Thread(Runnable target, String name)</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(my, <span class="string">"t1"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(my, <span class="string">"t2"</span>);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="../images/%E7%BA%BF%E7%A8%8B/3.png" alt="3"></p>
<h3 id="线程名称"><a href="#线程名称" class="headerlink" title="线程名称"></a>线程名称</h3><ul>
<li>如何获取线程对象的名称呢?<ul>
<li>public final String getName()    获取线程的名称。</li>
</ul>
</li>
<li>如何设置线程对象的名称呢?<ul>
<li>public final void setName(String name)    设置线程的名称</li>
</ul>
</li>
</ul>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建线程对象</span></span><br><span class="line">		<span class="comment">//无参构造+setXxx()</span></span><br><span class="line">		MyThread my1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">		MyThread my2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="comment">//调用方法设置名称</span></span><br><span class="line">		my1.setName(<span class="string">"林青霞"</span>);</span><br><span class="line">		my2.setName(<span class="string">"刘意"</span>);</span><br><span class="line">		my1.start();</span><br><span class="line">		my2.start();</span><br><span class="line">        <span class="comment">//不用setName，会得到Thread-0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//名称为什么是：Thread-? 编号。	调用Thread的init方法设置的</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">class Thread &#123;</span></span><br><span class="line"><span class="comment">	private char name[];</span></span><br><span class="line"><span class="comment">	//名字</span></span><br><span class="line"><span class="comment">	public Thread() &#123;</span></span><br><span class="line"><span class="comment">        init(null, null, "Thread-" + nextThreadNum(), 0);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">class MyThread extends Thread &#123;</span></span><br><span class="line"><span class="comment">	public MyThread() &#123;</span></span><br><span class="line"><span class="comment">		super();</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>方式二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一定要</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//一定要</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		带参构造方法给线程起名字</span><br><span class="line">		MyThread my1 = <span class="keyword">new</span> MyThread(<span class="string">"林青霞"</span>);</span><br><span class="line">		MyThread my2 = <span class="keyword">new</span> MyThread(<span class="string">"刘意"</span>);</span><br><span class="line">		my1.start();</span><br><span class="line">		my2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题1：针对不是Thread类的子类中如何获取线程对象名称呢?</strong></p>
<ul>
<li>public static Thread currentThread()    返回当前正在执行的线程对象</li>
<li>Thread.currentThread().getName()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Thread.currentThread().getName());</span><br></pre></td></tr></table></figure>



<h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><p>​    假如我们的计算机只有一个 CPU，那么 CPU 在某一个时刻只能执行一条指令，线程只有得到 CPU时间片，也就是使用权，才可以执行指令。那么Java是如何对线程进行调用的呢？</p>
<p>线程有两种调度模型：</p>
<ul>
<li>分时调度模型   所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片</li>
<li>抢占式调度模型   优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些。 </li>
<li>Java使用的是抢占式调度模型。</li>
</ul>
<p><strong>如何设置和获取线程优先级？</strong></p>
<p>线程没有设置优先级,肯定有默认优先级。线程默认优先级是5。</p>
<p><strong>获取线程对象的优先级：</strong></p>
<ul>
<li>public final int getPriority():返回线程对象的优先级</li>
</ul>
<p><strong>设置线程对象的优先级：</strong></p>
<ul>
<li>public final void setPriority(int newPriority)：更改线程的优先级。 </li>
</ul>
<p><strong>注意：</strong></p>
<p>​    线程优先级的范围是：1-10。</p>
<p>​    线程优先级高仅仅表示线程获取的 CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到比较好的效果。因为，线程有随机性。</p>
<p>​    IllegalArgumentException    非法参数异常。</p>
<p>​    抛出的异常表明向方法传递了一个不合法或不正确的参数。 </p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPriorityDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadPriority tp1 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">		ThreadPriority tp2 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">		ThreadPriority tp3 = <span class="keyword">new</span> ThreadPriority();</span><br><span class="line">		tp1.setName(<span class="string">"tp1"</span>);</span><br><span class="line">		tp2.setName(<span class="string">"tp2"</span>);</span><br><span class="line">		tp3.setName(<span class="string">"tp3"</span>);</span><br><span class="line">		<span class="comment">// 获取默认优先级</span></span><br><span class="line">		System.out.println(tp1.getPriority());</span><br><span class="line">		System.out.println(tp2.getPriority());</span><br><span class="line">		System.out.println(tp3.getPriority());</span><br><span class="line">		<span class="comment">// 设置线程优先级</span></span><br><span class="line">		<span class="comment">// tp1.setPriority(100000);</span></span><br><span class="line">		<span class="comment">//出异常，优先级太大</span></span><br><span class="line">		<span class="comment">//设置正确的线程优先级</span></span><br><span class="line">		tp1.setPriority(<span class="number">10</span>);</span><br><span class="line">		tp2.setPriority(<span class="number">1</span>);</span><br><span class="line">		tp1.start();</span><br><span class="line">		tp2.start();</span><br><span class="line">		tp3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程控制-睡眠"><a href="#线程控制-睡眠" class="headerlink" title="线程控制-睡眠"></a>线程控制-睡眠</h3><p>​    public static void sleep(long millis)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleep</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">":"</span> + x + <span class="string">",日期："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">			<span class="comment">//休息1秒钟</span></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSleepDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadSleep ts1 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">		ThreadSleep ts2 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">		ThreadSleep ts3 = <span class="keyword">new</span> ThreadSleep();</span><br><span class="line">		ts1.setName(<span class="string">"ts1"</span>);</span><br><span class="line">		ts2.setName(<span class="string">"ts2"</span>);</span><br><span class="line">		ts3.setName(<span class="string">"ts3"</span>);</span><br><span class="line">		ts1.start();</span><br><span class="line">		ts2.start();</span><br><span class="line">		ts3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程控制-加入"><a href="#线程控制-加入" class="headerlink" title="线程控制-加入"></a>线程控制-加入</h3><p>​    public final void join():等待该线程终止。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadJoin为普通继承Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadJoin tj1 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">		ThreadJoin tj2 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">		ThreadJoin tj3 = <span class="keyword">new</span> ThreadJoin();</span><br><span class="line">		tj1.setName(<span class="string">"tj1"</span>);</span><br><span class="line">		tj2.setName(<span class="string">"tj2"</span>);</span><br><span class="line">		tj3.setName(<span class="string">"tj3"</span>);</span><br><span class="line">        <span class="comment">//直到tj1结束，tj2，tj3才开始</span></span><br><span class="line">		tj1.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			tj1.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		tj2.start();</span><br><span class="line">		tj3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程控制-礼让"><a href="#线程控制-礼让" class="headerlink" title="线程控制-礼让"></a>线程控制-礼让</h3><p>​    public static void yield()</p>
<p>​    暂停当前正在执行的线程对象，并执行其他线程。 让多个线程的执行更和谐，但是不能靠它保证一人一次。（后面会完善用法）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYield</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">100</span>; x++) &#123;</span><br><span class="line">			System.out.println(getName() + <span class="string">":"</span> + x);</span><br><span class="line">			Thread.yield();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadYieldDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadYield ty1 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">		ThreadYield ty2 = <span class="keyword">new</span> ThreadYield();</span><br><span class="line">		ty1.setName(<span class="string">"ty1"</span>);</span><br><span class="line">		ty2.setName(<span class="string">"ty2"</span>);</span><br><span class="line">		ty1.start();</span><br><span class="line">		ty2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程控制-后台线程"><a href="#线程控制-后台线程" class="headerlink" title="线程控制-后台线程"></a>线程控制-后台线程</h3><p>​    public final void setDaemon(boolean on)</p>
<p>​    将该线程标记为守护线程或用户线程。当正在运行的线程都是守护线程时，Java 虚拟机退出。 该方法必须在启动线程前调用。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ThreadDaemon为普通继承Thread</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDaemonDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadDaemon td1 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">		ThreadDaemon td2 = <span class="keyword">new</span> ThreadDaemon();</span><br><span class="line">		td1.setName(<span class="string">"td1"</span>);</span><br><span class="line">		td2.setName(<span class="string">"td2"</span>);</span><br><span class="line">		<span class="comment">// 设置收获线程</span></span><br><span class="line">		td1.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		td2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		td1.start();</span><br><span class="line">		td2.start();</span><br><span class="line">        <span class="comment">//当main线程结束，td1和td2线程也会结束，但会相应走一段，结束，但没那么快</span></span><br><span class="line">		Thread.currentThread().setName(<span class="string">"main"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="number">5</span>; x++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程控制-中断线程"><a href="#线程控制-中断线程" class="headerlink" title="线程控制-中断线程"></a>线程控制-中断线程</h3><ul>
<li><p>public final void stop()</p>
<ul>
<li>让线程停止，过时了，但是还可以使用。</li>
</ul>
</li>
<li><p>public void interrupt()</p>
<ul>
<li>中断线程，方法：把线程的状态终止，并抛出一个InterruptedException。</li>
<li>接着代码走，抛出的异常和剩下的代码</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStop</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"开始执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">		<span class="comment">// 休息10秒钟</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			<span class="comment">// e.printStackTrace();</span></span><br><span class="line">			System.out.println(<span class="string">"线程被终止了"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"结束执行："</span> + <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadStopDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadStop ts = <span class="keyword">new</span> ThreadStop();</span><br><span class="line">		ts.start();</span><br><span class="line">		<span class="comment">// 超过三秒不醒过来，终止</span></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            <span class="comment">//过时</span></span><br><span class="line">			<span class="comment">// ts.stop();</span></span><br><span class="line">			ts.interrupt();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul>
<li>新建：创建线程对象</li>
<li>就绪：有执行资格，没有执行权</li>
<li>运行：有执行资格，有执行权</li>
<li>阻塞：由于一些操作让线程处于该状态。没有执行状态，没有执行权，而另一些操作却可以把它给激活，激活后处于就绪状态</li>
<li>死亡：线程对象变成垃圾，等待被回收</li>
</ul>
<p><img src="../images/%E7%BA%BF%E7%A8%8B/2.png" alt="2"></p>
<h2 id="3-线程练习"><a href="#3-线程练习" class="headerlink" title="3.线程练习"></a>3.线程练习</h2><p>​    某电影院目前正在上映贺岁大片，共有100张票，而它有3个售票窗口售票，请设计一个程序模拟该电影院售票。</p>
<p><strong>两种方式实现：</strong></p>
<h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义100张票</span></span><br><span class="line">	<span class="comment">// private int tickets = 100;</span></span><br><span class="line">	<span class="comment">// 为了让多个线程对象共享这100张票，用静态修饰</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 每个线程进来都会走这里，这样的话，每个线程对象相当于买的是自己的那100张票，这不合理，所以应该定义到外面</span></span><br><span class="line">		<span class="comment">// int tickets = 100;</span></span><br><span class="line">		<span class="comment">// 是为了模拟一直有票</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(getName() + <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建三个线程对象</span></span><br><span class="line">		SellTicket st1 = <span class="keyword">new</span> SellTicket();</span><br><span class="line">		SellTicket st2 = <span class="keyword">new</span> SellTicket();</span><br><span class="line">		SellTicket st3 = <span class="keyword">new</span> SellTicket();</span><br><span class="line">		<span class="comment">// 给线程对象起名字</span></span><br><span class="line">		st1.setName(<span class="string">"窗口1"</span>);</span><br><span class="line">		st2.setName(<span class="string">"窗口2"</span>);</span><br><span class="line">		st3.setName(<span class="string">"窗口3"</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		st1.start();</span><br><span class="line">		st2.start();</span><br><span class="line">		st3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    会有错误，后面修订</p>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义100张票</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span></span><br><span class="line">						+ (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建资源对象</span></span><br><span class="line">		SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">		<span class="comment">// 创建三个线程对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    相比较之下，Runnable接口的方式产生错误会比继承Thread少，但还是会有，后面修订</p>
<h3 id="问题与解决"><a href="#问题与解决" class="headerlink" title="问题与解决"></a>问题与解决</h3><p>​    电影院售票程序，从表面上看不出什么问题，但是在真实生活中，售票时网络是不能实时传输的，总是存在延迟的情况，所以，在出售一张票以后，需要一点时间的延迟</p>
<p>​    接口方式的卖票程序：每次卖票延迟100毫秒</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义100张票</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">//问题-1：相同的票卖了多次</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// t1,t2,t3三个线程</span></span><br><span class="line">			<span class="comment">// 这一次的tickets = 100;</span></span><br><span class="line">			<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 模拟真实的场景，稍作休息</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>); <span class="comment">// t1就稍作休息,t2就稍作休息</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span></span><br><span class="line">						+ (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">				<span class="comment">// 理想状态：</span></span><br><span class="line">				<span class="comment">// 窗口1正在出售第100张票</span></span><br><span class="line">				<span class="comment">// 窗口2正在出售第99张票</span></span><br><span class="line">				<span class="comment">// 但是呢?</span></span><br><span class="line">				<span class="comment">// CPU的每一次执行必须是一个原子性(最简单基本的)的操作。</span></span><br><span class="line">				<span class="comment">// 先记录以前的值</span></span><br><span class="line">				<span class="comment">// 接着把ticket--</span></span><br><span class="line">				<span class="comment">// 然后输出以前的值(t2来了)</span></span><br><span class="line">				<span class="comment">// ticket的值就变成了99</span></span><br><span class="line">				<span class="comment">// 窗口1正在出售第100张票</span></span><br><span class="line">				<span class="comment">// 窗口2正在出售第100张票</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//问题-2：出现了负数票</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// t1,t2,t3三个线程</span></span><br><span class="line">			<span class="comment">// 这一次的tickets = 1;</span></span><br><span class="line">			<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="comment">// 为了模拟更真实的场景，我们稍作休息</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">100</span>); <span class="comment">//t1进来了并休息，t2进来了并休息，t3进来了并休息，</span></span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">"正在出售第"</span></span><br><span class="line">						+ (tickets--) + <span class="string">"张票"</span>);</span><br><span class="line">				<span class="comment">//窗口1正在出售第1张票,tickets=0</span></span><br><span class="line">				<span class="comment">//窗口2正在出售第0张票,tickets=-1</span></span><br><span class="line">				<span class="comment">//窗口3正在出售第-1张票,tickets=-2</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建资源对象</span></span><br><span class="line">		SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">		<span class="comment">// 创建三个线程对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="通过加入延迟后，就产生了两个问题："><a href="#通过加入延迟后，就产生了两个问题：" class="headerlink" title="通过加入延迟后，就产生了两个问题："></a>通过加入延迟后，就产生了两个问题：</h4><ul>
<li>A:相同的票卖了多次<ul>
<li>CPU的一次操作必须是原子性的</li>
</ul>
</li>
<li>B:出现了负数票<ul>
<li>随机性和延迟导致的</li>
</ul>
</li>
</ul>
<p>线程安全问题在理想状态下，不容易出现，但一旦出现对软件的影响是非常大的</p>
<p>​    要想解决问题，就要知道哪些原因会导致出问题:(而且这些原因也是以后我们判断一个程序是否会有线程安全问题的标准)</p>
<ol>
<li>是否是多线程环境</li>
<li>是否有共享数据</li>
<li>是否有多条语句操作共享数据</li>
</ol>
<p><strong>解决思想：</strong></p>
<p>​    把多条语句操作共享数据的代码给包成一个整体，让某个线程在执行的时候，别人不能来执行。Java给我们提供了：同步机制。</p>
<h4 id="同步代码块："><a href="#同步代码块：" class="headerlink" title="同步代码块："></a>同步代码块：</h4><p>​     synchronized(对象){<br>​        需要同步的代码;<br>​     }</p>
<h4 id="需要同步的代码是哪些呢"><a href="#需要同步的代码是哪些呢" class="headerlink" title="需要同步的代码是哪些呢?"></a>需要同步的代码是哪些呢?</h4><p>​        把多条语句操作共享数据的代码的部分给包起来</p>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li>同步可以解决安全问题的根本原因就在那个对象上。该对象如同锁的功能。</li>
<li>多个线程必须是同一把锁。</li>
</ul>
<p><strong>代码实现：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicket</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 定义100张票</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// 定义同一把锁</span></span><br><span class="line">	<span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// t1,t2,t3都能走到这里</span></span><br><span class="line">			<span class="comment">// 假设t1抢到CPU的执行权，t1就要进来</span></span><br><span class="line">			<span class="comment">// 假设t2抢到CPU的执行权，t2就要进来,发现门是关着的，进不去。所以就等着。</span></span><br><span class="line">			<span class="comment">// 门(开,关)</span></span><br><span class="line">			<span class="keyword">synchronized</span> (obj) &#123; <span class="comment">// 发现这里的代码将来是会被锁上的，所以t1进来后，就锁了。(关)</span></span><br><span class="line">				<span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">100</span>); <span class="comment">// t1就睡眠了</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(Thread.currentThread().getName()</span><br><span class="line">							+ <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">					<span class="comment">//窗口1正在出售第100张票</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="comment">//t1就出来可，然后就开门。(开)</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SellTicketDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建资源对象</span></span><br><span class="line">		SellTicket st = <span class="keyword">new</span> SellTicket();</span><br><span class="line">		<span class="comment">// 创建三个线程对象</span></span><br><span class="line">		Thread t1 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口1"</span>);</span><br><span class="line">		Thread t2 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口2"</span>);</span><br><span class="line">		Thread t3 = <span class="keyword">new</span> Thread(st, <span class="string">"窗口3"</span>);</span><br><span class="line">		<span class="comment">// 启动线程</span></span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-同步"><a href="#4-同步" class="headerlink" title="4.同步"></a>4.同步</h2><p>同步的特点：</p>
<ul>
<li>前提：多个线程</li>
<li>解决问题的时候要注意：多个线程使用的是同一个锁对象</li>
<li>同步的好处 ：同步的出现解决了多线程的安全问题。</li>
<li>同步的弊端： 当线程相当多时，因为每个线程都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率。</li>
</ul>
<h3 id="同步的各种问题"><a href="#同步的各种问题" class="headerlink" title="同步的各种问题"></a>同步的各种问题</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//同步代码块用obj做锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                   + <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>同步代码块的锁对象是：任意对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Demo d = <span class="keyword">new</span> Demo();</span><br><span class="line"><span class="comment">//同步代码块用任意对象做锁</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                   + <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>同步方法的格式及锁对象：把同步关键字加在方法上。</p>
</li>
<li><p>同步方法是：this</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                       + <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            sellTicket();</span><br><span class="line">        &#125;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                           + <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>静态方法及锁对象是：类的字节码文件对象。(反射)（要比静态先存在，class文件）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> tickets = <span class="number">100</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SellTicket<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                                       + <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            sellTicket();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        x++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tickets &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()</span><br><span class="line">                           + <span class="string">"正在出售第"</span> + (tickets--) + <span class="string">"张票 "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>如果锁对象是this，就可以考虑使用同步方法。否则能使用同步代码块的尽量使用同步代码块</p>
<h2 id="5-以前的线程安全的类"><a href="#5-以前的线程安全的类" class="headerlink" title="5.以前的线程安全的类"></a>5.以前的线程安全的类</h2><p>线程安全：StringBuffer、Vector、Hashtable<br>如何把一个线程不安全的集合类变成一个线程安全的集合类？<br>用Collections工具类的方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 线程安全的类</span></span><br><span class="line">      <span class="comment">// 里面有些方法加synchronized</span></span><br><span class="line">      StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">      Vector&lt;String&gt; v = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">      Hashtable&lt;String, String&gt; h = <span class="keyword">new</span> Hashtable&lt;String, String&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Vector是线程安全的时候才去考虑使用的，但是我还说过即使要安全，我也不用你</span></span><br><span class="line">      <span class="comment">// 那么到底用谁呢?</span></span><br><span class="line">      <span class="comment">// public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</span></span><br><span class="line">      List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();<span class="comment">// 线程不安全</span></span><br><span class="line">      List&lt;String&gt; list2 = Collections</span><br><span class="line">            .synchronizedList(<span class="keyword">new</span> ArrayList&lt;String&gt;()); <span class="comment">// 线程安全</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>JAVA线程</tag>
      </tags>
  </entry>
  <entry>
    <title>做过项目展示</title>
    <url>/post/d9dde34b.html</url>
    <content><![CDATA[<p>做过的项目</p>
<a id="more"></a>


<p><a href="https://linhuide.github.io/Sprintboot-BiShe/" title="毕业项目">毕业项目</a></p>
<p><a href="https://linhuide.github.io/SSM-JAVAEE/">JaveEE课程设计</a></p>
]]></content>
  </entry>
  <entry>
    <title>java8新特性</title>
    <url>/post/f41870e2.html</url>
    <content><![CDATA[<p>​    关于java8的新特性</p>
<a id="more"></a>

<ul>
<li>速度更快<ul>
<li>修改底层数据结构：HashMap（数组-链表-红黑数），HashSet，ConcurrentHashMap（CAS算法）</li>
<li>修改垃圾回收机制（内存结构）：取消堆中的永久区（PremGen）-&gt;回收条件苛刻，使用元空间（MetaSpace）-&gt;直接使用物理内存-&gt;加载类文件</li>
</ul>
</li>
</ul>
<p>底层数据结构：最核心HashMap：</p>
<p>​    HashMap如果不用哈希算法，用equals，效率极低。对比HashCode，没有直接进来。相同，通过equals内容比较不同，形成链表，后加的放前边，称为碰撞，但碰撞应该避免，因为链表元素过多，效率低。</p>
<p>​    equals和HashCode重写方法严谨一点，但还是避免不了，因为数组的索引值就几个。方法，提供加载因子，默认0,75，当元素到达哈希表的75%，进行扩容。把链表里面的元素进行重排序，新位置，碰撞概率变低。</p>
<p>​    但极端情况，查找元素，查找到链表，查找到最后一个，查找效率变低。<br><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/1.png" alt="1"></p>
<p>​    所以jdk1.8后，数组+链表+红黑数（二叉树一种）</p>
<p>​    链表元素长度（个数）大于8，容量大于64，转换为红黑树。</p>
<p>​    链表转为红黑树后，除了添加以外，其他的效率都高了。添加，链表直接在后面添加，在红黑树要比较大小后才添加。</p>
<p>​    扩容以后，换位置不用重新计算，在原来哈希表的总长度+当前的位置，原来5，+3，在第8个位置。</p>
<p>​    HashSet变了，ConcurrenHashMap变了，改为CAS算法（无锁算法）</p>
<p>底层数据结构：内存</p>
<p>​    永久区没有了，JVM调优，PremGenSize，MaxPremGenSize没有了。取而代之，MetaspaceSize，MaxMetaSpaceSize。</p>
<ul>
<li>代码更少（增加了新的语法 Lambda  表达式）</li>
<li>强大的 Stream API</li>
<li>便于并行</li>
<li>最大化减少空指针异常 Optional</li>
</ul>
<h2 id="1-Lambda-表达式"><a href="#1-Lambda-表达式" class="headerlink" title="1.Lambda 表达式"></a>1.Lambda 表达式</h2><p>​    Lambda 是一个 匿名函数，我们可以把 Lambda表达式理解为是 一段可以传递的代码（将代码像数据一样进行传递）。可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。</p>
<h3 id="1-1-从匿名类到Lambda的转换："><a href="#1-1-从匿名类到Lambda的转换：" class="headerlink" title="1-1.从匿名类到Lambda的转换："></a>1-1.从匿名类到Lambda的转换：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来的匿名内部类</span></span><br><span class="line">Runnable ri=<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"sss"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//现在的 Lambda 表达式</span></span><br><span class="line">Runnable ri=()-&gt;System.out.println(<span class="string">"sss"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//原来的匿名内部类作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts2 = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Integer.compare(o1.length(), o2.length());</span><br><span class="line">		&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//现在的 Lambda 表达式作为参数传递</span></span><br><span class="line">TreeSet&lt;String&gt; ts2 = <span class="keyword">new</span> TreeSet&lt;&gt;((o1,o2) -&gt; Integer.compare(o1.length(), o2.length());</span><br></pre></td></tr></table></figure>

<p><strong>代码例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//原来的匿名内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Comparator&lt;String&gt; com = <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> Integer.compare(o1.length(), o2.length());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(com);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在的 Lambda 表达式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Comparator&lt;String&gt; com = (x, y) -&gt; Integer.compare(x.length(), y.length());</span><br><span class="line">	TreeSet&lt;String&gt; ts = <span class="keyword">new</span> TreeSet&lt;&gt;(com);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-具体例子："><a href="#1-2-具体例子：" class="headerlink" title="1-2.具体例子："></a>1-2.具体例子：</h3><p>一个实体类，接口，两个实现类，优化方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyPredicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="comment">//年龄小于 35</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeForAge</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.getAge() &lt;= <span class="number">35</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工资大于 5000</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterEmployeeForSalary</span> <span class="keyword">implements</span> <span class="title">MyPredicate</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t.getSalary() &gt;= <span class="number">5000</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>主代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组转集合，输入数据</span></span><br><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//需求：获取公司中年龄小于 35 的员工信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployeeAge</span><span class="params">(List&lt;Employee&gt; emps)</span></span>&#123;</span><br><span class="line">	List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Employee emp : emps) &#123;</span><br><span class="line">		<span class="keyword">if</span>(emp.getAge() &lt;= <span class="number">35</span>)&#123;</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	List&lt;Employee&gt; list = filterEmployeeAge(emps);</span><br><span class="line">	<span class="keyword">for</span> (Employee employee : list) &#123;</span><br><span class="line">		System.out.println(employee);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果又多出一个需求</span></span><br><span class="line"><span class="comment">//需求：获取公司中工资大于 5000 的员工信息</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployeeSalary</span><span class="params">(List&lt;Employee&gt; emps)</span></span>&#123;</span><br><span class="line">	List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Employee emp : emps) &#123;</span><br><span class="line">		<span class="keyword">if</span>(emp.getSalary() &gt;= <span class="number">5000</span>)&#123;</span><br><span class="line">			list.add(emp);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//又要写多一个方法，所以要优化</span></span><br></pre></td></tr></table></figure>

<p><strong>优化方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//优化方式一：策略设计模式，使用接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">filterEmployee</span><span class="params">(List&lt;Employee&gt; emps, MyPredicate&lt;Employee&gt; mp)</span></span>&#123;</span><br><span class="line">	List&lt;Employee&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Employee employee : emps) &#123;</span><br><span class="line">		<span class="keyword">if</span>(mp.test(employee))&#123;</span><br><span class="line">			list.add(employee);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//需求1，年龄小于 35</span></span><br><span class="line">	List&lt;Employee&gt; list = filterEmployee(emps, <span class="keyword">new</span> FilterEmployeeForAge());</span><br><span class="line">	<span class="keyword">for</span> (Employee employee : list) &#123;</span><br><span class="line">		System.out.println(employee);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"------------------------------------------"</span>);</span><br><span class="line">    <span class="comment">//需求2，工资大于 5000</span></span><br><span class="line">	List&lt;Employee&gt; list2 = filterEmployee(emps, <span class="keyword">new</span> FilterEmployeeForSalary());</span><br><span class="line">	<span class="keyword">for</span> (Employee employee : list2) &#123;</span><br><span class="line">		System.out.println(employee);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化方式二：匿名内部类，也是使用接口</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//需求1，年龄小于 35</span></span><br><span class="line">	List&lt;Employee&gt; list = filterEmployee(emps, <span class="keyword">new</span> MyPredicate&lt;Employee&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Employee t)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> t.getAge() &lt;= <span class="number">35</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="keyword">for</span> (Employee employee : list) &#123;</span><br><span class="line">		System.out.println(employee);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化方式三：Lambda 表达式</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//需求1，年龄小于 35</span></span><br><span class="line">	List&lt;Employee&gt; list = filterEmployee(emps, (e) -&gt; e.getAge() &lt;= <span class="number">35</span>);</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"------------------------------------------"</span>);</span><br><span class="line">    <span class="comment">//需求2，工资大于5000</span></span><br><span class="line">	List&lt;Employee&gt; list2 = filterEmployee(emps, (e) -&gt; e.getSalary() &gt;= <span class="number">5000</span>);</span><br><span class="line">	list2.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//优化方式四：Stream API，什么都不用，只要有数据</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//需求1，年龄小于 35</span></span><br><span class="line">	emps.stream()</span><br><span class="line">		.filter((e) -&gt; e.getAge() &lt;= <span class="number">35</span>)</span><br><span class="line">		.forEach(System.out::println);</span><br><span class="line">	System.out.println(<span class="string">"----------------------------------------------"</span>);</span><br><span class="line">    <span class="comment">//需求2，取出名字，排序sorted，limit前3个</span></span><br><span class="line">	emps.stream()</span><br><span class="line">		.map(Employee::getName)</span><br><span class="line">		.limit(<span class="number">3</span>)</span><br><span class="line">		.sorted()</span><br><span class="line">		.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Lambda表达式的基础介绍"><a href="#1-3-Lambda表达式的基础介绍" class="headerlink" title="1-3.Lambda表达式的基础介绍"></a>1-3.Lambda表达式的基础介绍</h3><p>​    Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符。箭头操作符将 Lambda 表达式拆分成两部分：</p>
<ul>
<li>左侧：Lambda 表达式的参数列表（接口中抽象方法）</li>
<li>右侧：Lambda 表达式中所需执行的功能， 即 Lambda体。（接口中抽象方法的实现）</li>
</ul>
<h3 id="1-4-基础语法"><a href="#1-4-基础语法" class="headerlink" title="1.4.基础语法"></a>1.4.基础语法</h3><ul>
<li>语法格式一：无参数，无返回值<ul>
<li>() -&gt; System.out.println(“Hello Lambda!”);</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//局部内部类中用了同级别的局部变量时，jdk 1.7 前，必须是 final</span></span><br><span class="line">	Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"Hello World!"</span> + num);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	r.run();</span><br><span class="line">	System.out.println(<span class="string">"-------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">	Runnable r1 = () -&gt; System.out.println(<span class="string">"Hello Lambda!"</span>+num);</span><br><span class="line">	r1.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>语法格式二：有一个参数，并且无返回值<ul>
<li>(x) -&gt; System.out.println(x)</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Consumer&lt;String&gt; con = x -&gt; System.out.println(x);</span><br><span class="line">    con.accept(<span class="string">"是是是"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>语法格式三：若只有一个参数，小括号可以省略不写<ul>
<li>x -&gt; System.out.println(x)</li>
</ul>
</li>
</ul>
<ul>
<li>语法格式四：有两个以上的参数，有返回值，并且 Lambda 体中有多条语句<ul>
<li>Comparator<Integer> com = (x, y) -&gt; {System.out.println(“函数式接口”);</Integer></li>
<li>return Integer.compare(x, y);</li>
<li>};</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Comparator&lt;Integer&gt; com = (x, y) -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">"函数式接口"</span>);</span><br><span class="line">	<span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>语法格式五：若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写<ul>
<li>Comparator<Integer> com = (x, y) -&gt; Integer.compare(x, y);</Integer></li>
</ul>
</li>
</ul>
<ul>
<li>语法格式六：Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断” <ul>
<li>(Integer x, Integer y) -&gt; Integer.compare(x, y);</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//类型推断</span></span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//类型推断</span></span><br><span class="line">    String[] strs = &#123;<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>&#125;;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    show(<span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>左右遇一括号省</li>
<li>左侧推断类型省</li>
<li>能省则省</li>
</ul>
<h2 id="2-Lambda-表达式需要“函数式接口”的支持"><a href="#2-Lambda-表达式需要“函数式接口”的支持" class="headerlink" title="2.Lambda 表达式需要“函数式接口”的支持"></a>2.Lambda 表达式需要“函数式接口”的支持</h2><ul>
<li>函数式接口：接口中只有一个抽象方法的接口，称为函数式接口。</li>
<li>可以通过 Lambda 表达式来创建该接口的对象。（若 Lambda表达式抛出一个受检异常，那么该异常需要在目标接口的抽象方法上进行声明）。</li>
<li>可以使用注解 @FunctionalInterface 修饰，可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">函数式接口中使用泛型</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFun</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    为了将  Lambda  表达式作为参数传递，接收 Lambda 该 表达式的参数类型必须是与该  Lambda  表达式兼容的函数式接口的类型。</p>
<p><strong>代码：</strong></p>
<p>接口，需求实现方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只能一个抽象方法，多余一个，报错</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFun</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">(Integer num)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：对一个数进行运算</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//对x进行平方</span></span><br><span class="line">    Integer num = operation(<span class="number">100</span>, (x) -&gt; x * x);</span><br><span class="line">    System.out.println(num);</span><br><span class="line">	<span class="comment">//对y进行加200操作</span></span><br><span class="line">    System.out.println(operation(<span class="number">200</span>, (y) -&gt; y + <span class="number">200</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法，调用接口</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">operation</span><span class="params">(Integer num, MyFun mf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mf.getValue(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>做习题：</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/2.png" alt="2"></p>
<p>1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数据添加</span></span><br><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">//方法，排序</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Collections.sort(emps, (e1, e2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(e1.getAge() == e2.getAge())&#123;</span><br><span class="line">            <span class="keyword">return</span> e1.getName().compareTo(e2.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> -Integer.compare(e1.getAge(), e2.getAge());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (Employee emp : emps) &#123;</span><br><span class="line">        System.out.println(emp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//去除空格</span></span><br><span class="line">    String trimStr = strHandler(<span class="string">"\t\t\t 啊啊啊   "</span>, (str) -&gt; str.trim());</span><br><span class="line">    System.out.println(trimStr);</span><br><span class="line">    <span class="comment">//转换大写</span></span><br><span class="line">    String upper = strHandler(<span class="string">"abcdef"</span>, (str) -&gt; str.toUpperCase());</span><br><span class="line">    System.out.println(upper);</span><br><span class="line">    <span class="comment">//截取字符</span></span><br><span class="line">    String newStr = strHandler(<span class="string">"啊啊啊"</span>, (str) -&gt; str.substring(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：用于处理字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, MyFunction mf)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mf.getValue(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFunction2</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> R <span class="title">getValue</span><span class="params">(T t1, T t2)</span></span>;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//相加</span></span><br><span class="line">    op(<span class="number">100L</span>, <span class="number">200L</span>, (x, y) -&gt; x + y);</span><br><span class="line">    <span class="comment">//相乘</span></span><br><span class="line">    op(<span class="number">100L</span>, <span class="number">200L</span>, (x, y) -&gt; x * y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：对于两个 Long 型数据进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">op</span><span class="params">(Long l1, Long l2, MyFunction2&lt;Long, Long&gt; mf)</span></span>&#123;</span><br><span class="line">    System.out.println(mf.getValue(l1, l2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Java提供接口"><a href="#2-2-Java提供接口" class="headerlink" title="2-2.Java提供接口"></a>2-2.Java提供接口</h3><p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/3.png" alt="3"></p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/4.png" alt="4"></p>
<p><strong>四大内置的四大核心函数式接口：</strong></p>
<ul>
<li>Consumer<T> : 消费型接口<ul>
<li>void accept(T t);</li>
</ul>
</T></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Consumer&lt;T&gt; 消费型接口 :</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    happy(<span class="number">10000</span>, (m) -&gt; System.out.println(<span class="string">"每次消费："</span> + m + <span class="string">"元"</span>));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">happy</span><span class="params">(<span class="keyword">double</span> money, Consumer&lt;Double&gt; con)</span></span>&#123;</span><br><span class="line">    con.accept(money);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Supplier<T> : 供给型接口<ul>
<li>T get(); </li>
</ul>
</T></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Supplier&lt;T&gt; 供给型接口 :</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; numList = getNumList(<span class="number">10</span>, () -&gt; (<span class="keyword">int</span>)(Math.random() * <span class="number">100</span>));</span><br><span class="line">    <span class="keyword">for</span> (Integer num : numList) &#123;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：产生指定个数的整数，并放入集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getNumList</span><span class="params">(<span class="keyword">int</span> num, Supplier&lt;Integer&gt; sup)</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        Integer n = sup.get();</span><br><span class="line">        list.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Function&lt;T, R&gt; : 函数型接口<ul>
<li>R apply(T t);</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Function&lt;T, R&gt; 函数型接口：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String newStr = strHandler(<span class="string">"\t\t\t 我大尚硅谷威武   "</span>, (str) -&gt; str.trim());</span><br><span class="line">    System.out.println(newStr);</span><br><span class="line"></span><br><span class="line">    String subStr = strHandler(<span class="string">"我大尚硅谷威武"</span>, (str) -&gt; str.substring(<span class="number">2</span>, <span class="number">5</span>));</span><br><span class="line">    System.out.println(subStr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：用于处理字符串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">strHandler</span><span class="params">(String str, Function&lt;String, String&gt; fun)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fun.apply(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Predicate<T> : 断言型接口<ul>
<li>boolean test(T t);</li>
</ul>
</T></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Predicate&lt;T&gt; 断言型接口：</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"Hello"</span>, <span class="string">"atguigu"</span>, <span class="string">"Lambda"</span>, <span class="string">"www"</span>, <span class="string">"ok"</span>);</span><br><span class="line">    List&lt;String&gt; strList = filterStr(list, (s) -&gt; s.length() &gt; <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需求：将满足条件的字符串，放入集合中</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">filterStr</span><span class="params">(List&lt;String&gt; list, Predicate&lt;String&gt; pre)</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pre.test(str))&#123;</span><br><span class="line">            strList.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> strList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-方法引用与构造器引用"><a href="#3-方法引用与构造器引用" class="headerlink" title="3.方法引用与构造器引用"></a>3.方法引用与构造器引用</h2><h3 id="3-1-方法引用"><a href="#3-1-方法引用" class="headerlink" title="3-1.方法引用"></a>3-1.方法引用</h3><p>​    若 Lambda 体中的功能，已经有方法提供了实现，可以使用方法引用（可以将方法引用理解为 Lambda 表达式的另外一种表现形式）</p>
<p>​    实现抽象方法的参数列表，必须与方法引用方法的参数列表保持一致.</p>
<p>​    方法引用：使用操作符 “ ::” 将方法名和对象或类的名字分隔开来。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PrintStream ps = System.out;</span><br><span class="line">    Consumer&lt;String&gt; con = (str) -&gt; ps.println(str);</span><br><span class="line">    con.accept(<span class="string">"Hello World！"</span>);</span><br><span class="line">    System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">    con2.accept(<span class="string">"Hello Java8！"</span>);</span><br><span class="line">    Consumer&lt;String&gt; con3 = System.out::println;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>方法引用所引用的方法的参数列表与返回值类型，需要与函数式接口中抽象方法的参数列表和返回值类型保持一致！</p>
<ul>
<li>若Lambda 的参数列表的第一个参数，是实例方法的调用者，第二个参数(或无参)是实例方法的参数时，格式： ClassName::MethodName</li>
</ul>
</li>
</ul>
<ul>
<li>对象的引用 :: 实例方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对象的引用 :: 实例方法名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Employee emp = <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>);</span><br><span class="line">    Supplier&lt;String&gt; sup = () -&gt; emp.getName();</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类名 :: 静态方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类名 :: 静态方法名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br><span class="line">    System.out.println(<span class="string">"-------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiFunction&lt;Double, Double, Double&gt; fun = (x, y) -&gt; Math.max(x, y);</span><br><span class="line">    System.out.println(fun.apply(<span class="number">1.5</span>, <span class="number">22.2</span>));</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    BiFunction&lt;Double, Double, Double&gt; fun2 = Math::max;</span><br><span class="line">    System.out.println(fun2.apply(<span class="number">1.2</span>, <span class="number">1.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类名 :: 实例方法名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类名 :: 实例方法名</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    BiPredicate&lt;String, String&gt; bp = (x, y) -&gt; x.equals(y);</span><br><span class="line">    System.out.println(bp.test(<span class="string">"abcde"</span>, <span class="string">"abcde"</span>));</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    BiPredicate&lt;String, String&gt; bp2 = String::equals;</span><br><span class="line">    System.out.println(bp2.test(<span class="string">"abc"</span>, <span class="string">"abc"</span>));</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Function&lt;Employee, String&gt; fun = (e) -&gt; e.show();</span><br><span class="line">    System.out.println(fun.apply(<span class="keyword">new</span> Employee()));</span><br><span class="line">    System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Employee, String&gt; fun2 = Employee::show;</span><br><span class="line">    System.out.println(fun2.apply(<span class="keyword">new</span> Employee()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-构造器引用"><a href="#3-2-构造器引用" class="headerlink" title="3-2.构造器引用"></a>3-2.构造器引用</h3><p>​    与函数式接口相结合，自动与函数式接口中方法兼容。可以把构造器引用赋值给定义的方法，与构造器参数列表要与接口中抽象方法的参数列表一致！</p>
<p>​    类名 :: new</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Function&lt;String, Employee&gt; fun = Employee::<span class="keyword">new</span>;</span><br><span class="line">    BiFunction&lt;String, Integer, Employee&gt; fun2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Supplier&lt;Employee&gt; sup = () -&gt; <span class="keyword">new</span> Employee();</span><br><span class="line">    System.out.println(sup.get());</span><br><span class="line">    System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt; sup2 = Employee::<span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-数组引用"><a href="#3-3-数组引用" class="headerlink" title="3-3.数组引用"></a>3-3.数组引用</h3><p>​    类型[] :: new;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组引用</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Function&lt;Integer, String[]&gt; fun = (args) -&gt; <span class="keyword">new</span> String[args];</span><br><span class="line">    String[] strs = fun.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(strs.length);</span><br><span class="line">    System.out.println(<span class="string">"--------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer, Employee[]&gt; fun2 = Employee[] :: <span class="keyword">new</span>;</span><br><span class="line">    Employee[] emps = fun2.apply(<span class="number">20</span>);</span><br><span class="line">    System.out.println(emps.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-Stream-API"><a href="#4-Stream-API" class="headerlink" title="4.Stream API"></a>4.Stream API</h2><p>​    Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。使用Stream API 对集合数据进行操作，就类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简而言之，Stream API 提供了一种高效且易于使用的处理数据的方式。</p>
<p>​    流 (Stream)  是数据渠道，用于操作数据源（集合、数组等）所生成的元素序列。</p>
<p>​    集合讲的是数据，流讲的是计算</p>
<p><strong>注意：</strong></p>
<ul>
<li>Stream 自己不会存储元素。</li>
<li>Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream。</li>
<li>Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行。</li>
</ul>
<h3 id="4-1-Stream-的操作三个步骤"><a href="#4-1-Stream-的操作三个步骤" class="headerlink" title="4-1.Stream  的操作三个步骤"></a>4-1.Stream  的操作三个步骤</h3><ul>
<li>创建  Stream<br>一个数据源（如：集合、数组），获取一个流</li>
<li>中间操作<br>一个中间操作链，对数据源的数据进行处理</li>
<li>终止操作( ( 终端操作) )<br>一个终止操作，执行中间操作链，并产生结果</li>
</ul>
<h3 id="4-2-创建-Stream"><a href="#4-2-创建-Stream" class="headerlink" title="4-2.创建  Stream"></a>4-2.创建  Stream</h3><ul>
<li>Java8 中的 Collection 接口被扩展，提供了两个获取流的方法 ：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> : 返回一个顺序流</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">parallelStream</span><span class="params">()</span> : 返回一个并行流</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Java8 中的 Arrays 的静态方法 stream() 可以获取数组流<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(T[] array)</span>: 返回一个流</span></span><br></pre></td></tr></table></figure>
<ul>
<li>重载形式，能够处理对应基本类型的数组</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IntStream <span class="title">stream</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LongStream <span class="title">stream</span><span class="params">(<span class="keyword">long</span>[] array)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleStream <span class="title">stream</span><span class="params">(<span class="keyword">double</span>[] array)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用静态方法 Stream.of(), 通过显示值创建一个流。它可以接收任意数量的参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">of</span><span class="params">(T... values)</span> : 返回一个流</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以使用静态方法 Stream.iterate() 和Stream.generate(), 创建无限流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//迭代</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">iterate</span><span class="params">(<span class="keyword">final</span> T seed, <span class="keyword">final</span> UnaryOperator&lt;T&gt; f)</span></span></span><br><span class="line"><span class="function"><span class="comment">//生成</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>&lt;T&gt; Stream&lt;T&gt; <span class="title">generate</span><span class="params">(Supplier&lt;T&gt; s)</span> :</span></span><br></pre></td></tr></table></figure>

<p><strong>例子： Collection 接口，由数组创建流，由值创建流，由函数创建流：创建无限流</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建 Stream</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1. Collection 提供了两个方法  stream() 与 parallelStream()</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stream = list.stream(); <span class="comment">//获取一个顺序流</span></span><br><span class="line">    Stream&lt;String&gt; parallelStream = list.parallelStream(); <span class="comment">//获取一个并行流</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 通过 Arrays 中的 stream() 获取一个数组流</span></span><br><span class="line">    Integer[] nums = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">    Stream&lt;Integer&gt; stream1 = Arrays.stream(nums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 通过 Stream 类中静态方法 of()</span></span><br><span class="line">    Stream&lt;Integer&gt; stream2 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. 创建无限流</span></span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    Stream&lt;Integer&gt; stream3 = Stream.iterate(<span class="number">0</span>, (x) -&gt; x + <span class="number">2</span>).limit(<span class="number">10</span>);</span><br><span class="line">    stream3.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成</span></span><br><span class="line">    Stream&lt;Double&gt; stream4 = Stream.generate(Math::random).limit(<span class="number">2</span>);</span><br><span class="line">    stream4.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Stream-的中间操作"><a href="#4-3-Stream-的中间操作" class="headerlink" title="4-3.Stream 的中间操作"></a>4-3.Stream 的中间操作</h3><p>​    多个 中间操作可以连接起来形成一个 流水线，除非流水线上触发终止操作，否则 中间操作不会执行任何的处理。</p>
<p>​    而在终止操作时一次性全部 处理，称为“惰性求值”</p>
<p><strong>方法：筛选与切片，映射，排序</strong></p>
<p>筛选与切片</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/5.png" alt="5"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. 中间操作</span></span><br><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	筛选与切片</span></span><br><span class="line"><span class="comment">	filter——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line"><span class="comment">	limit——截断流，使其元素不超过给定数量。</span></span><br><span class="line"><span class="comment">	skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line"><span class="comment">	distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素（要在实体类里重写方法 hashCode() 和 equals()）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">	</span><br><span class="line"><span class="comment">//内部迭代：迭代操作 Stream API 内部完成</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//所有的中间操作不会做任何的处理</span></span><br><span class="line">    Stream&lt;Employee&gt; stream = emps.stream()</span><br><span class="line">        .filter((e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试中间操作"</span>);</span><br><span class="line">            <span class="keyword">return</span> e.getAge() &lt;= <span class="number">35</span>;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有当做终止操作时，所有的中间操作会一次性的全部执行，称为“惰性求值”</span></span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外部迭代</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Iterator&lt;Employee&gt; it = emps.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        System.out.println(it.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//filter——接收 Lambda ， 从流中排除某些元素。</span></span><br><span class="line"><span class="comment">//limit——截断流，使其元素不超过给定数量。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    emps.stream()</span><br><span class="line">        .filter((e) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"短路！"</span>); <span class="comment">// &amp;&amp;  ||</span></span><br><span class="line">            <span class="keyword">return</span> e.getSalary() &gt;= <span class="number">5000</span>;</span><br><span class="line">        &#125;).limit(<span class="number">3</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    emps.parallelStream()</span><br><span class="line">        .filter((e) -&gt; e.getSalary() &gt;= <span class="number">5000</span>)</span><br><span class="line">        .skip(<span class="number">2</span>)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//distinct——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line"><span class="comment">//要在实体类里重写方法 hashCode() 和 equals()</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    emps.stream()</span><br><span class="line">        .distinct()</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>映射</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/6.png" alt="6"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	映射</span></span><br><span class="line"><span class="comment">	map——接收 Lambda ， 将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。</span></span><br><span class="line"><span class="comment">	flatMap——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line"><span class="comment">	类似add（Object ob），addAll（Collection coll）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stream&lt;String&gt; str = emps.stream()</span><br><span class="line">        .map((e) -&gt; e.getName());</span><br><span class="line">    System.out.println(<span class="string">"-------------------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; strList = Arrays.asList(<span class="string">"aaa"</span>, <span class="string">"bbb"</span>, <span class="string">"ccc"</span>, <span class="string">"ddd"</span>, <span class="string">"eee"</span>);</span><br><span class="line">    Stream&lt;String&gt; stream = strList.stream()</span><br><span class="line">        .map(String::toUpperCase);</span><br><span class="line">    stream.forEach(System.out::println);</span><br><span class="line">	<span class="comment">//map	使用方法filterCharacter</span></span><br><span class="line">    Stream&lt;Stream&lt;Character&gt;&gt; stream2 = strList.stream()</span><br><span class="line">        .map(TestStreamAPI1::filterCharacter);</span><br><span class="line">    <span class="comment">//&#123;a，a，a&#125;，&#123;b，b，b&#125;，流放在流中</span></span><br><span class="line">    stream2.forEach((sm) -&gt; &#123;</span><br><span class="line">        sm.forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"---------------------------------------------"</span>);</span><br><span class="line">	<span class="comment">//flatMap	使用方法filterCharacter</span></span><br><span class="line">    Stream&lt;Character&gt; stream3 = strList.stream()</span><br><span class="line">        .flatMap(TestStreamAPI1::filterCharacter);</span><br><span class="line">    <span class="comment">//a，a，a，b，b，b,元素放在流中</span></span><br><span class="line">    stream3.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//Str转字符串数组</span></span><br><span class="line">    <span class="keyword">for</span> (Character ch : str.toCharArray()) &#123;</span><br><span class="line">        list.add(ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排序</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/7.png" alt="7"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	sorted()——自然排序（Comparable）</span></span><br><span class="line"><span class="comment">	sorted(Comparator com)——定制排序（Compatator）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//对名字排序</span></span><br><span class="line">	emps.stream()</span><br><span class="line">		.map(Employee::getName)</span><br><span class="line">		.sorted()</span><br><span class="line">		.forEach(System.out::println);</span><br><span class="line">	System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">	<span class="comment">//对年龄和名字进行排序</span></span><br><span class="line">	emps.stream()</span><br><span class="line">		.sorted((x, y) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(x.getAge() == y.getAge())&#123;</span><br><span class="line">				<span class="keyword">return</span> x.getName().compareTo(y.getName());</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> Integer.compare(x.getAge(), y.getAge());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-4-Stream-的终止操作"><a href="#4-4-Stream-的终止操作" class="headerlink" title="4-4.Stream 的终止操作"></a>4-4.Stream 的终止操作</h3><p>​    操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void</p>
<p><strong>方法：</strong></p>
<p>查找与匹配</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/8.png" alt="8"></p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/9.png" alt="9"></p>
<p><strong>实体类加个方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> salary;</span><br><span class="line">	<span class="keyword">private</span> Status status;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Status &#123;</span><br><span class="line">		FREE, BUSY, VOCATION;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStreamAPI2</span> </span>&#123;</span><br><span class="line">	List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line">			<span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>, Status.BUSY),</span><br><span class="line">			<span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>, Status.FREE),</span><br><span class="line">			<span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>, Status.VOCATION),</span><br><span class="line">			<span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.BUSY),</span><br><span class="line">			<span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line">			<span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line">			<span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>, Status.BUSY)</span><br><span class="line">	);</span><br><span class="line">	<span class="comment">//3. 终止操作</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		allMatch——检查是否匹配所有元素</span></span><br><span class="line"><span class="comment">		anyMatch——检查是否至少匹配一个元素</span></span><br><span class="line"><span class="comment">		noneMatch——检查是否没有匹配的元素</span></span><br><span class="line"><span class="comment">		findFirst——返回第一个元素</span></span><br><span class="line"><span class="comment">		findAny——返回当前流中的任意元素</span></span><br><span class="line"><span class="comment">		count——返回流中元素的总个数</span></span><br><span class="line"><span class="comment">		max——返回流中最大值</span></span><br><span class="line"><span class="comment">		min——返回流中最小值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//allMatch——检查是否匹配所有元素</span></span><br><span class="line">        <span class="keyword">boolean</span> bl = emps.stream()</span><br><span class="line">            .allMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">        System.out.println(bl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//anyMatch——检查是否至少匹配一个元素</span></span><br><span class="line">        <span class="keyword">boolean</span> bl1 = emps.stream()</span><br><span class="line">            .anyMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">        System.out.println(bl1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//noneMatch——检查是否没有匹配的元素</span></span><br><span class="line">        <span class="keyword">boolean</span> bl2 = emps.stream()</span><br><span class="line">            .noneMatch((e) -&gt; e.getStatus().equals(Status.BUSY));</span><br><span class="line">        System.out.println(bl2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//findFirst——返回第一个元素</span></span><br><span class="line">		<span class="comment">//对工资进行排序，找第一个，有可能没有数据，没有第一个</span></span><br><span class="line">		<span class="comment">//Optional，避免空指针异常，容器类，有个orElse方法，对象为空，找个替代的对象</span></span><br><span class="line">		Optional&lt;Employee&gt; op = emps.stream()</span><br><span class="line">			.sorted((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()))</span><br><span class="line">			.findFirst();</span><br><span class="line">		System.out.println(op.get());</span><br><span class="line">		System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//findAny——返回当前流中的任意元素</span></span><br><span class="line">		Optional&lt;Employee&gt; op2 = emps.parallelStream()</span><br><span class="line">            .filter((e) -&gt; e.getStatus().equals(Status.FREE))</span><br><span class="line">            .findAny();</span><br><span class="line">		System.out.println(op2.get());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//count——返回流中元素的总个数</span></span><br><span class="line">		<span class="keyword">long</span> count = emps.stream()</span><br><span class="line">            .filter((e) -&gt; e.getStatus().equals(Status.FREE))</span><br><span class="line">            .count();</span><br><span class="line">		System.out.println(count);</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//max——返回流中最大值</span></span><br><span class="line">		Optional&lt;Double&gt; op = emps.stream()</span><br><span class="line">            .map(Employee::getSalary)</span><br><span class="line">            .max(Double::compare);</span><br><span class="line">		System.out.println(op.get());</span><br><span class="line">        </span><br><span class="line">		<span class="comment">//min——返回流中最小值</span></span><br><span class="line">		Optional&lt;Employee&gt; op2 = emps.stream()</span><br><span class="line">            .min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">		System.out.println(op2.get());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注意：流进行了终止操作后，不能再次使用</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//查找FREE</span></span><br><span class="line">		Stream&lt;Employee&gt; stream = emps.stream()</span><br><span class="line">		 .filter((e) -&gt; e.getStatus().equals(Status.FREE));</span><br><span class="line">        <span class="comment">//统计总数</span></span><br><span class="line">		<span class="keyword">long</span> count = stream.count();</span><br><span class="line">		<span class="comment">//提取getSalary，找工资最大值</span></span><br><span class="line">		stream.map(Employee::getSalary)</span><br><span class="line">			.max(Double::compare);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归约：：map 和 reduce 的连接通常称为 map-reduce 模式</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/10.png" alt="10"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	归约</span></span><br><span class="line"><span class="comment">	reduce(T identity, BinaryOperator)</span></span><br><span class="line"><span class="comment">	reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">	<span class="comment">//sum，累加</span></span><br><span class="line">	Integer sum = list.stream()</span><br><span class="line">		.reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">	System.out.println(<span class="string">"----------------------------------------"</span>);</span><br><span class="line">	<span class="comment">//提取工资，累加</span></span><br><span class="line">	Optional&lt;Double&gt; op = emps.stream()</span><br><span class="line">		.map(Employee::getSalary)</span><br><span class="line">		.reduce(Double::sum);</span><br><span class="line">	System.out.println(op.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//收集的例子</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Optional&lt;Double&gt; sum = emps.stream()</span><br><span class="line">		.map(Employee::getSalary)</span><br><span class="line">		.collect(Collectors.reducing(Double::sum));</span><br><span class="line">	System.out.println(sum.get());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：搜索名字中 “六” 出现的次数</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Optional&lt;Integer&gt; sum = emps.stream()</span><br><span class="line">		.map(Employee::getName)</span><br><span class="line">		.flatMap(TestStreamAPI1::filterCharacter)</span><br><span class="line">		.map((ch) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(ch.equals(<span class="string">'六'</span>))</span><br><span class="line">				<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;).reduce(Integer::sum);</span><br><span class="line">	</span><br><span class="line">	System.out.println(sum.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>收集</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/11.png" alt="11"></p>
<ul>
<li>Collector 接口中方法的实现决定了如何对流执行收集操作(如收集到 List、Set、Map)。但是 Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例，</li>
</ul>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/12.png" alt="12"></p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/13.png" alt="13"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//collect——将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//元素收集到list</span></span><br><span class="line">	List&lt;String&gt; list = emps.stream()</span><br><span class="line">        .map(Employee::getName)</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">	list.forEach(System.out::println);</span><br><span class="line">	System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//元素收集到set</span></span><br><span class="line">	Set&lt;String&gt; set = emps.stream()</span><br><span class="line">		.map(Employee::getName)</span><br><span class="line">		.collect(Collectors.toSet());</span><br><span class="line">	set.forEach(System.out::println);</span><br><span class="line">	System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//元素收集到HashSet</span></span><br><span class="line">	HashSet&lt;String&gt; hs = emps.stream()</span><br><span class="line">		.map(Employee::getName)</span><br><span class="line">		.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));	</span><br><span class="line">	hs.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//最大值</span></span><br><span class="line">	Optional&lt;Double&gt; min = emps.stream()</span><br><span class="line">		.map(Employee::getSalary)</span><br><span class="line">		.collect(Collectors.minBy(Double::compare));</span><br><span class="line">	System.out.println(min.get());</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//最小值</span></span><br><span class="line">	Optional&lt;Employee&gt; max = emps.stream()</span><br><span class="line">		.collect(Collectors.maxBy((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary())));</span><br><span class="line">	System.out.println(max.get());</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//总和</span></span><br><span class="line">	Double sum = emps.stream()</span><br><span class="line">		.collect(Collectors.summingDouble(Employee::getSalary));</span><br><span class="line">	System.out.println(sum);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//平均值</span></span><br><span class="line">	Double avg = emps.stream()</span><br><span class="line">		.collect(Collectors.averagingDouble(Employee::getSalary));</span><br><span class="line">	System.out.println(avg);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//总数</span></span><br><span class="line">	Long count = emps.stream()</span><br><span class="line">		.collect(Collectors.counting());</span><br><span class="line">	System.out.println(count);</span><br><span class="line">	</span><br><span class="line">	System.out.println(<span class="string">"--------------------------------------------"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//一次性得到要搞该元素的个数、总和、均值、最大值、最小值</span></span><br><span class="line">	DoubleSummaryStatistics dss = emps.stream()</span><br><span class="line">        .collect(Collectors.summarizingDouble(Employee::getSalary));</span><br><span class="line">	System.out.println(dss);</span><br><span class="line">	System.out.println(dss.getMax());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Map&lt;Status, List&lt;Employee&gt;&gt; map = emps.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Employee::getStatus));</span><br><span class="line">	System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多级分组</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; map = emps.stream()</span><br><span class="line">        .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy((e) -&gt; &#123;</span><br><span class="line">			<span class="keyword">if</span>(e.getAge() &gt;= <span class="number">60</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"老年"</span>;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(e.getAge() &gt;= <span class="number">35</span>)</span><br><span class="line">				<span class="keyword">return</span> <span class="string">"中年"</span>;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">return</span> <span class="string">"成年"</span>;</span><br><span class="line">		&#125;)));</span><br><span class="line">	System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分区，对或错</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">	Map&lt;Boolean, List&lt;Employee&gt;&gt; map = emps.stream()</span><br><span class="line">        .collect(Collectors.partitioningBy((e) -&gt; e.getSalary() &gt;= <span class="number">5000</span>));</span><br><span class="line">	System.out.println(map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串加，首尾加"----"</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">	String str = emps.stream()</span><br><span class="line">        .map(Employee::getName)</span><br><span class="line">        .collect(Collectors.joining(<span class="string">","</span> , <span class="string">"----"</span>, <span class="string">"----"</span>));</span><br><span class="line">	System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-练习题"><a href="#4-5-练习题" class="headerlink" title="4-5.练习题"></a>4-5.练习题</h3><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a><strong>Stream</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1.	给定一个数字列表，如何返回一个由每个数的平方构成的列表呢？</span></span><br><span class="line"><span class="comment">		给定【1，2，3，4，5】， 应该返回【1，4，9，16，25】。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Integer[] nums = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    Arrays.stream(nums)</span><br><span class="line">        .map((x) -&gt; x * x)</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	 2.	怎样用 map 和 reduce 方法数一数流中有多少个Employee呢？</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Employee&gt; emps = Arrays.asList(</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">102</span>, <span class="string">"李四"</span>, <span class="number">59</span>, <span class="number">6666.66</span>, Status.BUSY),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>, Status.FREE),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">103</span>, <span class="string">"王五"</span>, <span class="number">28</span>, <span class="number">3333.33</span>, Status.VOCATION),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.BUSY),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">104</span>, <span class="string">"赵六"</span>, <span class="number">8</span>, <span class="number">7777.77</span>, Status.FREE),</span><br><span class="line">    <span class="keyword">new</span> Employee(<span class="number">105</span>, <span class="string">"田七"</span>, <span class="number">38</span>, <span class="number">5555.55</span>, Status.BUSY)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;Integer&gt; count = emps.stream()</span><br><span class="line">        .map((e) -&gt; <span class="number">1</span>)</span><br><span class="line">        .reduce(Integer::sum);</span><br><span class="line">    System.out.println(count.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="综合例子：实体类，解决问题类"><a href="#综合例子：实体类，解决问题类" class="headerlink" title="综合例子：实体类，解决问题类"></a><strong>综合例子：实体类，解决问题类</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交易员类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trader</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> String city;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//交易类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Trader trader;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> year;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTransaction</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	List&lt;Transaction&gt; transactions = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Before</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Trader raoul = <span class="keyword">new</span> Trader(<span class="string">"Raoul"</span>, <span class="string">"Cambridge"</span>);</span><br><span class="line">		Trader mario = <span class="keyword">new</span> Trader(<span class="string">"Mario"</span>, <span class="string">"Milan"</span>);</span><br><span class="line">		Trader alan = <span class="keyword">new</span> Trader(<span class="string">"Alan"</span>, <span class="string">"Cambridge"</span>);</span><br><span class="line">		Trader brian = <span class="keyword">new</span> Trader(<span class="string">"Brian"</span>, <span class="string">"Cambridge"</span>);</span><br><span class="line">		transactions = Arrays.asList(</span><br><span class="line">				<span class="keyword">new</span> Transaction(brian, <span class="number">2011</span>, <span class="number">300</span>),</span><br><span class="line">				<span class="keyword">new</span> Transaction(raoul, <span class="number">2012</span>, <span class="number">1000</span>),</span><br><span class="line">				<span class="keyword">new</span> Transaction(raoul, <span class="number">2011</span>, <span class="number">400</span>),</span><br><span class="line">				<span class="keyword">new</span> Transaction(mario, <span class="number">2012</span>, <span class="number">710</span>),</span><br><span class="line">				<span class="keyword">new</span> Transaction(mario, <span class="number">2012</span>, <span class="number">700</span>),</span><br><span class="line">				<span class="keyword">new</span> Transaction(alan, <span class="number">2012</span>, <span class="number">950</span>)</span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//1. 找出2011年发生的所有交易， 并按交易额排序（从低到高）</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		transactions.stream()</span><br><span class="line">            .filter((t) -&gt; t.getYear() == <span class="number">2011</span>)</span><br><span class="line">            .sorted((t1, t2) -&gt; Integer.compare(t1.getValue(), t2.getValue()))</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2. 交易员都在哪些不同的城市工作过？</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		transactions.stream()</span><br><span class="line">            .map((t) -&gt; t.getTrader().getCity())</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//3. 查找所有来自剑桥的交易员，并按姓名排序</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		transactions.stream()</span><br><span class="line">            .filter((t) -&gt; t.getTrader().getCity().equals(<span class="string">"Cambridge"</span>))</span><br><span class="line">            .map(Transaction::getTrader)</span><br><span class="line">            .sorted((t1, t2) -&gt; t1.getName().compareTo(t2.getName()))</span><br><span class="line">            .distinct()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//4. 返回所有交易员的姓名字符串，按字母顺序排序</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">		transactions.stream()</span><br><span class="line">            .map((t) -&gt; t.getTrader().getName())</span><br><span class="line">            .sorted()</span><br><span class="line">            .forEach(System.out::println);</span><br><span class="line">		System.out.println(<span class="string">"-----------------------------------"</span>);</span><br><span class="line">		<span class="comment">//String的排序</span></span><br><span class="line">		String str = transactions.stream()</span><br><span class="line">            .map((t) -&gt; t.getTrader().getName())</span><br><span class="line">            .sorted()</span><br><span class="line">            .reduce(<span class="string">""</span>, String::concat);</span><br><span class="line">		System.out.println(str);</span><br><span class="line">		System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">		<span class="comment">//按字母大小写排序,调用方法</span></span><br><span class="line">		transactions.stream()</span><br><span class="line">            .map((t) -&gt; t.getTrader().getName())</span><br><span class="line">            .flatMap(TestTransaction::filterCharacter)</span><br><span class="line">            .sorted((s1, s2) -&gt; s1.compareToIgnoreCase(s2))</span><br><span class="line">            .forEach(System.out::print);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;String&gt; <span class="title">filterCharacter</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (Character ch : str.toCharArray()) &#123;</span><br><span class="line">			list.add(ch.toString());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> list.stream();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5. 有没有交易员是在米兰工作的？</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">boolean</span> bl = transactions.stream()</span><br><span class="line">            .anyMatch((t) -&gt; t.getTrader().getCity().equals(<span class="string">"Milan"</span>));</span><br><span class="line">		System.out.println(bl);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//6. 打印生活在剑桥的交易员的所有交易额</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Optional&lt;Integer&gt; sum = transactions.stream()</span><br><span class="line">            .filter((e) -&gt; e.getTrader().getCity().equals(<span class="string">"Cambridge"</span>))</span><br><span class="line">            .map(Transaction::getValue)</span><br><span class="line">            .reduce(Integer::sum);</span><br><span class="line">		System.out.println(sum.get());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//7. 所有交易中，最高的交易额是多少</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Optional&lt;Integer&gt; max = transactions.stream()</span><br><span class="line">            .map((t) -&gt; t.getValue())</span><br><span class="line">            .max(Integer::compare);</span><br><span class="line">		System.out.println(max.get());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//8. 找到交易额最小的交易</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test8</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Optional&lt;Transaction&gt; op = transactions.stream()</span><br><span class="line">            .min((t1, t2) -&gt; Integer.compare(t1.getValue(), t2.getValue()));</span><br><span class="line">		System.out.println(op.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-并行流与串行流"><a href="#5-并行流与串行流" class="headerlink" title="5.并行流与串行流"></a>5.并行流与串行流</h2><p>​    并行流，是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。</p>
<p>​    Java 8 中将并行进行了优化，对数据进行并行操作。Stream API 可以声明性地通过 parallel() 与<br>sequential() 在并行流与顺序流之间进行切换。</p>
<h3 id="Fork-Join-框架"><a href="#Fork-Join-框架" class="headerlink" title="Fork/Join 框架"></a>Fork/Join 框架</h3><p>​    Fork/Join  框架：就是在必要的情况下，将一个大任务，进行拆分(fork)成若干个小任务（拆到不可再拆时），再将一个个的小任务运算的结果进行 join 汇总.</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/14.png" alt="14"></p>
<h3 id="Fork-Join-框架与传统线程池的区别"><a href="#Fork-Join-框架与传统线程池的区别" class="headerlink" title="Fork/Join 框架与传统线程池的区别"></a>Fork/Join 框架与传统线程池的区别</h3><p>采用 “工作窃取”模式（work-stealing）：</p>
<p>​    当执行新的任务时它可以将其拆分分成更小的任务执行，并将小任务加到线程队列中，然后再从一个随机线程的队列中偷一个并把它放在自己的队列中。</p>
<p>​    相对于一般的线程池实现，fork/join框架的优势体现在对其中包含的任务的处理方式上。在一般的线程池中，如果一个线程正在执行的任务由于某些原因无法继续运行，那么该线程会处于等待状态。</p>
<p>​    而在fork/join框架实现中，如果某个子问题由于等待另外一个子问题的完成而无法继续运行。那么处理该子问题的线程会主动寻找其他尚未运行的子问题来执行，这种方式减少了线程的等待时间,提高了性能 。</p>
<p><strong>ForkJoin框架</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinCalculate</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 序列化</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">13475679780L</span>;</span><br><span class="line">	<span class="comment">//拆分</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">	<span class="comment">//临界值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> THRESHOLD = <span class="number">10000L</span>; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ForkJoinCalculate</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.start = start;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> length = end - start;</span><br><span class="line">		<span class="comment">//到临界值不能再拆</span></span><br><span class="line">		<span class="keyword">if</span>(length &lt;= THRESHOLD)&#123;</span><br><span class="line">			<span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">				sum += i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> sum;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//递归拆</span></span><br><span class="line">			<span class="keyword">long</span> middle = (start + end) / <span class="number">2</span>;</span><br><span class="line">			ForkJoinCalculate left = <span class="keyword">new</span> ForkJoinCalculate(start, middle);</span><br><span class="line">			left.fork(); </span><br><span class="line">			<span class="comment">//拆分，并将该子任务压入线程队列</span></span><br><span class="line">			ForkJoinCalculate right = <span class="keyword">new</span> ForkJoinCalculate(middle+<span class="number">1</span>, end);</span><br><span class="line">			right.fork();</span><br><span class="line">			<span class="comment">//合并，累加总和</span></span><br><span class="line">			<span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestForkJoin</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*	ForkJoin框架</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">//线程池支持</span></span><br><span class="line">		ForkJoinPool pool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">		ForkJoinTask&lt;Long&gt; task = <span class="keyword">new</span> ForkJoinCalculate(<span class="number">0L</span>, <span class="number">10000000000L</span>);</span><br><span class="line">		<span class="keyword">long</span> sum = pool.invoke(task);</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();	</span><br><span class="line">		System.out.println(<span class="string">"耗费的时间为: "</span> + (end - start)); </span><br><span class="line">        <span class="comment">//112-1953-1988-2654-2647-20663-113808</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*	普通for</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0L</span>; i &lt;= <span class="number">10000000000L</span>; i++) &#123;</span><br><span class="line">			sum += i;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"耗费的时间为: "</span> + (end - start)); </span><br><span class="line">        <span class="comment">//34-3174-3132-4227-4223-31583</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	*	java8并行流</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">		<span class="comment">//reduce（0，Long::sum）顺序流</span></span><br><span class="line">		Long sum = LongStream.rangeClosed(<span class="number">0L</span>, <span class="number">10000000000L</span>)</span><br><span class="line">							 .parallel()</span><br><span class="line">							 .sum();</span><br><span class="line">		System.out.println(sum);</span><br><span class="line">		<span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">"耗费的时间为: "</span> + (end - start)); </span><br><span class="line">        <span class="comment">//2061-2053-2086-18926</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-Optional-类"><a href="#6-Optional-类" class="headerlink" title="6.Optional 类"></a>6.Optional 类</h2><p>​    Optional<T> 类(java.util.Optional) 是一个容器类，代表一个值存在或不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念。并且可以避免空指针异常。</T></p>
<p><strong>常用方法：</strong></p>
<table>
<thead>
<tr>
<th><strong>Optional.ofNullable(T t)</strong></th>
<th><strong>若 t 不为 null,创建 Optional 实例,否则创建空实例</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Optional.of(T t)</strong></td>
<td><strong>创建一个 Optional 实例</strong></td>
</tr>
<tr>
<td><strong>Optional.empty()</strong></td>
<td><strong>创建一个空的 Optional 实例</strong></td>
</tr>
<tr>
<td><strong>isPresent()</strong></td>
<td><strong>判断是否包含值</strong></td>
</tr>
<tr>
<td><strong>orElse(T t)</strong></td>
<td><strong>如果调用对象包含值，返回该值，否则返回t</strong></td>
</tr>
<tr>
<td><strong>orElseGet(Supplier s)</strong></td>
<td><strong>如果调用对象包含值，返回该值，否则返回 s 获取的值</strong></td>
</tr>
<tr>
<td><strong>map(Function f)</strong></td>
<td><strong>如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()</strong></td>
</tr>
<tr>
<td><strong>flatMap(Function mapper)</strong></td>
<td><strong>与 map 类似，要求返回值必须是Optional</strong></td>
</tr>
</tbody></table>
<p><strong>Optional 容器类：用于尽量避免空指针异常</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	Optional.of(T t) : 创建一个 Optional 实例</span></span><br><span class="line"><span class="comment"> * 	Optional.empty() : 创建一个空的 Optional 实例</span></span><br><span class="line"><span class="comment"> * 	Optional.ofNullable(T t):若 t 不为 null,创建 Optional 实例,否则创建空实例</span></span><br><span class="line"><span class="comment"> * 	isPresent() : 判断是否包含值</span></span><br><span class="line"><span class="comment"> * 	orElse(T t) :  如果调用对象包含值，返回该值，否则返回t</span></span><br><span class="line"><span class="comment"> * 	orElseGet(Supplier s) :如果调用对象包含值，返回该值，否则返回 s 获取的值</span></span><br><span class="line"><span class="comment"> * 	map(Function f): 如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()</span></span><br><span class="line"><span class="comment"> * 	flatMap(Function mapper):与 map 类似，要求返回值必须是Optional</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOptional</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Optional&lt;Employee&gt; op = Optional.of(<span class="keyword">new</span> Employee(<span class="number">101</span>, <span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">9999.99</span>));</span><br><span class="line">		<span class="comment">//如果有值对其处理，并返回处理后的Optional，否则返回 Optional.empty()</span></span><br><span class="line">		Optional&lt;String&gt; op2 = op.map(Employee::getName);</span><br><span class="line">		System.out.println(op2.get());</span><br><span class="line">		<span class="comment">//与 map 类似，要求返回值必须是Optional</span></span><br><span class="line">		Optional&lt;String&gt; op3 = op.flatMap((e) -&gt; Optional.of(e.getName()));</span><br><span class="line">		System.out.println(op3.get());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//若 t 不为 null,创建 Optional 实例,否则创建空实例</span></span><br><span class="line">		Optional&lt;Employee&gt; op = Optional.ofNullable(<span class="keyword">new</span> Employee());</span><br><span class="line">		<span class="comment">//判断是否包含值</span></span><br><span class="line">		<span class="keyword">if</span>(op.isPresent())&#123;</span><br><span class="line">			System.out.println(op.get());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果调用对象包含值，返回该值，否则返回t</span></span><br><span class="line">		Employee emp = op.orElse(<span class="keyword">new</span> Employee(<span class="string">"张三"</span>));</span><br><span class="line">		System.out.println(emp);</span><br><span class="line">		<span class="comment">//如果调用对象包含值，返回该值，否则返回 s 获取的值</span></span><br><span class="line">		Employee emp2 = op.orElseGet(() -&gt; <span class="keyword">new</span> Employee());</span><br><span class="line">		System.out.println(emp2);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		Optional&lt;Employee&gt; op2 = Optional.ofNullable(<span class="keyword">null</span>);</span><br><span class="line">		<span class="comment">//报错</span></span><br><span class="line">		System.out.println(op2.get());</span><br><span class="line">		<span class="comment">//创建一个空的 Optional 实例</span></span><br><span class="line">		Optional&lt;Employee&gt; op = Optional.empty();</span><br><span class="line">		<span class="comment">//报错</span></span><br><span class="line">		System.out.println(op.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建一个 Optional 实例</span></span><br><span class="line">		<span class="comment">//报错</span></span><br><span class="line">		<span class="comment">//Optional&lt;Employee&gt; op = Optional.of(null);</span></span><br><span class="line">		Optional&lt;Employee&gt; op = Optional.of(<span class="keyword">new</span> Employee());</span><br><span class="line">		Employee emp = op.get();</span><br><span class="line">		System.out.println(emp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>例题：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Godness god;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Godness</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//注意：Optional 不能被序列化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewMan</span> </span>&#123;</span><br><span class="line">	<span class="comment">//有对象在</span></span><br><span class="line">	<span class="keyword">private</span> Optional&lt;Godness&gt; godness = Optional.empty();</span><br><span class="line">	<span class="keyword">private</span> Godness god;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Man man = <span class="keyword">new</span> Man();</span><br><span class="line">    String name = getGodnessName(man);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需求：获取一个男人心中女神的名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGodnessName</span><span class="params">(Man man)</span></span>&#123;</span><br><span class="line">    <span class="comment">//避免空指针异常</span></span><br><span class="line">    <span class="keyword">if</span>(man != <span class="keyword">null</span>)&#123;</span><br><span class="line">        Godness g = man.getGod();</span><br><span class="line">       <span class="keyword">if</span>(g != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> g.getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"没有这个人"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运用 Optional 的实体类</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Optional&lt;Godness&gt; godness = Optional.ofNullable(<span class="keyword">new</span> Godness(<span class="string">"林志玲"</span>));</span><br><span class="line">    Optional&lt;NewMan&gt; op = Optional.ofNullable(<span class="keyword">new</span> NewMan(godness));</span><br><span class="line">    String name = getGodnessName2(op);</span><br><span class="line">    System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getGodnessName2</span><span class="params">(Optional&lt;NewMan&gt; man)</span></span>&#123;</span><br><span class="line">    <span class="comment">//保证一定有个对象 </span></span><br><span class="line">    <span class="keyword">return</span> man.orElse(<span class="keyword">new</span> NewMan())</span><br><span class="line">        .getGodness()</span><br><span class="line">        .orElse(<span class="keyword">new</span> Godness(<span class="string">"没有这个人"</span>))</span><br><span class="line">        .getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-接口中的默认方法与静态方法"><a href="#7-接口中的默认方法与静态方法" class="headerlink" title="7.接口中的默认方法与静态方法"></a>7.接口中的默认方法与静态方法</h2><p>​    Java 8中允许接口中包含具有具体实现的方法，该方法称为“默认方法”，默认方法使用 default 关键字修饰。</p>
<p>如下面：MyFun</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFun</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"哈哈哈"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口默认方法的 ” 类优先 ”原则</p>
<p>​    若一个接口中定义了一个默认方法，而另外一个父类或接口中又定义了一个同名的方法时</p>
<ul>
<li>选择父类中的方法。如果一个父类提供了具体的实现，那么接口中具有相同名称和参数的默认方法会被忽略。</li>
<li>接口冲突。如果一个父接口提供一个默认方法，而另一个接口也提供了一个具有相同名称和参数列表的方法（不管方法是否是默认方法），那么必须覆盖该方法来解决冲突</li>
</ul>
<p>Java8 中，接口中允许添加静态方法。</p>
<p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyFun</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"哈哈哈"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"嘿嘿嘿"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"呵呵呵"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"接口中的静态方法"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：****</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">MyClass</span> <span class="keyword">implements</span> <span class="title">MyFun</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> <span class="keyword">implements</span> <span class="title">MyFun</span>, <span class="title">MyInterface</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> MyInterface.<span class="keyword">super</span>.getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDefaultInterface</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SubClass sc = <span class="keyword">new</span> SubClass();</span><br><span class="line">		System.out.println(sc.getName());</span><br><span class="line">        <span class="comment">//静态方法</span></span><br><span class="line">		MyInterface.show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-新时间日期-API"><a href="#8-新时间日期-API" class="headerlink" title="8.新时间日期 API"></a>8.新时间日期 API</h2><p><strong>例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormatThreadLocal</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="keyword">new</span> ThreadLocal&lt;DateFormat&gt;()&#123;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> DateFormat <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Date <span class="title">convert</span><span class="params">(String source)</span> <span class="keyword">throws</span> ParseException</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> df.get().parse(source);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSimpleDateFormat</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			//线程问题</span></span><br><span class="line"><span class="comment">			SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");</span></span><br><span class="line"><span class="comment">			//需要一个实例</span></span><br><span class="line"><span class="comment">			Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123;</span></span><br><span class="line"><span class="comment">				@Override</span></span><br><span class="line"><span class="comment">				public Date call() throws Exception &#123;</span></span><br><span class="line"><span class="comment">					return sdf.parse("20161121");</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;;</span></span><br><span class="line"><span class="comment">			//线程池，长度为10</span></span><br><span class="line"><span class="comment">			ExecutorService pool = Executors.newFixedThreadPool(10);</span></span><br><span class="line"><span class="comment">			//返回结果放在list</span></span><br><span class="line"><span class="comment">			List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">			for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">				results.add(pool.submit(task));</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			</span></span><br><span class="line"><span class="comment">			for (Future&lt;Date&gt; future : results) &#123;</span></span><br><span class="line"><span class="comment">				System.out.println(future.get());</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			pool.shutdown();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">//解决多线程安全问题</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">			Callable&lt;Date&gt; task = new Callable&lt;Date&gt;() &#123;</span></span><br><span class="line"><span class="comment">				@Override</span></span><br><span class="line"><span class="comment">				public Date call() throws Exception &#123;</span></span><br><span class="line"><span class="comment">					return DateFormatThreadLocal.convert("20161121");</span></span><br><span class="line"><span class="comment">				&#125;</span></span><br><span class="line"><span class="comment">			&#125;;</span></span><br><span class="line"><span class="comment">			ExecutorService pool = Executors.newFixedThreadPool(10);</span></span><br><span class="line"><span class="comment">			List&lt;Future&lt;Date&gt;&gt; results = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">			for (int i = 0; i &lt; 10; i++) &#123;</span></span><br><span class="line"><span class="comment">				results.add(pool.submit(task));</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			for (Future&lt;Date&gt; future : results) &#123;</span></span><br><span class="line"><span class="comment">				System.out.println(future.get());</span></span><br><span class="line"><span class="comment">			&#125;</span></span><br><span class="line"><span class="comment">			pool.shutdown();</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="comment">//java8</span></span><br><span class="line">		DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMdd"</span>);</span><br><span class="line">		Callable&lt;LocalDate&gt; task = <span class="keyword">new</span> Callable&lt;LocalDate&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> LocalDate <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">				LocalDate ld = LocalDate.parse(<span class="string">"20161121"</span>, dtf);</span><br><span class="line">				<span class="keyword">return</span> ld;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		ExecutorService pool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">		List&lt;Future&lt;LocalDate&gt;&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			results.add(pool.submit(task));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (Future&lt;LocalDate&gt; future : results) &#123;</span><br><span class="line">			System.out.println(future.get());</span><br><span class="line">		&#125;</span><br><span class="line">		pool.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-1-使用-LocalDate-、LocalTime-、LocalDateTime"><a href="#8-1-使用-LocalDate-、LocalTime-、LocalDateTime" class="headerlink" title="8-1.使用 LocalDate 、LocalTime 、LocalDateTime"></a>8-1.使用 LocalDate 、LocalTime 、LocalDateTime</h3><p>​    LocalDate、LocalTime、LocalDateTime 类的实例是不可变的对象，分别表示使用 ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的日期或时间，并不包含当前的时间信息。也不包含与时区相关的信息。</p>
<p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/15.png" alt="15"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. LocalDate、LocalTime、LocalDateTime</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取当前时间</span></span><br><span class="line">    LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">    System.out.println(ldt);</span><br><span class="line">    <span class="comment">//设置时间</span></span><br><span class="line">    LocalDateTime ld2 = LocalDateTime.of(<span class="number">2016</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    System.out.println(ld2);</span><br><span class="line">    <span class="comment">//加年</span></span><br><span class="line">    LocalDateTime ldt3 = ld2.plusYears(<span class="number">20</span>);</span><br><span class="line">    System.out.println(ldt3);</span><br><span class="line">    <span class="comment">//减时间</span></span><br><span class="line">    LocalDateTime ldt4 = ld2.minusMonths(<span class="number">2</span>);</span><br><span class="line">    System.out.println(ldt4);</span><br><span class="line">    <span class="comment">//细化获取时间</span></span><br><span class="line">    System.out.println(ldt.getYear());</span><br><span class="line">    System.out.println(ldt.getMonthValue());</span><br><span class="line">    System.out.println(ldt.getDayOfMonth());</span><br><span class="line">    System.out.println(ldt.getHour());</span><br><span class="line">    System.out.println(ldt.getMinute());</span><br><span class="line">    System.out.println(ldt.getSecond());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-2-Instant"><a href="#8-2-Instant" class="headerlink" title="8-2.Instant"></a>8-2.Instant</h3><p>​    用于“时间戳”的运算。它是以Unix元年(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的描述进行运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2. Instant : 时间戳。 （使用 Unix 元年  1970年1月1日 00:00:00 所经历的毫秒值）</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Instant ins = Instant.now();  </span><br><span class="line">    <span class="comment">//默认使用 UTC 时区</span></span><br><span class="line">    System.out.println(ins);</span><br><span class="line">    <span class="comment">//添加时间</span></span><br><span class="line">    OffsetDateTime odt = ins.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">    System.out.println(odt);</span><br><span class="line">    <span class="comment">//从第二个开始的时间线获取纳米秒数</span></span><br><span class="line">    System.out.println(ins.getNano());</span><br><span class="line">    <span class="comment">//加5秒，原始时间</span></span><br><span class="line">    Instant ins2 = Instant.ofEpochSecond(<span class="number">5</span>);</span><br><span class="line">    System.out.println(ins2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-3-Duration-和-Period"><a href="#8-3-Duration-和-Period" class="headerlink" title="8-3.Duration  和 Period"></a>8-3.Duration  和 Period</h3><ul>
<li>Duration:用于计算两个“时间”间隔</li>
<li>Period:用于计算两个“日期”间隔</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Duration : 用于计算两个“时间”间隔</span></span><br><span class="line"><span class="comment">//Period : 用于计算两个“日期”间隔</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Instant ins1 = Instant.now();</span><br><span class="line">    System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    Instant ins2 = Instant.now();</span><br><span class="line">    System.out.println(<span class="string">"所耗费时间为："</span> + Duration.between(ins1, ins2));</span><br><span class="line">    <span class="comment">//获取毫秒 Duration.toMillis()</span></span><br><span class="line">    System.out.println(<span class="string">"----------------------------------"</span>);</span><br><span class="line"></span><br><span class="line">    LocalDate ld1 = LocalDate.now();</span><br><span class="line">    LocalDate ld2 = LocalDate.of(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Period pe = Period.between(ld2, ld1);</span><br><span class="line">    System.out.println(pe.getYears());</span><br><span class="line">    System.out.println(pe.getMonths());</span><br><span class="line">    System.out.println(pe.getDays());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-4-日期的操纵"><a href="#8-4-日期的操纵" class="headerlink" title="8-4.日期的操纵"></a>8-4.日期的操纵</h3><ul>
<li>TemporalAdjuster : 时间校正器。有时我们可能需要获取例如：将日期调整到“下个周日”等操作。</li>
<li>TemporalAdjusters : 该类通过静态方法提供了大量的常<br>用 TemporalAdjuster 的实现。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4. TemporalAdjuster : 时间校正器</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">    System.out.println(ldt);</span><br><span class="line">    </span><br><span class="line">    LocalDateTime ldt2 = ldt.withDayOfMonth(<span class="number">10</span>);</span><br><span class="line">    System.out.println(ldt2);</span><br><span class="line">    <span class="comment">//增加下一周</span></span><br><span class="line">    LocalDateTime ldt3 = ldt.with(TemporalAdjusters.next(DayOfWeek.SUNDAY));</span><br><span class="line">    System.out.println(ldt3);</span><br><span class="line">    <span class="comment">//自定义：下一个工作日</span></span><br><span class="line">    LocalDateTime ldt5 = ldt.with((l) -&gt; &#123;</span><br><span class="line">        LocalDateTime ldt4 = (LocalDateTime) l;</span><br><span class="line">        DayOfWeek dow = ldt4.getDayOfWeek();</span><br><span class="line">        <span class="comment">//周五加3天，周六加2天，周日加一天</span></span><br><span class="line">        <span class="keyword">if</span>(dow.equals(DayOfWeek.FRIDAY))&#123;</span><br><span class="line">            <span class="keyword">return</span> ldt4.plusDays(<span class="number">3</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dow.equals(DayOfWeek.SATURDAY))&#123;</span><br><span class="line">            <span class="keyword">return</span> ldt4.plusDays(<span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ldt4.plusDays(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(ldt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-5-解析与格式化"><a href="#8-5-解析与格式化" class="headerlink" title="8-5.解析与格式化"></a>8-5.解析与格式化</h3><p>​    java.time.format.DateTimeFormatter 类：该类提供了三种格式化方法：</p>
<ul>
<li>预定义的标准格式</li>
<li>语言环境相关的格式</li>
<li>自定义的格式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//5. DateTimeFormatter : 解析和格式化日期或时间</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//提供的时间格式</span></span><br><span class="line">    <span class="comment">//DateTimeFormatter dtf = DateTimeFormatter.ISO_LOCAL_DATE;</span></span><br><span class="line">    <span class="comment">//自定义时间格式</span></span><br><span class="line">    DateTimeFormatter dtf = DateTimeFormatter.ofPattern(<span class="string">"yyyy年MM月dd日 HH:mm:ss E"</span>);</span><br><span class="line">    LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">    String strDate = ldt.format(dtf);</span><br><span class="line">    System.out.println(strDate);</span><br><span class="line">    <span class="comment">//将字符串转换为时间</span></span><br><span class="line">    LocalDateTime newLdt = ldt.parse(strDate, dtf);</span><br><span class="line">    System.out.println(newLdt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-6-时区的处理"><a href="#8-6-时区的处理" class="headerlink" title="8-6.时区的处理"></a>8-6.时区的处理</h3><p>​    带时区的时间为分别为：ZonedDate、ZonedTime、ZonedDateTime</p>
<p>​    其中每个时区都对应着 ID，地区ID都为 “{区域}/{城市}”的格式</p>
<p>​    例如 ：Asia/Shanghai 等</p>
<ul>
<li>ZoneId：该类中包含了所有的时区信息<ul>
<li>getAvailableZoneIds() : 可以获取所有时区时区信息</li>
<li>of(id) : 用指定的时区信息获取 ZoneId 对象</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//6.ZonedDate、ZonedTime、ZonedDateTime ： 带时区的时间或日期</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test7</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//指定时区Asia/Shanghai</span></span><br><span class="line">    LocalDateTime ldt = LocalDateTime.now(ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">    System.out.println(ldt);</span><br><span class="line">    <span class="comment">//指定时区US/Pacific</span></span><br><span class="line">    ZonedDateTime zdt = ZonedDateTime.now(ZoneId.of(<span class="string">"US/Pacific"</span>));</span><br><span class="line">    System.out.println(zdt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test6</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取所有时区</span></span><br><span class="line">    Set&lt;String&gt; set = ZoneId.getAvailableZoneIds();</span><br><span class="line">    set.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="8-7-与传统日期处理的转换"><a href="#8-7-与传统日期处理的转换" class="headerlink" title="8-7.与传统日期处理的转换"></a>8-7.与传统日期处理的转换</h3><p><img src="../images/java8%E6%96%B0%E7%89%B9%E6%80%A7/16.png" alt="16"></p>
<h2 id="9-重复注解与类型注解"><a href="#9-重复注解与类型注解" class="headerlink" title="9.重复注解与类型注解"></a>9.重复注解与类型注解</h2><p>​    Java 8对注解处理：可重复的注解及可用于类型的注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//类型注解 TYPE_PARAMETER</span></span><br><span class="line"><span class="meta">@Repeatable</span>(MyAnnotations<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> "atguigu"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  重复注解与类型注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnnotation</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;TestAnnotation&gt; clazz=TestAnnotation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        Method m1=clazz.getMethod(<span class="string">"show"</span>);</span><br><span class="line">        MyAnnotation[] max=m1.getAnnotationsByType(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">for</span> (MyAnnotation myAnnotation : max) &#123;</span><br><span class="line">            System.out.println(myAnnotation.value());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="meta">@MyAnnotation</span>(<span class="string">"World"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@MyAnnotation</span>(<span class="string">"Hello"</span>)</span><br><span class="line">    <span class="meta">@MyAnnotation</span>(<span class="string">"World"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">(@MyAnnotation(<span class="string">"abd"</span>)</span> String str)</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>JAVA8</tag>
      </tags>
  </entry>
  <entry>
    <title>全部面试笔记-2</title>
    <url>/post/c0e5897b.html</url>
    <content><![CDATA[<p>​    Java面试的笔记-2，全面回忆</p>
<a id="more"></a>

<h1 id="4-前端部分"><a href="#4-前端部分" class="headerlink" title="4.前端部分"></a>4.前端部分</h1><h2 id="4-1-html-css-javascript在网页开发中的定位"><a href="#4-1-html-css-javascript在网页开发中的定位" class="headerlink" title="4-1.html,css,javascript在网页开发中的定位?"></a>4-1.html,css,javascript在网页开发中的定位?</h2><p>HTML 超文本标记语言 定义网页的结构</p>
<p>CSS 层叠样式表，用来美化页面</p>
<p>JavaScript主要用来验证表单，做动态交互(其中ajax)</p>
<h2 id="4-2-Ajax"><a href="#4-2-Ajax" class="headerlink" title="4-2.Ajax?"></a>4-2.Ajax?</h2><p>​    什么是Ajax? </p>
<p>​        异步的javascript和xml</p>
<p>​    作用是什么？</p>
<p>​        通过AJAX与服务器进行数据交换，AJAX可以使网页实现布局更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。</p>
<p>​    怎么来实现Ajax的XmlHttpRequest对象，使用这个对象可以异步向服务器发送请求，获取获取响应，完成局部更新。Open send responseText/responseXML 局部响应。</p>
<p>​    使用场景：登陆失败时不跳转页面，注册时提示用户名是否存在，二级联动等等使用场景</p>
<h2 id="4-3-js和jQuery的关系"><a href="#4-3-js和jQuery的关系" class="headerlink" title="4-3.js和jQuery的关系?"></a>4-3.js和jQuery的关系?</h2><p>​    jQuery是一个js框架，封装了js的属性和方法，让用户使用起来更加便利，并且增强了js的功能.</p>
<p>​    使用原生js是要处理很多兼容性的问题(注册事件等)，由jQuery封装了底层，就不用处理兼容性问题。</p>
<p>​    原生的js的dom和事件绑定和Ajax等操作非常麻烦，jQuery封装以后操作非常方便。</p>
<h2 id="4-4-jQuery的常用选择器？"><a href="#4-4-jQuery的常用选择器？" class="headerlink" title="4-4.jQuery的常用选择器？"></a>4-4.jQuery的常用选择器？</h2><ul>
<li><p>ID选择器   通过ID获取一个元素</p>
</li>
<li><p>Class选择器 通过类(css)获取元素</p>
</li>
<li><p>标签选择器 通过标签获取元素</p>
</li>
<li><p>通用选择器(*) 获取所以的元素</p>
<p>​    div.myCls  获取有myCls这个类的div</p>
</li>
<li><p>层次选择器</p>
<p>​     儿子选择器 &gt; 获取下面的子元素</p>
<p>​     后代选择器 空格 获取下面后代，包括儿子、孙子等后代</p>
</li>
<li><p>属性选择器</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Tag[attrName=’test’] </span><br><span class="line">获取有属性名为xxxx并且属性的值为test的所有xxx标签</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>/&gt;</span> 吃饭<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"hobby"</span>/&gt;</span> 睡觉<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">Input[name=’hobby’]</span><br><span class="line">表示获取属性名为name并且name属性值为hobby的的所有input标签元素</span><br></pre></td></tr></table></figure>

<p>​    </p>
<h2 id="4-5-jQuery的页面加载完毕事件？"><a href="#4-5-jQuery的页面加载完毕事件？" class="headerlink" title="4-5.jQuery的页面加载完毕事件？"></a>4-5.jQuery的页面加载完毕事件？</h2><p>​    需要获取元素，但是必须等到该元素被加载完成后才能获取。我们可以把js代码放到该元素的后面，但是这样就会造成js在我们的body中存在不好管理。所有页面加载完毕后所有的元素当然已经加载完毕。一般获取元素做操作都要在页面加载完毕后操作。</p>
<table>
<thead>
<tr>
<th>$(document).ready(function(){});</th>
<th>$(function(){});</th>
</tr>
</thead>
<tbody><tr>
<td>$(document)把原生的document这个dom对象转换为jQuery对象，转换完成后才能调用ready方法</td>
<td>当页面加载完毕后执行里面的函数,这一种相对简单，用得最多。</td>
</tr>
<tr>
<td>ready(fn),表示的是页面结构被加载完毕后执行传入函数fn</td>
<td></td>
</tr>
</tbody></table>
<p><strong>window.onload的区别</strong></p>
<p>​    1、jQuery中的页面加载完毕事件，表示的是页面结构被加载完毕。</p>
<p>​    2、window.onload 表示的是页面被加载完毕。</p>
<p>​    <strong>onload</strong>必须等等页面中的图片、声音、图像等远程资源被加载完毕后才调用</p>
<p>​    <strong>jQuery</strong>中只需要页面结构被加载完毕。</p>
<h2 id="4-6-Jquery的Ajax和原生Js实现Ajax有什么关系？"><a href="#4-6-Jquery的Ajax和原生Js实现Ajax有什么关系？" class="headerlink" title="4-6.Jquery的Ajax和原生Js实现Ajax有什么关系？"></a>4-6.Jquery的Ajax和原生Js实现Ajax有什么关系？</h2><p>​    jQuery中的Ajax也是通过原生的js封装的。封装完成后让我们使用起来更加便利，不用考虑底层实现或兼容性等处理。</p>
<p>​    如果采用原生js实现Ajax是非常麻烦的，并且每次都是一样的。如果我们不使用jQuery我们也要封装Ajax对象的方法和属性。</p>
<p>​    有像jQuery这些已经封装完成，并经过很多企业实际的框架，比较可靠并且开源。我们就不需要封装，直接使用成熟的框架(jQuery)即可.</p>
<h2 id="4-7-html5"><a href="#4-7-html5" class="headerlink" title="4-7.html5?"></a>4-7.html5?</h2><p>​    Html5是最新版本的html,是在原来html4的基础上增强了一些标签。</p>
<p>​    Html增加一些像画板、声音、视频、web存储等高级功能。但是html5有一个不好的地方，那就是html5太强调语义了，导致开发中都不知道要选择那个标签。</p>
<p>​    在做页面布局是，无论头部、主题、导航等模块都使用div来表示，但是html5的规范，需要使用不同的标签来表示。(header footer等)</p>
<h2 id="4-8-css3"><a href="#4-8-css3" class="headerlink" title="4-8.css3?"></a>4-8.css3?</h2><p>Css3是最新版本的css,是对原理css2的功能增强。</p>
<p>Css3中提供一些原来css2中实现起来比较困难或者不能实现的功能。</p>
<p>​     1、盒子圆角边框</p>
<p>​     2、盒子和文字的阴影</p>
<p>​     3、渐变</p>
<p>​     4、转换 移动、缩放、旋转等</p>
<p>​     5、过渡、动画都可以使用动画。</p>
<p>​     6、可以使用媒体查询实现响应式网站。</p>
<p>Css3最大缺点就是要根据不同的浏览器处理兼容性。对应有一些处理兼容性的工具。不用担心.</p>
<h2 id="4-9-bootstrap是什么？"><a href="#4-9-bootstrap是什么？" class="headerlink" title="4-9.bootstrap是什么？"></a>4-9.bootstrap是什么？</h2><p>​    BootStrap是一个移动设备优先的UI框架。我们可以不用谢任何css,js代码就能实现比较漂亮的有交互性的页面。我们程序员对页面的编写是有硬伤的，所有要自己写页面的话就要使用类似于bootstrap这样的UI框架。</p>
<h1 id="5-后端部分"><a href="#5-后端部分" class="headerlink" title="5.后端部分"></a>5.后端部分</h1><h2 id="5-1-什么是框架"><a href="#5-1-什么是框架" class="headerlink" title="5-1.什么是框架?"></a>5-1.什么是框架?</h2><p>​    <strong>框架</strong>（Framework）是一个框子——指其约束性，也是一个架子——指其支撑性。</p>
<p>​    IT语境中的框架，特指为解决一个开放性问题而设计的具有一定约束性的支撑结构。在此结构上可以根据具体问题扩展、安插更多的组成部分，从而更迅速和方便地构建完整的解决问题的方案。</p>
<p>​    1）框架本身一般不完整到可以解决特定问题,但是可以帮助您快速解决特定问题；</p>
<p>​    2）框架天生就是为扩展而设计的；</p>
<p>​    3）框架里面可以为后续扩展的组件提供很多辅助性、支撑性的方便易用的实用工具（utilities），也就是说框架时常配套了一些帮助解决某类问题的库（libraries）或工具（tools）。</p>
<p>​    java中就是一系列的jar包，其本质就是对jdk功能的扩展.</p>
<h2 id="5-2-MVC模式"><a href="#5-2-MVC模式" class="headerlink" title="5-2. MVC模式"></a>5-2. MVC模式</h2><p>​    <strong>MVC</strong>全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写</p>
<p>​    一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p>
<p>​    最简单的、最经典就是Jsp(view) +Servlet(controller) + JavaBean(model)</p>
<p><img src="../images/%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/6.png" alt="6"></p>
<p>​    1、当控制器收到来自用户的请求</p>
<p>​    2、控制器调用JavaBean完成业务</p>
<p>​    3、完成业务后通过控制器跳转JSP页面的方式给用户反馈信息</p>
<p>​    4、Jsp个 用户做出响应。</p>
<h2 id="5-3-MVC框架"><a href="#5-3-MVC框架" class="headerlink" title="5-3.MVC框架"></a>5-3.MVC框架</h2><p>​    是为了解决传统MVC模式(Jsp + Servlet + JavaBean)的一些问题而出现的框架。</p>
<p><strong>传统MVC模式问题</strong></p>
<p>​    1、所有的Servlet和Servlet映射都要配置在web.xml中，如果项目太大，web.xml就太庞大，并且不能实现模块化管理。</p>
<p>​    2、Servlet的主要功能就是接受参数、调用逻辑、跳转页面，比如像其他字符编码、文件上传等功能也要写在Servlet中，不能让Servlet主要功能而需要做处理一下特例。</p>
<p>​    3、接受参数比较麻烦(String name = request.getParameter(“name”),User user=new User user.setName(name))，不能通过model接收，只能单个接收，接收完成后转换封装model.</p>
<p>​    4、跳转页面方式比较单一(forword,redirect),并且当我的页面名称发生改变时需要修改Servlet源代码.</p>
<h2 id="5-4-SpringMVC的执行流程？"><a href="#5-4-SpringMVC的执行流程？" class="headerlink" title="5-4.SpringMVC的执行流程？"></a>5-4.SpringMVC的执行流程？</h2><ol>
<li><p>用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获；</p>
</li>
<li><p>DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；</p>
</li>
<li><p>DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。（<strong>附注</strong>：如果成功获得HandlerAdapter后，此时将开始执行拦截器的preHandler(…)方法）</p>
</li>
<li><p>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。 在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作：</p>
</li>
<li><p>Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象；</p>
</li>
<li><p>根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver)返回给DispatcherServlet ；</p>
</li>
<li><p>ViewResolver 结合Model和View，来渲染视图</p>
</li>
<li><p>将渲染结果返回给客户端。</p>
</li>
</ol>
<p><img src="../images/%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/7.png" alt="7"></p>
<p>​    HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息</p>
<p>​      数据转换：对请求消息进行数据转换。如String转换成Integer、Double等</p>
<p>​      数据根式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等</p>
<p>​      数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中</p>
<p><strong>面试：</strong></p>
<p>1、 用户向服务器发送请求，请求被Spring 前端控制Servelt DispatcherServlet捕获(捕获)</p>
<p>2、 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI）。然后根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain对象的形式返回；(查找handler)</p>
<p>3、 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller), Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象(执行handler)</p>
<p>4、DispatcherServlet 根据返回的ModelAndView，选择一个适合的ViewResolver（必须是已经注册到Spring容器中的ViewResolver) (选择ViewResolver)</p>
<p>5、通过ViewResolver 结合Model和View，来渲染视图,DispatcherServlet 将渲染结果返回给客户端。（渲染返回）</p>
<p><strong>快速记忆技巧：</strong></p>
<p>​    核心控制器捕获请求、查找Handler、执行Handler、选择ViewResolver,通过ViewResolver渲染视图并返回</p>
<h2 id="5-5-struts2和springMVC有什么不同？"><a href="#5-5-struts2和springMVC有什么不同？" class="headerlink" title="5-5.struts2和springMVC有什么不同？"></a>5-5.struts2和springMVC有什么不同？</h2><p>对SpringMvc和Struts2进行各方面的比较:</p>
<ol>
<li><p>核 心控制器（前端控制器、预处理控制器）：对于使用过mvc框架的人来说这个词应该不会陌生，核心控制器的主要用途是处理所有的请求，然后对那些特殊的请求 （控制器）统一的进行处理(字符编码、文件上传、参数接受、异常处理等等),spring mvc核心控制器是Servlet，而Struts2是Filter。</p>
</li>
<li><p>控制器实例：Spring Mvc会比Struts快一些（理论上）。Spring Mvc是基于方法设计，而Sturts是基于对象，每次发一次请求都会实例一个action，每个action都会被注入 属性，而Spring更像Servlet一样，只有一个实例，每次请求执行对应的方法即可(注意：由于是单例实例，所以应当避免全局变量的修改，这样会产生线程安全问题)。</p>
</li>
<li><p>管理方式：大部分的公司的核心架构中，就会使用到spring,而spring mvc又是spring中的一个模块，所以spring对于spring mvc的控制器管理更加简单方便，而且提供了全 注解方式进行管理，各种功能的注解都比较全面，使用简单，而struts2需要采用XML很多的配置参数来管理（虽然也可以采用注解，但是几乎没有公司那 样使用）。</p>
</li>
<li><p>参数传递：Struts2中自身提供多种参数接受，其实都是通过（ValueStack）进行传递和赋值，而SpringMvc是通过方法的参数进行接收。</p>
</li>
<li><p>学习难度：Struts更加很多新的技术点，比如拦截器、值栈及OGNL表达式，学习成本较高，springmvc 比较简单，很较少的时间都能上手。</p>
</li>
<li><p>intercepter 的实现机制：struts有以自己的interceptor机制，spring mvc用的是独立的AOP方式。这样导致struts的配置文件量还是比spring mvc大，虽然struts的配置能继承，所以我觉得论使用上来讲，spring mvc使用更加简洁，开发效率Spring MVC确实比struts2高。</p>
</li>
<li><p>spring mvc是方法级别的拦截，一个方法对应一个request上下文，而方法同时又跟一个url对应，所以说从架构本身上spring3 mvc就容易实现restful url。struts2是类级别的拦截，一个类对应一个request上下文；实现restful url要费劲，因为struts2 action的一个方法可以对应一个url；而其类属性却被所有方法共享，这也就无法用注解或其他方式标识其所属方法了。</p>
</li>
<li><p>spring3 mvc的方法之间基本上独立的，独享request response数据，请求数据通过参数获取，处理结果通过ModelMap交回给框架方法之间不共享变量，而struts2搞的就比较乱，虽然方法之间 也是独立的，但其所有Action变量是共享的，这不会影响程序运行，却给我们编码，读程序时带来麻烦。</p>
</li>
<li><p>spring mvc处理ajax请求,直接通过返回数据，方法中使用注解@ResponseBody，spring mvc自动帮我们对象转换为JSON数据。而struts2是通过插件的方式进行处理</p>
</li>
</ol>
<p>​    在SpringMVC流行起来之前，Struts2在MVC框架中占核心地位，随着SpringMVC的出现，SpringMVC慢慢的取代struts2,但是很多企业都是原来搭建的框架，使用Struts2较多。</p>
<h2 id="5-6-Spring中的两大核心？"><a href="#5-6-Spring中的两大核心？" class="headerlink" title="5-6.Spring中的两大核心？"></a>5-6.Spring中的两大核心？</h2><p>​    Spring是J2EE应用程序框架，是轻量级的IoC和AOP的容器框架(相对于重量级的EJB)，主要是针对javaBean的生命周期进行管理的轻量级容器，可以单独使用，也可以和Struts框架，ibatis框架等组合使用。</p>
<ol>
<li>IOC(Inversion of Control )或DI(Dependency Injection)：<strong>控制权反转</strong></li>
</ol>
<p>​          原来：我的Service需要调用DAO，Service就需要创建DAO</p>
<p>​          Spring:Spring发现你Service依赖于dao,就给你注入.</p>
<p>​       核心原理：就是配置文件+反射(工厂也可以)+容器(map)  </p>
<p>2、AOP：<strong>面向切面编程</strong></p>
<p>​       核心原理：使用动态代理的设计模式在执行方法前后或出现异常做加入相关逻辑。</p>
<p>​      我们主要使用AOP来做：</p>
<p>​      1、事务处理</p>
<p>​      2、权限判断</p>
<p>​      3、日志</p>
<p>​      4、….</p>
<h2 id="5-7-AOP是什么？你都拿它做什么？"><a href="#5-7-AOP是什么？你都拿它做什么？" class="headerlink" title="5-7.AOP是什么？你都拿它做什么？"></a>5-7.AOP是什么？你都拿它做什么？</h2><p>AOP：<strong>面向切面编程</strong></p>
<p>​       核心原理：使用动态代理的设计模式在执行方法前后或出现异常做加入相关逻辑。</p>
<p>​      我们主要使用AOP来做：</p>
<p>​      1、事务处理：执行方法前，开启事务、执行完成后关闭事务、出现异常后回滚事务</p>
<p>​      2、权限判断：在执行方法前，判断是否具有权限</p>
<p>​      3、日志：在执行前进行日志处理</p>
<p>​      4、….</p>
<h2 id="5-8-Spring的事务传播特性"><a href="#5-8-Spring的事务传播特性" class="headerlink" title="5-8.Spring的事务传播特性"></a>5-8.Spring的事务传播特性</h2><ol>
<li><p>PROPAGATION_REQUIRED：如果存在一个事务，则支持当前事务。如果没有事务则开启</p>
</li>
<li><p>PROPAGATION_SUPPORTS：如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</p>
</li>
<li><p>PROPAGATION_MANDATORY：如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
</li>
<li><p>PROPAGATION_REQUIRES_NEW：总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
</li>
<li><p>PROPAGATION_NOT_SUPPORTED：总是非事务地执行，并挂起任何存在的事务。</p>
</li>
<li><p>PROPAGATION_NEVER： 总是非事务地执行，如果存在一个活动事务，则抛出异常</p>
</li>
<li><p>PROPAGATION_NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按TransactionDefinition.PROPAGATION_REQUIRED属性执行</p>
</li>
</ol>
<p>Required： 需要：如果存在一个事务，则支持当前事务。如果没有事务则开启</p>
<p>Supports： 支持：如果存在一个事务，支持当前事务。如果没有事务，则非事务的执行</p>
<p>Mandatory： 必要的：如果已经存在一个事务，支持当前事务。如果没有一个活动的事务，则抛出异常。</p>
<p>required_new： 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。</p>
<p>Not_support： 总是非事务地执行，并挂起任何存在的事务。</p>
<p>Never： 绝不：总是非事务地执行，如果存在一个活动事务，则抛出异常</p>
<p>Nested： 嵌套的：如果有就嵌套、没有就开启事务</p>
<h2 id="5-9-Spring事务的隔离级别"><a href="#5-9-Spring事务的隔离级别" class="headerlink" title="5-9.Spring事务的隔离级别"></a>5-9.Spring事务的隔离级别</h2><ol>
<li><p>ISOLATION_DEFAULT： 这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。    另外四个与JDBC的隔离级别相对应</p>
</li>
<li><p>ISOLATION_READ_UNCOMMITTED： 这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。    这种隔离级别会产生脏读，不可重复读和幻像读。</p>
</li>
<li><p>ISOLATION_READ_COMMITTED： 保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据</p>
</li>
<li><p>ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</p>
</li>
<li><p>ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻像读。</p>
</li>
</ol>
<p><strong>其中的一些概念的说明：</strong></p>
<ul>
<li><strong>脏读:</strong> 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</li>
<li><strong>不可重复读:</strong> 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</li>
<li><strong>幻觉读:</strong> 指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。</li>
</ul>
<h2 id="5-10-什么是ORM"><a href="#5-10-什么是ORM" class="headerlink" title="5-10.什么是ORM?"></a>5-10.什么是ORM?</h2><p>​    <strong>对象关系映射</strong>（Object Relational Mapping，简称ORM）模式是一种为了解决面向<strong>对象</strong>与<strong>关系</strong>数据库存在的互不匹配的现象的技术。</p>
<p>​    简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。</p>
<p>​    那么，到底如何实现持久化呢？</p>
<p>​    一种简单的方案是采用硬编码方式(jdbc操作sql方式)，为每一种可能的数据库访问操作提供单独的方法。</p>
<p>这种方案存在以下不足： </p>
<p>​    1.持久化层缺乏弹性。一旦出现业务需求的变更，就必须修改持久化层的接口 </p>
<p>​    2.持久化层同时与域模型与关系数据库模型绑定，不管域模型还是关系数据库模型发生变化，都要修改持久化曾的相关程序代码，增加了软件的维护难度。 </p>
<p>​    ORM提供了实现持久化层的另一种模式，它采用映射元数据来描述对象关系的映射，使得ORM中间件能在任何一个应用的业务逻辑层和数据库层之间充当桥梁。</p>
<p>​    Java典型的ORM框架有:Hibernate、mybatis、speedframework。</p>
<p>   ORM的方法论基于三个核心原则： </p>
<p>　　   简单：以最基本的形式建模数据。 </p>
<p>　　   传达性：数据库结构被任何人都能理解的语言文档化。 </p>
<p>　　   精确性：基于数据模型创建正确标准化了的结构</p>
<h2 id="5-11-mybatis与Hibernate有什么不同"><a href="#5-11-mybatis与Hibernate有什么不同" class="headerlink" title="5-11.mybatis与Hibernate有什么不同?"></a>5-11.mybatis与Hibernate有什么不同?</h2><p>相同点：</p>
<p>​    都是java中orm框架、屏蔽jdbc api的底层访问细节，使用我们不用与jdbc api打交道，就可以完成对数据库的持久化操作。</p>
<p>​    jdbc api编程流程固定，还将sql语句与java代码混杂在了一起，经常需要拼凑sql语句，细节很繁琐。</p>
<p>mybatis的好处：</p>
<ul>
<li>屏蔽jdbc api的底层访问细节</li>
<li>将sql语句与java代码进行分离;提供了将结果集自动封装称为实体对象和对象的集合的功能.queryForList返回对象集合，用queryForObject返回单个对象</li>
<li>提供了自动将实体对象的属性传递给sql语句的参数。</li>
</ul>
<p> Hibername的好处：</p>
<ul>
<li>Hibernate是一个全自动的orm映射工具，它可以自动生成sql语句，并执行并返回java结果。</li>
</ul>
<p>不同点：</p>
<p>​    1、hibernate要比mybatis功能强大很多。因为hibernate自动生成sql语句。</p>
<p>​    2、mybatis需要我们自己在xml配置文件中写sql语句，hibernate我们无法直接控制该语句，我们就无法去写特定的高效率的sql。对于一些不太复杂的sql查询，hibernate可以很好帮我们完成，但是，对于特别复杂的查询，hibernate就很难适应了，这时候用mybatis就是不错的选择，因为mybatis还是由我们自己写sql语句。</p>
<p>​    3、mybatis可以出来复杂语句，而hibernate不能。</p>
<p>​    4、mybatis要比hibernate简单的多。mybatis是面向sql的，不同考虑对象间一些复杂的映射关系。</p>
<h1 id="6-其他方面（待续…）"><a href="#6-其他方面（待续…）" class="headerlink" title="6.其他方面（待续…）"></a>6.其他方面（待续…）</h1>]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>全部面试笔记-1</title>
    <url>/post/448efa24.html</url>
    <content><![CDATA[<p>​    Java面试的笔记，全面回忆</p>
<a id="more"></a>

<h1 id="1-java基础"><a href="#1-java基础" class="headerlink" title="1.java基础"></a>1.java基础</h1><h2 id="1-1-java的跨平台原理"><a href="#1-1-java的跨平台原理" class="headerlink" title="1-1.java的跨平台原理"></a>1-1.java的跨平台原理</h2><p>​    由于各操作系统支持的指令集，不是完全一致。不同的操作系统上要执行不同程序代码，但相同代码会使程序执行不了。所以，java开发了适用于不同操作系统及位数的java虚拟机(jvm)来屏蔽各个系统之间的差异，提供统一的接口(java API)。</p>
<p>​    对于java开发者而言，只需要在不同系统上安装对应不同的虚拟机。只要java程序遵循java规范，可以在所有操作系统上运行java程序</p>
<p><img src="../images/%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/1.png" alt="1"></p>
<h2 id="1-2-搭建java开发环境的步骤"><a href="#1-2-搭建java开发环境的步骤" class="headerlink" title="1-2.搭建java开发环境的步骤"></a>1-2.搭建java开发环境的步骤</h2><p>​    1、适用于我们开发环境的jdk</p>
<p>​    2、对应开发环境eclipse或idea</p>
<p>​    3、还需要web服务器(tomcat)</p>
<h2 id="1-3-int占几个字节"><a href="#1-3-int占几个字节" class="headerlink" title="1-3.int占几个字节"></a>1-3.int占几个字节</h2><p>​    java有8个基本数据类型：byte，shot，int，long，float，double，char，boolean</p>
<p>byte：8位    shot：16位    int：32位，占4个字节    </p>
<p>long：64位    float：32位    double：64位    </p>
<p>char：16位    boolean：1位    </p>
<h2 id="1-4-面向对象的特征有哪些方面"><a href="#1-4-面向对象的特征有哪些方面" class="headerlink" title="1-4.面向对象的特征有哪些方面"></a>1-4.面向对象的特征有哪些方面</h2><p>​    四大基本特征：封装，抽象，继承，多态</p>
<ul>
<li>封装：将对象封装成一个高度自治和相对封闭的个体，对象状态（属性由这个对象自己的行为（方法）来读取和改变。</li>
<li>抽象：做出一些事物的相似和共性之处，归为一个类。（把现实生活中的对象，抽象为类）</li>
<li>继承：在一个已经存在的类的基础之上进行，将其定义的内容作为自己的，可以加入若干新内容，或修改原来的方法，符合需求。</li>
<li>多态：<ul>
<li>程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定。</li>
<li>即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</li>
<li>引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。 </li>
</ul>
</li>
</ul>
<h2 id="1-5-基本数据类型，为什么还需要包装类型"><a href="#1-5-基本数据类型，为什么还需要包装类型" class="headerlink" title="1-5.基本数据类型，为什么还需要包装类型"></a>1-5.基本数据类型，为什么还需要包装类型</h2><p>​    每一个基本数据类型会对于一个包装类型：boolean–&gt;Boolean    int–&gt;Integer</p>
<ul>
<li>基本数据类型，包装类型–&gt;装箱和拆箱</li>
</ul>
<p>​    装箱：把基本的数据类型转换成对应的包装类型</p>
<p>​        Integer i = 1–&gt;Integer .valueOf(1)</p>
<p>​        自动装箱，实际上在编译时会调用Integer .valueOf方法来装箱</p>
<p>​    拆箱：把包装类型转换为基本数据类型.基本数据类型</p>
<p>​        Integer i = 1;</p>
<p>​        int j = i–&gt;自动拆箱</p>
<p>​        int j = i.intValue()i–&gt;手动拆箱</p>
<p>​        自动拆箱：实际上会在编译调用intValue    （源码）</p>
<ul>
<li><p>Java是一个面向对象的语言，而基本的数据类型，不具备面向对象的特性</p>
<p>面向对象特性：null，max，min</p>
<p>例子：Integer和int分别表示Person这个类的ID，可以null，判断一下</p>
</li>
<li><p>包装类型：对象有缓存–&gt;Integer i=1、Integer j= 1、i ==j</p>
</li>
</ul>
<h2 id="1-6-和equals有什么区别"><a href="#1-6-和equals有什么区别" class="headerlink" title="1-6.==和equals有什么区别"></a>1-6.==和equals有什么区别</h2><p>​    ==，用来判断两个变量之间的的值是否相等。</p>
<p>​    变量就可以分为基本数据类型变量，引用类型。</p>
<p>​    如果是基本数据类型的变量直接比较值，而引用类型要比较对应的引用的内存的首地址。</p>
<p>​    equals 用来比较两个对象长得是否一样。</p>
<p>​    判断两个对象的某些特征是否一样。实际上就是调用对象的equals方法进行比较。</p>
<h2 id="1-7-String和StringBuilder的区别？StringBuffer和StringBuilder的区别"><a href="#1-7-String和StringBuilder的区别？StringBuffer和StringBuilder的区别" class="headerlink" title="1-7.String和StringBuilder的区别？StringBuffer和StringBuilder的区别?"></a>1-7.String和StringBuilder的区别？StringBuffer和StringBuilder的区别?</h2><p>​    String、StringBuillder、StringBuffer三个类是来表示和操作字符串：字符串就是多个字符的集合。</p>
<p>​    String是内容不可变的字符串。String底层使用了一个不可变的字符数组(final char[])</p>
<p><img src="../images/%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/2.png" alt="2"></p>
<p>​    StringBuillder、StringBuffer：是内容可以改变的字符串。StringBuillder、StringBuffer底层使用的可变的字符数组（没有使用final来修饰） </p>
<p><img src="../images/%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/3.png" alt="3"></p>
<p><strong>拼接字符串：</strong></p>
<p>​    String进行拼接：String c = “a”+”b”</p>
<p>​    StringBuilder或者StringBuffer ：</p>
<p>​        StringBuilder sb = new StringBuilder();    </p>
<p>​        sb.apend(“a”).apend(“b”)</p>
<p>​    拼接字符串不能使用String进行拼接，要使用StringBuilder或者StringBuffer</p>
<p><strong>区别：</strong></p>
<p>​    StringBuilder是线程不安全的，效率较高    而StringBuffer是线程安全的，效率较低。</p>
<h2 id="1-8-java中的集合"><a href="#1-8-java中的集合" class="headerlink" title="1-8.java中的集合?"></a>1-8.java中的集合?</h2><p>​    Java中的集合为两种：Conllection：value，Map：key–vale</p>
<p>Conllection：存储值有分为List 和Set</p>
<ul>
<li>List是有序的，可以重复的。</li>
<li>Set是无序的，不可以重复的。根据equals和hashcode判断，也就是如果一个对象要存储在Set中，必须重写equals和hashCode方法。</li>
</ul>
<p>map：存储key-value</p>
<h2 id="1-9-ArrayList和LinkedList的区别"><a href="#1-9-ArrayList和LinkedList的区别" class="headerlink" title="1-9.ArrayList和LinkedList的区别?"></a>1-9.ArrayList和LinkedList的区别?</h2><ul>
<li><p>ArrayList底层使用时数组。LinkedList使用的是链表。</p>
</li>
<li><p>数组查询具有所有查询特定元素比较快，而插入和删除和修改比较慢(数组在内存中是一块连续的内存，如果插入或删除是需要移动内存)。</p>
</li>
<li><p>链表不要求内存是连续的，在当前元素中存放下一个或上一个元素的地址。查询时需要从头部开始，一个一个的找。所以查询效率低。插入时不需要移动内存，只需改变引用指向即可。所以插入或者删除的效率高。</p>
</li>
</ul>
<p><strong>区别：</strong></p>
<p>​      ArrayList使用在查询比较多，但是插入和删除比较少的情况</p>
<p>​      而LinkedList使用在查询比较少而插入和删除比较多的情况。</p>
<h2 id="1-10-HashMap哈HashTable的区别-HashTable和ConcurrentHashMap的区别"><a href="#1-10-HashMap哈HashTable的区别-HashTable和ConcurrentHashMap的区别" class="headerlink" title="1-10.HashMap哈HashTable的区别?HashTable和ConcurrentHashMap的区别?"></a>1-10.HashMap哈HashTable的区别?HashTable和ConcurrentHashMap的区别?</h2><ul>
<li>HashMap和HasheTalbe都可以使用来存储key–value的数据。</li>
<li>HashMap是可以把null作为key或者value的，而HashTable是不可以的。</li>
<li>HashMap是线程不安全的，效率较高。而HashTalbe是线程安全的，效率较低。</li>
</ul>
<p><strong>提高：</strong></p>
<p>​    我想线程安全但是我又想效率高？</p>
<p>​        通过把整个Map分为N个Segment（类似HashTable），可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。    </p>
<p>​    </p>
<h2 id="1-11-实现一个拷贝文件的工具类使用字节流还是字符流"><a href="#1-11-实现一个拷贝文件的工具类使用字节流还是字符流" class="headerlink" title="1-11.实现一个拷贝文件的工具类使用字节流还是字符流?"></a>1-11.实现一个拷贝文件的工具类使用字节流还是字符流?</h2><p>​    拷贝的文件不确定是只包含字符流，有可以能有字节流(图片、声音、图像等)，为考虑到通用性，要使用字节流。</p>
<h2 id="1-12-线程的几种实现方式-启动方式？区分方式？"><a href="#1-12-线程的几种实现方式-启动方式？区分方式？" class="headerlink" title="1-12.线程的几种实现方式?启动方式？区分方式？"></a>1-12.线程的几种实现方式?启动方式？区分方式？</h2><ol>
<li><p>实现方式</p>
<ul>
<li>通过继承Thread类实现一个线程</li>
<li>通过实现Runnable接口实现一个线程：继承扩展性不强，java总只支持单继承，如果一个类继承Thread就不能继承其他的类了。</li>
</ul>
</li>
<li><p>启动方式</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread thread = <span class="keyword">new</span> Thread</span><br><span class="line"><span class="comment">//(继承了Thread的对象/实现了Runnable的对象)</span></span><br><span class="line">thread.setName(“设置一个线程名称”);</span><br><span class="line">thread.start();</span><br><span class="line"><span class="comment">//启动线程使用start方法，而启动了以后执行的是run方法。</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>区分方式</li>
</ol>
<p>​        在一个系统中有很多线程，每个线程都会打印日志，我想区分是哪个线程打印的怎么办？</p>
<p>​     thread.setName(“设置一个线程名称”);</p>
<p>​    这是一种规范，在创建线程完成后，都需要设置名称。</p>
<h2 id="1-13-线程并发库"><a href="#1-13-线程并发库" class="headerlink" title="1-13.线程并发库?"></a>1-13.线程并发库?</h2><p>​    JDK5中增加了Doug Lea的并发库，这一引进给Java线程的管理和使用提供了强大的便利性。</p>
<p>​     java.util.current包中提供了对线程优化、管理的各项操作，使得线程的使用变得的心应手。该包提供了线程的运行，线程池的创建，线程生命周期的控制.</p>
<p>​    Java通过Executors提供四个静态方法创建四种线程池，分别为：</p>
<ul>
<li><p><strong>newCachedThreadPool</strong>创建一个<strong>可缓存</strong>线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
</li>
<li><p><strong>newFixedThreadPool</strong> 创建一个<strong>定长线</strong>程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
</li>
<li><p><strong>newScheduledThreadPool</strong> 创建一个<strong>定长线</strong>程池，支持定时及周期性任务执行。</p>
</li>
<li><p><strong>newSingleThreadExecutor</strong> 创建一个<strong>单线程化</strong>的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p>
</li>
</ul>
<h2 id="1-14-线程池的作用？"><a href="#1-14-线程池的作用？" class="headerlink" title="1-14.线程池的作用？"></a>1-14.线程池的作用？</h2><p>1、限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p>
<p>2、线程池不需要每次都去创建或销毁，节约了资源、</p>
<p>3、线程池不需要每次都去创建，响应时间更快。</p>
<h2 id="1-15-什么是设计模式？常用的设计模式有哪些？"><a href="#1-15-什么是设计模式？常用的设计模式有哪些？" class="headerlink" title="1-15.什么是设计模式？常用的设计模式有哪些？"></a>1-15.什么是设计模式？常用的设计模式有哪些？</h2><p>​    设计模式就是经过前人无数次的实践总结出的，设计过程中可以反复使用的、可以解决特定问题的设计方法。</p>
<p><strong>常用的设计模式：</strong></p>
<ul>
<li><p>单例(饱汉模式、饥汉模式)</p>
<ul>
<li>构造方法私有化，让出了自己类中能创建外其他地方都不能创建</li>
<li>在自己的类中创建一个单实例（饱汉模式是一出来就创建创建单实例，而饥汉模式需要的时候才创建）</li>
<li>提供一个方法获取该实例对象(创建时需要进行方法同步)</li>
</ul>
</li>
<li><p>工厂模式：Spring IOC就是使用了工厂模式.</p>
<ul>
<li>对象的创建交给一个工厂去创建。</li>
</ul>
</li>
<li><p>代理模式</p>
<ul>
<li>Spring AOP就是使用的动态代理。</li>
</ul>
</li>
</ul>
<h1 id="2-javaweb"><a href="#2-javaweb" class="headerlink" title="2.javaweb"></a>2.javaweb</h1><h2 id="2-1-http中get和post请求的区别"><a href="#2-1-http中get和post请求的区别" class="headerlink" title="2-1.http中get和post请求的区别?"></a>2-1.http中get和post请求的区别?</h2><p>​    GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。</p>
<p>​    GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作，具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息</p>
<ul>
<li><p>Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</p>
<ul>
<li>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接。</li>
<li>POST提交：把提交的数据放置在是HTTP包的包体中。 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</li>
</ul>
</li>
<li><p>传输数据的大小</p>
<ul>
<li>Get请求由于浏览器对地址长度的限制而导致传输的数据有限制</li>
<li>POST请求不会因为地址长度限制而导致传输数据限制</li>
</ul>
</li>
<li><p>安全性</p>
<ul>
<li>POST的安全性要比GET的安全性高：由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息</li>
</ul>
</li>
</ul>
<h2 id="2-2-对servlet的理解？或者servlet是什么？"><a href="#2-2-对servlet的理解？或者servlet是什么？" class="headerlink" title="2-2.对servlet的理解？或者servlet是什么？"></a>2-2.对servlet的理解？或者servlet是什么？</h2><p>​    <strong>Servlet</strong>（Server Applet），全称<strong>Java Servlet</strong>， 是用Java编写的服务器端程序。而这些Sevlet都要实现Servlet这个借口。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。Servlet运行于支持Java的应用服务器中。</p>
<p>​    HttpServlet 重写doGet和doPost方法，或者你也可以重写service方法完成对get和post请求的响应。</p>
<h2 id="2-3-servlet的生命周期"><a href="#2-3-servlet的生命周期" class="headerlink" title="2-3.servlet的生命周期?"></a>2-3.servlet的生命周期?</h2><p>​    servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。</p>
<p>​    这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。</p>
<p>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化</p>
<p>—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)</p>
<ul>
<li>Servlet启动时，开始加载servlet生命周期开始。</li>
<li>Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法</li>
<li>service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等。</li>
<li>当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</li>
</ul>
<h2 id="2-4-Servlet-API中forward-与redirect-的区别？"><a href="#2-4-Servlet-API中forward-与redirect-的区别？" class="headerlink" title="2-4.Servlet API中forward() 与redirect()的区别？"></a>2-4.Servlet API中forward() 与redirect()的区别？</h2><p>1、forward是服务器端的转向而redirect是客户端的跳转。</p>
<p>2、使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p>
<p>3、Forward是一次请求中完成。而redirect是重新发起请求。</p>
<p>4、Forward是在服务器端完成，而不用客户端重新发起请求，效率较高。</p>
<h2 id="2-5-JSP和Servlet有哪些相同点和不同点"><a href="#2-5-JSP和Servlet有哪些相同点和不同点" class="headerlink" title="2-5.JSP和Servlet有哪些相同点和不同点?"></a>2-5.JSP和Servlet有哪些相同点和不同点?</h2><p>​    JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p>
<p>​    JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p>
<p>​    Servlet如果要实现html的功能，必须使用Writer输出对应的html，比较麻烦。</p>
<p>​    JSP的情况是Java和HTML，可以组合成一个扩展名为.jsp的文件，做界面展示比较方便而嵌入逻辑比较复杂。</p>
<p><img src="../images/%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B0/4.png" alt="4"></p>
<h2 id="2-6-jsp有哪些内置对象-作用分别是什么"><a href="#2-6-jsp有哪些内置对象-作用分别是什么" class="headerlink" title="2-6.jsp有哪些内置对象?作用分别是什么?"></a>2-6.jsp有哪些内置对象?作用分别是什么?</h2><p>9个内置的对象： </p>
<ul>
<li><p>request 用户端请求，此请求会包含来自GET/POST请求的参数 </p>
</li>
<li><p>response 网页传回用户端的回应 </p>
</li>
<li><p>pageContext 网页的属性是在这里管理 </p>
</li>
<li><p>session 与请求有关的会话期 </p>
</li>
<li><p>application servlet正在执行的内容 </p>
</li>
<li><p>out 用来传送回应的输出 </p>
</li>
<li><p>config servlet的构架部件 </p>
</li>
<li><p>page JSP网页本身 </p>
</li>
<li><p>exception 针对错误网页，未捕捉的例外 </p>
<p>四大作用域：pageContext 、request 、session 、application 可以通过jstl从四大作用域中取值.</p>
<p>Jsp传递值request、session 、application 、cookie也能传值</p>
</li>
</ul>
<h2 id="2-7-session和cookie的区别？你在项目中都有哪些地方使用了？"><a href="#2-7-session和cookie的区别？你在项目中都有哪些地方使用了？" class="headerlink" title="2-7.session和cookie的区别？你在项目中都有哪些地方使用了？"></a>2-7.session和cookie的区别？你在项目中都有哪些地方使用了？</h2><p>​    Session和cookie都是会话(Seesion)跟踪技术。</p>
<p>​    Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。</p>
<p>​    但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p>
<p><strong>区别：</strong></p>
<p>​    1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p>
<p>​    2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session。</p>
<p>​    3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p>
<p>​    4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p>
<p>​    5、建议：将登陆信息等重要信息存放为SESSION、 其他信息如果需要保留，可以放在COOKIE中，比如购物车</p>
<p>​    购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</p>
<h2 id="2-8-MVC的各个部分都有那些技术来实现"><a href="#2-8-MVC的各个部分都有那些技术来实现" class="headerlink" title="2-8.MVC的各个部分都有那些技术来实现?"></a>2-8.MVC的各个部分都有那些技术来实现?</h2><ul>
<li><p>M(Model) 模型 javabean</p>
</li>
<li><p>V(View) 视图  html jsp volicity freemaker</p>
</li>
<li><p>C(Control) 控制器 Servlet,Action</p>
<p>Jsp+Servlet+javabean 最经典mvc模式,实际上就是model2的实现方式，就是把视图和逻辑隔离开来</p>
</li>
</ul>
<h1 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3.数据库"></a>3.数据库</h1><h2 id="3-1-数据库的分类及常用的数据库"><a href="#3-1-数据库的分类及常用的数据库" class="headerlink" title="3-1.数据库的分类及常用的数据库"></a>3-1.数据库的分类及常用的数据库</h2><p>关系型数据库和非关系型数据库</p>
<ul>
<li>关系型：mysql oracle sqlserver等</li>
<li>非关系型：redis,memcache,mogodb,hadoop等</li>
</ul>
<h2 id="3-2-关系数据库三范式？"><a href="#3-2-关系数据库三范式？" class="headerlink" title="3-2.关系数据库三范式？"></a>3-2.关系数据库三范式？</h2><p>​    范式就是规范,就是关系型数据库在设计表时，要遵循的三个规范。</p>
<p>​    要想满足第二范式必须先满足第一范式，要满足第三范式必须先满足第二范式。</p>
<ul>
<li>第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。<strong>列数据的不可分割</strong></li>
</ul>
<ul>
<li>二范式（2NF）要求数据库表中的每个行必须可以被唯一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的唯一标识。(<strong>主键</strong>)</li>
</ul>
<ul>
<li>满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。(<strong>外键</strong>)</li>
</ul>
<ul>
<li>反三范式，有的时候为了效率，可以设置重复或者可以推导出的字段：订单（总价）和订单项（单价）</li>
</ul>
<h2 id="3-3-事务四个基本特征或-ACID-特性"><a href="#3-3-事务四个基本特征或-ACID-特性" class="headerlink" title="3-3.事务四个基本特征或 ACID 特性"></a>3-3.事务四个基本特征或 ACID 特性</h2><p>​    事务是并发控制的单位，是用户定义的一个操作序列。这些操作要么都做，要么都不做，是一个不可分割的工作单位。</p>
<p>​    如：一个转账必须 A账号扣钱成功，B账号加钱成功，才算正真的转账成功</p>
<p>​    事务必须满足四大特征：原子性、一致性、隔离性、持久性/持续性</p>
<ul>
<li>原子性：表示事务内操作不可分割。要么都成功、要么都是失败.</li>
<li>一致性：要么都成功、要么都是失败.后面的失败了要对前面的操作进行回滚。</li>
<li>隔离性：一个事务开始后，不能后其他事务干扰。</li>
<li>持久性/持续性：表示事务开始了，就不能终止。</li>
</ul>
<h2 id="3-4-mysql数据库的默认的最大连接数？"><a href="#3-4-mysql数据库的默认的最大连接数？" class="headerlink" title="3-4.mysql数据库的默认的最大连接数？"></a>3-4.mysql数据库的默认的最大连接数？</h2><p>​    100 </p>
<p>​     为什么需要最大连接数？特定服务器上面的数据库只能支持一定数目同时连接，这时候我们一般都会设置最大连接数（最多同时服务多少连接）。在数据库安装时都会有一个默认的最大连接数为100</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">max_connections=100</span><br></pre></td></tr></table></figure>



<h2 id="3-5-msyql的分页？Oracle的分页？"><a href="#3-5-msyql的分页？Oracle的分页？" class="headerlink" title="3-5.msyql的分页？Oracle的分页？"></a>3-5.msyql的分页？Oracle的分页？</h2><p>​    Mysql是使用关键字limit来进行分页的：limit、offset、size 表示从多少索引去多少位.</p>
<p>​    Oracle的分页，大部分情况下，我们是记不住了。说思路，要使用三层嵌套查询。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line">String sql &#x3D; &quot;select * from students order by id limit &quot; + pageSize*(pageNumber-1) + &quot;,&quot; + pageSize;</span><br><span class="line">	</span><br><span class="line">oracle:</span><br><span class="line">String sql &#x3D; &quot;select * from &quot; </span><br><span class="line">+  (select *,rownum rid from (select * from students order by postime desc) where rid&lt;&#x3D;&quot;</span><br><span class="line">+ pagesize*pagenumber + &quot;) as t&quot; + &quot;where t&gt;&quot; </span><br><span class="line">+ pageSize*(pageNumber-1);</span><br></pre></td></tr></table></figure>



<h2 id="3-6-数据库的触发器的使用场景？"><a href="#3-6-数据库的触发器的使用场景？" class="headerlink" title="3-6.数据库的触发器的使用场景？"></a>3-6.数据库的触发器的使用场景？</h2><p>​    触发器，需要有触发条件，当条件满足以后做什么操作。</p>
<p>​    就是在增加日志时做一个后触发，再向通知表中写入条目。因为触发器效率高，而UCH没有用触发器，效率和数据处理能力都很低。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table board1(id int primary key auto_increment,name varchar(50),articleCount int);</span><br><span class="line"></span><br><span class="line">create table article1(id int primary key auto_increment,title varchar(50),bid int references board1(id));</span><br><span class="line"></span><br><span class="line">delimiter |#把分割符;改成|</span><br><span class="line"></span><br><span class="line">create trigger insertArticle_Trigger after insert on article1 for each row begin</span><br><span class="line">    -&gt; update board1 set articleCount&#x3D;articleCount+1 where id&#x3D; NEW.bid;</span><br><span class="line">    -&gt; end;</span><br><span class="line">    -&gt; |</span><br><span class="line"></span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">insert into board1 value (null,&#39;test&#39;,0);</span><br><span class="line"></span><br><span class="line">insert into article1 value(null,&#39;test&#39;,1);</span><br></pre></td></tr></table></figure>



<h2 id="3-7-数据库的存储过程的使用场景？"><a href="#3-7-数据库的存储过程的使用场景？" class="headerlink" title="3-7.数据库的存储过程的使用场景？"></a>3-7.数据库的存储过程的使用场景？</h2><p><strong>数据库存储过程具有如下优点：</strong></p>
<p>​    1、存储过程只在创建时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次，因此使用存储过程可以大大提高数据库执行速度。</p>
<p>​    2、通常，复杂的业务逻辑需要多条 SQL 语句。这些语句要分别地从客户机发送到服务器，当客户机和服务器之间的操作很多时，将产生大量的网络传输。如果将这些操作放在一个存储过程中，那么客户机和服务器之间的网络传输就会大大减少，降低了网络负载。</p>
<p>​    3、存储过程创建一次便可以重复使用，从而可以减少数据库开发人员的工作量。</p>
<p>​    4、安全性高，存储过程可以屏蔽对底层数据库对象的直接访问，使用 EXECUTE 权限调用存储过程，无需拥有访问底层数据库对象的显式权限。</p>
<p>​    正是由于存储过程的上述优点，目前常用的数据库都支持存储过程，例如 IBM DB2，Microsoft SQL Server，Oracle，Access 等，开源数据库系统 MySQL 也在 5.0 的时候实现了对存储过程的支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create procedure insert_Student (_name varchar(50),_age int ,out _id int)</span><br><span class="line">begin</span><br><span class="line">	insert into student value(null,_name,_age);</span><br><span class="line">	select max(stuId) into _id from student;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call insert_Student(&#39;wfz&#39;,23,@id);</span><br><span class="line">select @id;</span><br></pre></td></tr></table></figure>



<h2 id="3-8-用jdbc怎么调用存储过程？"><a href="#3-8-用jdbc怎么调用存储过程？" class="headerlink" title="3-8.用jdbc怎么调用存储过程？"></a>3-8.用jdbc怎么调用存储过程？</h2><p>​    加载驱动    获取连接    设置参数    执行    释放连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Connection cn = <span class="keyword">null</span>;</span><br><span class="line">		CallableStatement cstmt = <span class="keyword">null</span>;		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//这里最好不要这么干，因为驱动名写死在程序中了</span></span><br><span class="line">			Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">			<span class="comment">//实际项目中，这里应用DataSource数据，如果用框架，</span></span><br><span class="line">			<span class="comment">//这个数据源不需要我们编码创建，我们只需Datasource ds = context.lookup()</span></span><br><span class="line">			<span class="comment">//cn = ds.getConnection();			</span></span><br><span class="line">			cn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///test"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">			cstmt = cn.prepareCall(<span class="string">"&#123;call insert_Student(?,?,?)&#125;"</span>);</span><br><span class="line">			cstmt.registerOutParameter(<span class="number">3</span>,Types.INTEGER);</span><br><span class="line">			cstmt.setString(<span class="number">1</span>, <span class="string">"wangwu"</span>);</span><br><span class="line">			cstmt.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line">			cstmt.execute();</span><br><span class="line">			<span class="comment">//get第几个，不同的数据库不一样，建议不写</span></span><br><span class="line">			System.out.println(cstmt.getString(<span class="number">3</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">if</span>(cstmt != <span class="keyword">null</span>)</span><br><span class="line">					cstmt.close();</span><br><span class="line">				<span class="keyword">if</span>(cn != <span class="keyword">null</span>)				</span><br><span class="line">					cn.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-9-对jdbc的理解？"><a href="#3-9-对jdbc的理解？" class="headerlink" title="3-9.对jdbc的理解？"></a>3-9.对jdbc的理解？</h2><p>​    Java database connection java：数据库连接</p>
<p>​    数据库管理系统(mysql oracle等)是很多，每个数据库管理系统支持的命令是不一样的。</p>
<p>​    Java只定义接口，让数据库厂商自己实现接口，对于我们者而言。只需要导入对应厂商开发的实现即可。然后以接口方式进行调用.(mysql + mysql驱动（实现）+jdbc)</p>
<p><img src="../images/%E5%85%A8%E9%9D%A2%E7%AC%94%E8%AE%B01/5.png" alt="5"></p>
<h2 id="3-10-一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序"><a href="#3-10-一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序" class="headerlink" title="3-10.一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序?"></a>3-10.一个简单的jdbc的程序。写一个访问oracle数据的jdbc程序?</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">加载驱动</span><br><span class="line">com.mysql.jdbc.Driver,oracle.jdbc.driver.OracleDriver</span><br><span class="line">获取连接</span><br><span class="line">DriverManager.getConnection(url,usernam,passord)</span><br><span class="line">设置参数</span><br><span class="line">Statement PreparedStatement cstmt.setXXX(index, value);</span><br><span class="line">执行   </span><br><span class="line">executeQuery executeUpdate</span><br><span class="line">释放连接</span><br><span class="line">是否连接要从小到大，必须放到finnaly</span><br></pre></td></tr></table></figure>



<h2 id="3-11-JDBC中的PreparedStatement相比Statement的好处"><a href="#3-11-JDBC中的PreparedStatement相比Statement的好处" class="headerlink" title="3-11.JDBC中的PreparedStatement相比Statement的好处"></a>3-11.JDBC中的PreparedStatement相比Statement的好处</h2><ol>
<li>PreparedStatement是预编译的，比Statement速度快 </li>
<li>代码的可读性和可维护性</li>
</ol>
<ol start="3">
<li>安全性</li>
</ol>
<p>​    虽然用PreparedStatement来代替Statement会使代码多出几行,但这样的代码无论从可读性还是可维护性上来说.都比直接用Statement的代码高很多档次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">两种比较：</span><br><span class="line">stmt.executeUpdate(&quot;insert into tb_name (col1,col2,col2,col4) values (&#39;&quot;+var1+&quot;&#39;,&#39;&quot;+var2+&quot;&#39;,&quot;+var3+&quot;,&#39;&quot;+var4+&quot;&#39;)&quot;); </span><br><span class="line"></span><br><span class="line">perstmt &#x3D; con.prepareStatement(&quot;insert into tb_name (col1,col2,col2,col4) values (?,?,?,?)&quot;);</span><br><span class="line">perstmt.setString(1,var1);</span><br><span class="line">perstmt.setString(2,var2);</span><br><span class="line">perstmt.setString(3,var3);</span><br><span class="line">perstmt.setString(4,var4);</span><br><span class="line">perstmt.executeUpdate();</span><br></pre></td></tr></table></figure>

<p>​    PreparedStatement可以防止SQL注入攻击，而Statement却不能。比如说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String sql &#x3D; &quot;select * from tb_name where name&#x3D; &#39;&quot;+varname+&quot;&#39; and passwd&#x3D;&#39;&quot;+varpasswd+&quot;&#39;&quot;;</span><br><span class="line"></span><br><span class="line">如果我们把[&#39; or &#39;1&#39; &#x3D; &#39;1]作为varpasswd传入进来.用户名随意,看看会成为什么?</span><br><span class="line">select * from tb_name &#x3D; &#39;随意&#39; and passwd &#x3D; &#39;&#39; or &#39;1&#39; &#x3D; &#39;1&#39;;</span><br><span class="line"></span><br><span class="line">因为&#39;1&#39;&#x3D;&#39;1&#39;肯定成立，所以可以任何通过验证，更有甚者：</span><br><span class="line">把[&#39;;drop table tb_name;]作为varpasswd传入进来,则：</span><br><span class="line">select * from tb_name &#x3D; &#39;随意&#39; and passwd &#x3D; &#39;&#39;;drop table tb_name;</span><br></pre></td></tr></table></figure>

<p>​    有些数据库是不会让你成功的，但也有很多数据库就可以使这些语句得到执行。</p>
<p>​    而如果你使用预编译语句你传入的任何内容就不会和原来的语句发生任何匹配的关系，只要全使用预编译语句你就用不着对传入的数据做任何过虑。而如果使用普通的statement,有可能要对drop等做费尽心机的判断和过虑。</p>
]]></content>
      <categories>
        <category>后端</category>
        <category>JAVA</category>
      </categories>
      <tags>
        <tag>Java面试</tag>
      </tags>
  </entry>
  <entry>
    <title>maven的使用</title>
    <url>/post/c1734c25.html</url>
    <content><![CDATA[<p>​    这是Maven的基本使用方法</p>
<a id="more"></a>

<h2 id="1-基本信息"><a href="#1-基本信息" class="headerlink" title="1.基本信息"></a>1.基本信息</h2>]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>博客的完善</title>
    <url>/post/fc7e1d6d.html</url>
    <content><![CDATA[<p>​    对博客的完善，用next主题，逐步完善功能</p>
<a id="more"></a>

<h2 id="1-主题的启用"><a href="#1-主题的启用" class="headerlink" title="1.主题的启用"></a>1.主题的启用</h2><h2 id="2-对博客改中文"><a href="#2-对博客改中文" class="headerlink" title="2.对博客改中文"></a>2.对博客改中文</h2><h2 id="3-增加标签页和分类页"><a href="#3-增加标签页和分类页" class="headerlink" title="3.增加标签页和分类页"></a>3.增加标签页和分类页</h2><h2 id="4-主题样式的改变"><a href="#4-主题样式的改变" class="headerlink" title="4.主题样式的改变"></a>4.主题样式的改变</h2><h2 id="5-更改头像和logo"><a href="#5-更改头像和logo" class="headerlink" title="5.更改头像和logo"></a>5.更改头像和logo</h2><h2 id="6-更改标题和作者"><a href="#6-更改标题和作者" class="headerlink" title="6.更改标题和作者"></a>6.更改标题和作者</h2><h2 id="7-建立一篇文章"><a href="#7-建立一篇文章" class="headerlink" title="7.建立一篇文章"></a>7.建立一篇文章</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">hexo new post "XXXXX"</span><br></pre></td></tr></table></figure>



<h2 id="8-建立友情链接"><a href="#8-建立友情链接" class="headerlink" title="8.建立友情链接"></a>8.建立友情链接</h2><h2 id="9-启动侧边栏链接"><a href="#9-启动侧边栏链接" class="headerlink" title="9.启动侧边栏链接"></a>9.启动侧边栏链接</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;linhuide || github</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>git的使用</title>
    <url>/post/2e742d51.html</url>
    <content><![CDATA[<p>​    这是Git的基本使用方法</p>
<a id="more"></a>

<h2 id="1-基本信息设置"><a href="#1-基本信息设置" class="headerlink" title="1.基本信息设置"></a>1.基本信息设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global user.name &#39;XXXXX&#39;</span><br><span class="line">用户名字设置</span><br><span class="line">git config --global user.email &#39;XXXXX@qq.com&#39;</span><br><span class="line">用户邮箱设置</span><br></pre></td></tr></table></figure>

<h2 id="2-创建文件夹"><a href="#2-创建文件夹" class="headerlink" title="2.创建文件夹"></a>2.创建文件夹</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir XXXX</span><br></pre></td></tr></table></figure>

<h2 id="3-文件内初始化git"><a href="#3-文件内初始化git" class="headerlink" title="3.文件内初始化git"></a>3.文件内初始化git</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd XXX</span><br><span class="line">进入文件夹路径</span><br><span class="line">git init</span><br><span class="line">初始化git</span><br></pre></td></tr></table></figure>

<h2 id="4-增加文件"><a href="#4-增加文件" class="headerlink" title="4.增加文件"></a>4.增加文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">查看状态</span><br><span class="line">git add XXX</span><br><span class="line">git status</span><br><span class="line">增加，查看状态</span><br><span class="line">git commit -m &#39;XXXXXXXXX&#39;</span><br><span class="line">git status</span><br><span class="line">提交，查看状态</span><br></pre></td></tr></table></figure>

<h2 id="5-修改文件"><a href="#5-修改文件" class="headerlink" title="5.修改文件"></a>5.修改文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br><span class="line">查看状态</span><br><span class="line">git add XXX</span><br><span class="line">git status</span><br><span class="line">增加，查看状态</span><br><span class="line">git commit -m &#39;XXXXXXXXX&#39;</span><br><span class="line">git status</span><br><span class="line">提交，查看状态</span><br></pre></td></tr></table></figure>

<h2 id="6-删除文件"><a href="#6-删除文件" class="headerlink" title="6.删除文件"></a>6.删除文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -f XXX（删除文件）</span><br><span class="line">删除文件</span><br><span class="line">git rm XXX</span><br><span class="line">git删除文件</span><br><span class="line">git commit -m &#39;XXXXX&#39;</span><br><span class="line">提交删除文件描述</span><br></pre></td></tr></table></figure>

<h2 id="7-远程访问仓库"><a href="#7-远程访问仓库" class="headerlink" title="7.远程访问仓库"></a>7.远程访问仓库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先克隆github上面的仓库</span><br><span class="line">git clone XXXX</span><br><span class="line">克隆</span><br><span class="line">git add XXX</span><br><span class="line">增加</span><br><span class="line">git commit -m &#39;XXXXXXXXX&#39;</span><br><span class="line">提交描述</span><br><span class="line">git push</span><br><span class="line">提交到github上面</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>后端</category>
        <category>版本管理</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>建立个人博客</title>
    <url>/post/bae8e301.html</url>
    <content><![CDATA[<p>​    创建自己的个人博客，记录步骤，希望可以帮上忙</p>
<a id="more"></a>

<h2 id="1-安装node-js"><a href="#1-安装node-js" class="headerlink" title="1.安装node.js"></a>1.安装node.js</h2><p>​    去官网下载：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p>
<p><img src="../images/%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/1.jpg" alt="1"></p>
<ul>
<li>选择好要安装的地方，安装软件。</li>
<li>一直next，其中：修改存放地址，（我自己）版本选第三个，后面的不选择</li>
<li>安装完后进行测试</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在桌面打开cmd，对node和npm进行测试</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br><span class="line">两个都有版本号，就安装成功</span><br></pre></td></tr></table></figure>

<h2 id="2-配置node"><a href="#2-配置node" class="headerlink" title="2.配置node"></a>2.配置node</h2><h3 id="1-提高空间"><a href="#1-提高空间" class="headerlink" title="1.提高空间"></a>1.提高空间</h3><p>修改npm的缓存目录和全局目录路径，将对应的模块目录改到D盘nodejs的安装目录。</p>
<p>在D盘的node的目录下创建两个目录</p>
<p><img src="../images/%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/2.jpg" alt="2"></p>
<p>因为当npm安装的模块越来越多，那么这个文件夹的体积会越来越大，直到占满你的C盘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd，代码</span><br><span class="line">npm config set prefix “D:\nodejs\node_global”   &#x2F;&#x2F;配置全局模块存放路径</span><br><span class="line">npm config set cache “D:\nodejs\node_cache”   &#x2F;&#x2F;cache路径</span><br><span class="line">测试成功</span><br><span class="line">npm config get prefix</span><br><span class="line">npm config get cache</span><br></pre></td></tr></table></figure>

<h3 id="2-在电脑配置环境变量"><a href="#2-在电脑配置环境变量" class="headerlink" title="2.在电脑配置环境变量"></a>2.在电脑配置环境变量</h3><p><img src="../images/%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/3.jpg" alt="3"></p>
<p><img src="../images/%E5%BB%BA%E7%AB%8B%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/4.jpg" alt="4"></p>
<p>​    测试配置是否成功：打开cmd，输入node，回车，再输入require(‘cluster’)，如果能正常输出cluster模块的信息，说明上面的所有配置就算生效了</p>
<h2 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h2><p>​    先在cmd，阿里的国内镜像进行加速</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<p>在自己目录下，D:\Blog\Hexo</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">打开git bush here</span><br><span class="line">开始安装</span><br><span class="line">npm i hexo-cli -g   </span><br><span class="line">安装hexo</span><br><span class="line"></span><br><span class="line">hexo -v   </span><br><span class="line">验证版本号</span><br><span class="line"></span><br><span class="line">hexo init	</span><br><span class="line">初始化文件</span><br><span class="line"></span><br><span class="line">npm install   </span><br><span class="line">安装必备的组件</span><br><span class="line"></span><br><span class="line">hexo g	</span><br><span class="line">生成静态网页</span><br><span class="line"></span><br><span class="line">hexo s	</span><br><span class="line">打开本地服务器</span><br><span class="line"></span><br><span class="line">浏览器打开	</span><br><span class="line">http:&#x2F;&#x2F;localhost:4000</span><br><span class="line"></span><br><span class="line">Ctrl+C，关闭服务器</span><br></pre></td></tr></table></figure>

<h2 id="4-配置github"><a href="#4-配置github" class="headerlink" title="4.配置github"></a>4.配置github</h2><p>在目录下，D:\Blog\Hexo</p>
<p>打开git bush here</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"XXXXX"</span></span><br><span class="line">git config --global user.email <span class="string">"XXXX@qq.com"</span></span><br><span class="line">配置名字和邮箱</span><br><span class="line"></span><br><span class="line">然后生成密钥SSH key：</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"XXXXX@qq.com"</span></span><br><span class="line"></span><br><span class="line">获取秘钥</span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line">复制</span><br><span class="line"></span><br><span class="line">打开github，点击settings，点击SSH and GPG keys,新建一个ssh，名字随便，秘钥复制到下面框中。</span><br><span class="line"></span><br><span class="line">打开git bush here</span><br><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">结果出现你的用户名，那就成功了。</span><br></pre></td></tr></table></figure>



<p>打开D:\Blog\Hexo下的_config.yml</p>
<p>修改最后一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: https://github.com/XXXXX/XXXXX.github.io。git（建议直接复制URL过来）</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<h2 id="5-上传博客"><a href="#5-上传博客" class="headerlink" title="5.上传博客"></a>5.上传博客</h2><p>打开git bush here</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line">hexo g</span><br><span class="line"></span><br><span class="line">hexo d</span><br><span class="line">上传到github</span><br><span class="line">出现Deploy done：git，表示成功，可以登录</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;XXXXXXX.github.io&#x2F;</span><br><span class="line">没有登录成功，消除缓存，等待响应</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/post/ff05b5bf.html</url>
    <content><![CDATA[<p>创建第一篇博客，希望再接再厉</p>
]]></content>
  </entry>
</search>
